<!DOCTYPE html><html><head><meta charset="utf-8"><title>Untitled Document.md</title><style>@charset "UTF-8";@import 'https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0-alpha2/katex.min.css';code{color:#c7254e;background-color:#f9f2f4;border-radius:4px}code,kbd{padding:2px 4px}kbd{color:#fff;background-color:#333;border-radius:3px;box-shadow:inset 0 -1px 0 rgba(0,0,0,.25)}kbd kbd{padding:0;font-size:100%;box-shadow:none}pre{display:block;margin:0 0 10px;word-break:break-all;word-wrap:break-word;color:#333;background-color:#f5f5f5;border:1px solid #ccc;border-radius:4px}pre code{padding:0;font-size:inherit;color:inherit;white-space:pre-wrap;background-color:transparent;border-radius:0}.pre-scrollable{max-height:340px;overflow-y:scroll}table{background-color:transparent}th{text-align:left}.table{width:100%;max-width:100%;margin-bottom:20px}.table>thead>tr>th{padding:8px;line-height:1.4285714;border-top:1px solid #ddd}.table>thead>tr>td,.table>tbody>tr>th,.table>tbody>tr>td,.table>tfoot>tr>th,.table>tfoot>tr>td{padding:8px;line-height:1.4285714;vertical-align:top;border-top:1px solid #ddd}.table>thead>tr>th{vertical-align:bottom;border-bottom:2px solid #ddd}.table>caption+thead>tr:first-child>th,.table>caption+thead>tr:first-child>td,.table>colgroup+thead>tr:first-child>th,.table>colgroup+thead>tr:first-child>td,.table>thead:first-child>tr:first-child>th,.table>thead:first-child>tr:first-child>td{border-top:0}.table>tbody+tbody{border-top:2px solid #ddd}.table .table{background-color:#fff}.table-condensed>thead>tr>th,.table-condensed>thead>tr>td,.table-condensed>tbody>tr>th,.table-condensed>tbody>tr>td,.table-condensed>tfoot>tr>th,.table-condensed>tfoot>tr>td{padding:5px}.table-bordered,.table-bordered>thead>tr>th,.table-bordered>thead>tr>td,.table-bordered>tbody>tr>th,.table-bordered>tbody>tr>td,.table-bordered>tfoot>tr>th,.table-bordered>tfoot>tr>td{border:1px solid #ddd}.table-bordered>thead>tr>th,.table-bordered>thead>tr>td{border-bottom-width:2px}.table-striped>tbody>tr:nth-child(odd)>td,.table-striped>tbody>tr:nth-child(odd)>th{background-color:#f9f9f9}.table-hover>tbody>tr:hover>td,.table-hover>tbody>tr:hover>th{background-color:#f5f5f5}table col[class*="col-"]{position:static;float:none;display:table-column}table td[class*="col-"],table th[class*="col-"]{position:static;float:none;display:table-cell}.table>thead>tr>td.active,.table>thead>tr>th.active,.table>thead>tr.active>td,.table>thead>tr.active>th,.table>tbody>tr>td.active,.table>tbody>tr>th.active,.table>tbody>tr.active>td,.table>tbody>tr.active>th,.table>tfoot>tr>td.active,.table>tfoot>tr>th.active,.table>tfoot>tr.active>td,.table>tfoot>tr.active>th{background-color:#f5f5f5}.table-hover>tbody>tr>td.active:hover,.table-hover>tbody>tr>th.active:hover,.table-hover>tbody>tr.active:hover>td,.table-hover>tbody>tr:hover>.active,.table-hover>tbody>tr.active:hover>th{background-color:#e8e8e8}.table>thead>tr>td.success,.table>thead>tr>th.success,.table>thead>tr.success>td,.table>thead>tr.success>th,.table>tbody>tr>td.success,.table>tbody>tr>th.success,.table>tbody>tr.success>td,.table>tbody>tr.success>th,.table>tfoot>tr>td.success,.table>tfoot>tr>th.success,.table>tfoot>tr.success>td,.table>tfoot>tr.success>th{background-color:#dff0d8}.table-hover>tbody>tr>td.success:hover,.table-hover>tbody>tr>th.success:hover,.table-hover>tbody>tr.success:hover>td,.table-hover>tbody>tr:hover>.success,.table-hover>tbody>tr.success:hover>th{background-color:#d0e9c6}.table>thead>tr>td.info,.table>thead>tr>th.info,.table>thead>tr.info>td,.table>thead>tr.info>th,.table>tbody>tr>td.info,.table>tbody>tr>th.info,.table>tbody>tr.info>td,.table>tbody>tr.info>th,.table>tfoot>tr>td.info,.table>tfoot>tr>th.info,.table>tfoot>tr.info>td,.table>tfoot>tr.info>th{background-color:#d9edf7}.table-hover>tbody>tr>td.info:hover,.table-hover>tbody>tr>th.info:hover,.table-hover>tbody>tr.info:hover>td,.table-hover>tbody>tr:hover>.info,.table-hover>tbody>tr.info:hover>th{background-color:#c4e3f3}.table>thead>tr>td.warning,.table>thead>tr>th.warning,.table>thead>tr.warning>td,.table>thead>tr.warning>th,.table>tbody>tr>td.warning,.table>tbody>tr>th.warning,.table>tbody>tr.warning>td,.table>tbody>tr.warning>th,.table>tfoot>tr>td.warning,.table>tfoot>tr>th.warning,.table>tfoot>tr.warning>td,.table>tfoot>tr.warning>th{background-color:#fcf8e3}.table-hover>tbody>tr>td.warning:hover,.table-hover>tbody>tr>th.warning:hover,.table-hover>tbody>tr.warning:hover>td,.table-hover>tbody>tr:hover>.warning,.table-hover>tbody>tr.warning:hover>th{background-color:#faf2cc}.table>thead>tr>td.danger,.table>thead>tr>th.danger,.table>thead>tr.danger>td,.table>thead>tr.danger>th,.table>tbody>tr>td.danger,.table>tbody>tr>th.danger,.table>tbody>tr.danger>td,.table>tbody>tr.danger>th,.table>tfoot>tr>td.danger,.table>tfoot>tr>th.danger,.table>tfoot>tr.danger>td,.table>tfoot>tr.danger>th{background-color:#f2dede}.table-hover>tbody>tr>td.danger:hover,.table-hover>tbody>tr>th.danger:hover,.table-hover>tbody>tr.danger:hover>td,.table-hover>tbody>tr:hover>.danger,.table-hover>tbody>tr.danger:hover>th{background-color:#ebcccc}fieldset{border:0;min-width:0}legend{display:block;width:100%;margin-bottom:20px;font-size:21px;line-height:inherit;color:#333;border-bottom:1px solid #e5e5e5}label{display:inline-block;max-width:100%;margin-bottom:5px;font-weight:700}input[type="radio"],input[type="checkbox"]{margin:4px 0 0;margin-top:1px \9;line-height:normal}input[type="file"]{display:block}input[type="range"]{display:block;width:100%}select[multiple],select[size]{height:auto}input[type="file"]:focus,input[type="radio"]:focus,input[type="checkbox"]:focus{outline:thin dotted;outline:5px auto -webkit-focus-ring-color;outline-offset:-2px}output{padding-top:7px}output,.form-control{display:block;font-size:14px;line-height:1.4285714;color:#555}.form-control{width:100%;height:34px;padding:6px 12px;background-color:#fff;background-image:none;border:1px solid #ccc;border-radius:4px;box-shadow:inset 0 1px 1px rgba(0,0,0,.075);transition:border-color ease-in-out .15s,box-shadow ease-in-out .15s}.form-control:focus{border-color:#66afe9;outline:0;box-shadow:inset 0 1px 1px rgba(0,0,0,.075),0 0 8px rgba(102,175,233,.6)}.form-control::-moz-placeholder{color:#777;opacity:1}.form-control:-ms-input-placeholder{color:#777}.form-control::-webkit-input-placeholder{color:#777}.form-control[disabled],.form-control[readonly],fieldset[disabled] .form-control{cursor:not-allowed;background-color:#eee;opacity:1}textarea.form-control{height:auto}input[type="date"],input[type="time"],input[type="datetime-local"],input[type="month"]{line-height:34px;line-height:1.4285714 \0}input[type="date"].input-sm,.form-horizontal .form-group-sm input.form-control[type="date"],.input-group-sm>input.form-control[type="date"],.input-group-sm>input.input-group-addon[type="date"],.input-group-sm>.input-group-btn>input.btn[type="date"],input[type="time"].input-sm,.form-horizontal .form-group-sm input.form-control[type="time"],.input-group-sm>input.form-control[type="time"],.input-group-sm>input.input-group-addon[type="time"],.input-group-sm>.input-group-btn>input.btn[type="time"],input[type="datetime-local"].input-sm,.form-horizontal .form-group-sm input.form-control[type="datetime-local"],.input-group-sm>input.form-control[type="datetime-local"],.input-group-sm>input.input-group-addon[type="datetime-local"],.input-group-sm>.input-group-btn>input.btn[type="datetime-local"],input[type="month"].input-sm,.form-horizontal .form-group-sm input.form-control[type="month"],.input-group-sm>input.form-control[type="month"],.input-group-sm>input.input-group-addon[type="month"],.input-group-sm>.input-group-btn>input.btn[type="month"]{line-height:30px}input[type="date"].input-lg,.form-horizontal .form-group-lg input.form-control[type="date"],.input-group-lg>input.form-control[type="date"],.input-group-lg>input.input-group-addon[type="date"],.input-group-lg>.input-group-btn>input.btn[type="date"],input[type="time"].input-lg,.form-horizontal .form-group-lg input.form-control[type="time"],.input-group-lg>input.form-control[type="time"],.input-group-lg>input.input-group-addon[type="time"],.input-group-lg>.input-group-btn>input.btn[type="time"],input[type="datetime-local"].input-lg,.form-horizontal .form-group-lg input.form-control[type="datetime-local"],.input-group-lg>input.form-control[type="datetime-local"],.input-group-lg>input.input-group-addon[type="datetime-local"],.input-group-lg>.input-group-btn>input.btn[type="datetime-local"],input[type="month"].input-lg,.form-horizontal .form-group-lg input.form-control[type="month"],.input-group-lg>input.form-control[type="month"],.input-group-lg>input.input-group-addon[type="month"],.input-group-lg>.input-group-btn>input.btn[type="month"]{line-height:46px}.form-group{margin-bottom:15px}.radio,.checkbox{position:relative;display:block;min-height:20px;margin-top:10px;margin-bottom:10px}.radio label,.checkbox label{padding-left:20px;margin-bottom:0;font-weight:400;cursor:pointer}.radio input[type="radio"],.radio-inline input[type="radio"],.checkbox input[type="checkbox"],.checkbox-inline input[type="checkbox"]{position:absolute;margin-left:-20px;margin-top:4px \9}.radio+.radio,.checkbox+.checkbox{margin-top:-5px}.radio-inline,.checkbox-inline{display:inline-block;padding-left:20px;margin-bottom:0;vertical-align:middle;font-weight:400;cursor:pointer}.radio-inline+.radio-inline,.checkbox-inline+.checkbox-inline{margin-top:0;margin-left:10px}input[type="radio"][disabled],input[type="radio"].disabled,fieldset[disabled] input[type="radio"],input[type="checkbox"][disabled],input[type="checkbox"].disabled,fieldset[disabled] input[type="checkbox"],.radio-inline.disabled,fieldset[disabled] .radio-inline,.checkbox-inline.disabled,fieldset[disabled] .checkbox-inline,.radio.disabled label,fieldset[disabled] .radio label,.checkbox.disabled label,fieldset[disabled] .checkbox label{cursor:not-allowed}.form-control-static{padding-top:7px;padding-bottom:7px;margin-bottom:0}.form-control-static.input-lg,.form-horizontal .form-group-lg .form-control-static.form-control,.input-group-lg>.form-control-static.form-control,.input-group-lg>.form-control-static.input-group-addon,.input-group-lg>.input-group-btn>.form-control-static.btn,.form-control-static.input-sm,.form-horizontal .form-group-sm .form-control-static.form-control,.input-group-sm>.form-control-static.form-control,.input-group-sm>.form-control-static.input-group-addon,.input-group-sm>.input-group-btn>.form-control-static.btn{padding-left:0;padding-right:0}.input-sm,.form-horizontal .form-group-sm .form-control,.input-group-sm>.form-control{height:30px;padding:5px 10px;font-size:12px;line-height:1.5;border-radius:3px}.input-group-sm>.input-group-addon{height:30px;line-height:1.5}.input-group-sm>.input-group-btn>.btn{height:30px;padding:5px 10px;font-size:12px;line-height:1.5;border-radius:3px}select.input-sm,.form-horizontal .form-group-sm select.form-control,.input-group-sm>select.form-control,.input-group-sm>select.input-group-addon,.input-group-sm>.input-group-btn>select.btn{height:30px;line-height:30px}textarea.input-sm,.form-horizontal .form-group-sm textarea.form-control,.input-group-sm>textarea.form-control,.input-group-sm>textarea.input-group-addon,.input-group-sm>.input-group-btn>textarea.btn,select[multiple].input-sm,.form-horizontal .form-group-sm select.form-control[multiple],.input-group-sm>select.form-control[multiple],.input-group-sm>select.input-group-addon[multiple],.input-group-sm>.input-group-btn>select.btn[multiple]{height:auto}.input-lg,.form-horizontal .form-group-lg .form-control,.input-group-lg>.form-control{height:46px;padding:10px 16px;font-size:18px;line-height:1.33;border-radius:6px}.input-group-lg>.input-group-addon{height:46px;line-height:1.33}.input-group-lg>.input-group-btn>.btn{height:46px;padding:10px 16px;font-size:18px;line-height:1.33;border-radius:6px}select.input-lg,.form-horizontal .form-group-lg select.form-control,.input-group-lg>select.form-control,.input-group-lg>select.input-group-addon,.input-group-lg>.input-group-btn>select.btn{height:46px;line-height:46px}textarea.input-lg,.form-horizontal .form-group-lg textarea.form-control,.input-group-lg>textarea.form-control,.input-group-lg>textarea.input-group-addon,.input-group-lg>.input-group-btn>textarea.btn,select[multiple].input-lg,.form-horizontal .form-group-lg select.form-control[multiple],.input-group-lg>select.form-control[multiple],.input-group-lg>select.input-group-addon[multiple],.input-group-lg>.input-group-btn>select.btn[multiple]{height:auto}.has-feedback{position:relative}.has-feedback .form-control{padding-right:42.5px}.form-control-feedback{position:absolute;top:25px;right:0;z-index:2;display:block;width:34px;height:34px;line-height:34px;text-align:center}.input-lg+.form-control-feedback,.form-horizontal .form-group-lg .form-control+.form-control-feedback,.input-group-lg>.form-control+.form-control-feedback,.input-group-lg>.input-group-addon+.form-control-feedback,.input-group-lg>.input-group-btn>.btn+.form-control-feedback{width:46px;height:46px;line-height:46px}.input-sm+.form-control-feedback,.form-horizontal .form-group-sm .form-control+.form-control-feedback,.input-group-sm>.form-control+.form-control-feedback,.input-group-sm>.input-group-addon+.form-control-feedback,.input-group-sm>.input-group-btn>.btn+.form-control-feedback{width:30px;height:30px;line-height:30px}.has-success .help-block,.has-success .control-label,.has-success .radio,.has-success .checkbox,.has-success .radio-inline,.has-success .checkbox-inline{color:#3c763d}.has-success .form-control{border-color:#3c763d;box-shadow:inset 0 1px 1px rgba(0,0,0,.075)}.has-success .form-control:focus{border-color:#2b542c;box-shadow:inset 0 1px 1px rgba(0,0,0,.075),0 0 6px #67b168}.has-success .input-group-addon{color:#3c763d;border-color:#3c763d;background-color:#dff0d8}.has-success .form-control-feedback{color:#3c763d}.has-warning .help-block,.has-warning .control-label,.has-warning .radio,.has-warning .checkbox,.has-warning .radio-inline,.has-warning .checkbox-inline{color:#8a6d3b}.has-warning .form-control{border-color:#8a6d3b;box-shadow:inset 0 1px 1px rgba(0,0,0,.075)}.has-warning .form-control:focus{border-color:#66512c;box-shadow:inset 0 1px 1px rgba(0,0,0,.075),0 0 6px #c0a16b}.has-warning .input-group-addon{color:#8a6d3b;border-color:#8a6d3b;background-color:#fcf8e3}.has-warning .form-control-feedback{color:#8a6d3b}.has-error .help-block,.has-error .control-label,.has-error .radio,.has-error .checkbox,.has-error .radio-inline,.has-error .checkbox-inline{color:#a94442}.has-error .form-control{border-color:#a94442;box-shadow:inset 0 1px 1px rgba(0,0,0,.075)}.has-error .form-control:focus{border-color:#843534;box-shadow:inset 0 1px 1px rgba(0,0,0,.075),0 0 6px #ce8483}.has-error .input-group-addon{color:#a94442;border-color:#a94442;background-color:#f2dede}.has-error .form-control-feedback{color:#a94442}.has-feedback label.sr-only~.form-control-feedback{top:0}.help-block{display:block;margin-top:5px;margin-bottom:10px;color:#737373}.form-horizontal .radio,.form-horizontal .checkbox,.form-horizontal .radio-inline,.form-horizontal .checkbox-inline{margin-top:0;margin-bottom:0;padding-top:7px}.form-horizontal .radio,.form-horizontal .checkbox{min-height:27px}.form-horizontal .form-group{margin-left:-15px;margin-right:-15px}.form-horizontal .form-group:before{content:" ";display:table}.form-horizontal .form-group:after{content:" ";display:table;clear:both}.form-horizontal .has-feedback .form-control-feedback{top:0;right:15px}.btn{display:inline-block;vertical-align:middle;cursor:pointer;background-image:none;border:1px solid transparent;white-space:nowrap;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.btn:focus,.btn:active:focus,.btn.active:focus{outline:thin dotted;outline:5px auto -webkit-focus-ring-color;outline-offset:-2px}.btn:hover,.btn:focus{color:#333;text-decoration:none}.btn:active,.btn.active{outline:0;background-image:none;box-shadow:inset 0 3px 5px rgba(0,0,0,.125)}.btn.disabled,.btn[disabled],fieldset[disabled] .btn{cursor:not-allowed;pointer-events:none;opacity:.65;filter:alpha(opacity=65);box-shadow:none}.btn-default{color:#333;background-color:#fff;border-color:#ccc}.btn-default:hover,.btn-default:focus,.btn-default:active,.btn-default.active,.open>.btn-default.dropdown-toggle{color:#333;background-color:#e6e6e6;border-color:#adadad}.btn-default:active,.btn-default.active,.open>.btn-default.dropdown-toggle{background-image:none}.btn-default.disabled,.btn-default.disabled:hover,.btn-default.disabled:focus,.btn-default.disabled:active,.btn-default.disabled.active,.btn-default[disabled],.btn-default[disabled]:hover,.btn-default[disabled]:focus,.btn-default[disabled]:active,.btn-default[disabled].active,fieldset[disabled] .btn-default,fieldset[disabled] .btn-default:hover,fieldset[disabled] .btn-default:focus,fieldset[disabled] .btn-default:active,fieldset[disabled] .btn-default.active{background-color:#fff;border-color:#ccc}.btn-default .badge{color:#fff;background-color:#333}.btn-primary{color:#fff;background-color:#428bca;border-color:#357ebd}.btn-primary:hover,.btn-primary:focus,.btn-primary:active,.btn-primary.active,.open>.btn-primary.dropdown-toggle{color:#fff;background-color:#3071a9;border-color:#285e8e}.btn-primary:active,.btn-primary.active,.open>.btn-primary.dropdown-toggle{background-image:none}.btn-primary.disabled,.btn-primary.disabled:hover,.btn-primary.disabled:focus,.btn-primary.disabled:active,.btn-primary.disabled.active,.btn-primary[disabled],.btn-primary[disabled]:hover,.btn-primary[disabled]:focus,.btn-primary[disabled]:active,.btn-primary[disabled].active,fieldset[disabled] .btn-primary,fieldset[disabled] .btn-primary:hover,fieldset[disabled] .btn-primary:focus,fieldset[disabled] .btn-primary:active,fieldset[disabled] .btn-primary.active{background-color:#428bca;border-color:#357ebd}.btn-primary .badge{color:#428bca;background-color:#fff}.btn-success{color:#fff;background-color:#5cb85c;border-color:#4cae4c}.btn-success:hover,.btn-success:focus,.btn-success:active,.btn-success.active,.open>.btn-success.dropdown-toggle{color:#fff;background-color:#449d44;border-color:#398439}.btn-success:active,.btn-success.active,.open>.btn-success.dropdown-toggle{background-image:none}.btn-success.disabled,.btn-success.disabled:hover,.btn-success.disabled:focus,.btn-success.disabled:active,.btn-success.disabled.active,.btn-success[disabled],.btn-success[disabled]:hover,.btn-success[disabled]:focus,.btn-success[disabled]:active,.btn-success[disabled].active,fieldset[disabled] .btn-success,fieldset[disabled] .btn-success:hover,fieldset[disabled] .btn-success:focus,fieldset[disabled] .btn-success:active,fieldset[disabled] .btn-success.active{background-color:#5cb85c;border-color:#4cae4c}.btn-success .badge{color:#5cb85c;background-color:#fff}.btn-info{color:#fff;background-color:#5bc0de;border-color:#46b8da}.btn-info:hover,.btn-info:focus,.btn-info:active,.btn-info.active,.open>.btn-info.dropdown-toggle{color:#fff;background-color:#31b0d5;border-color:#269abc}.btn-info:active,.btn-info.active,.open>.btn-info.dropdown-toggle{background-image:none}.btn-info.disabled,.btn-info.disabled:hover,.btn-info.disabled:focus,.btn-info.disabled:active,.btn-info.disabled.active,.btn-info[disabled],.btn-info[disabled]:hover,.btn-info[disabled]:focus,.btn-info[disabled]:active,.btn-info[disabled].active,fieldset[disabled] .btn-info,fieldset[disabled] .btn-info:hover,fieldset[disabled] .btn-info:focus,fieldset[disabled] .btn-info:active,fieldset[disabled] .btn-info.active{background-color:#5bc0de;border-color:#46b8da}.btn-info .badge{color:#5bc0de;background-color:#fff}.btn-warning{color:#fff;background-color:#f0ad4e;border-color:#eea236}.btn-warning:hover,.btn-warning:focus,.btn-warning:active,.btn-warning.active,.open>.btn-warning.dropdown-toggle{color:#fff;background-color:#ec971f;border-color:#d58512}.btn-warning:active,.btn-warning.active,.open>.btn-warning.dropdown-toggle{background-image:none}.btn-warning.disabled,.btn-warning.disabled:hover,.btn-warning.disabled:focus,.btn-warning.disabled:active,.btn-warning.disabled.active,.btn-warning[disabled],.btn-warning[disabled]:hover,.btn-warning[disabled]:focus,.btn-warning[disabled]:active,.btn-warning[disabled].active,fieldset[disabled] .btn-warning,fieldset[disabled] .btn-warning:hover,fieldset[disabled] .btn-warning:focus,fieldset[disabled] .btn-warning:active,fieldset[disabled] .btn-warning.active{background-color:#f0ad4e;border-color:#eea236}.btn-warning .badge{color:#f0ad4e;background-color:#fff}.btn-danger{color:#fff;background-color:#d9534f;border-color:#d43f3a}.btn-danger:hover,.btn-danger:focus,.btn-danger:active,.btn-danger.active,.open>.btn-danger.dropdown-toggle{color:#fff;background-color:#c9302c;border-color:#ac2925}.btn-danger:active,.btn-danger.active,.open>.btn-danger.dropdown-toggle{background-image:none}.btn-danger.disabled,.btn-danger.disabled:hover,.btn-danger.disabled:focus,.btn-danger.disabled:active,.btn-danger.disabled.active,.btn-danger[disabled],.btn-danger[disabled]:hover,.btn-danger[disabled]:focus,.btn-danger[disabled]:active,.btn-danger[disabled].active,fieldset[disabled] .btn-danger,fieldset[disabled] .btn-danger:hover,fieldset[disabled] .btn-danger:focus,fieldset[disabled] .btn-danger:active,fieldset[disabled] .btn-danger.active{background-color:#d9534f;border-color:#d43f3a}.btn-danger .badge{color:#d9534f;background-color:#fff}.btn-link{color:#428bca;font-weight:400;cursor:pointer;border-radius:0}.btn-link,.btn-link:active,.btn-link[disabled],fieldset[disabled] .btn-link{background-color:transparent;box-shadow:none}.btn-link,.btn-link:hover,.btn-link:focus,.btn-link:active{border-color:transparent}.btn-link:hover,.btn-link:focus{color:#2a6496;text-decoration:underline;background-color:transparent}.btn-link[disabled]:hover,.btn-link[disabled]:focus,fieldset[disabled] .btn-link:hover,fieldset[disabled] .btn-link:focus{color:#777;text-decoration:none}.btn-lg{padding:10px 16px;font-size:18px;line-height:1.33;border-radius:6px}.btn-sm{padding:5px 10px}.btn-sm,.btn-xs{font-size:12px;line-height:1.5;border-radius:3px}.btn-xs{padding:1px 5px}.btn-block{display:block;width:100%}.btn-block+.btn-block{margin-top:5px}input[type="submit"].btn-block,input[type="reset"].btn-block,input[type="button"].btn-block{width:100%}.fade{opacity:0;transition:opacity .15s linear}.fade.in{opacity:1}.collapse{display:none}.collapse.in{display:block}tr.collapse.in{display:table-row}tbody.collapse.in{display:table-row-group}.collapsing{position:relative;height:0;overflow:hidden;transition:height .35s ease}.input-group{position:relative;display:table;border-collapse:separate}.input-group[class*="col-"]{float:none;padding-left:0;padding-right:0}.input-group .form-control{position:relative;z-index:2;float:left;width:100%;margin-bottom:0}.input-group-addon,.input-group-btn,.input-group .form-control{display:table-cell}.input-group-addon:not(:first-child):not(:last-child),.input-group-btn:not(:first-child):not(:last-child),.input-group .form-control:not(:first-child):not(:last-child){border-radius:0}.input-group-addon{white-space:nowrap}.input-group-addon,.input-group-btn{width:1%;vertical-align:middle}.input-group-addon{padding:6px 12px;font-size:14px;font-weight:400;line-height:1;color:#555;text-align:center;background-color:#eee;border:1px solid #ccc;border-radius:4px}.input-group-addon.input-sm,.form-horizontal .form-group-sm .input-group-addon.form-control,.input-group-sm>.input-group-addon,.input-group-sm>.input-group-btn>.input-group-addon.btn{padding:5px 10px;font-size:12px;border-radius:3px}.input-group-addon.input-lg,.form-horizontal .form-group-lg .input-group-addon.form-control,.input-group-lg>.input-group-addon,.input-group-lg>.input-group-btn>.input-group-addon.btn{padding:10px 16px;font-size:18px;border-radius:6px}.input-group-addon input[type="radio"],.input-group-addon input[type="checkbox"]{margin-top:0}.input-group .form-control:first-child,.input-group-addon:first-child,.input-group-btn:first-child>.btn,.input-group-btn:first-child>.btn-group>.btn,.input-group-btn:first-child>.dropdown-toggle,.input-group-btn:last-child>.btn:not(:last-child):not(.dropdown-toggle),.input-group-btn:last-child>.btn-group:not(:last-child)>.btn{border-bottom-right-radius:0;border-top-right-radius:0}.input-group-addon:first-child{border-right:0}.input-group .form-control:last-child,.input-group-addon:last-child,.input-group-btn:last-child>.btn,.input-group-btn:last-child>.btn-group>.btn,.input-group-btn:last-child>.dropdown-toggle,.input-group-btn:first-child>.btn:not(:first-child),.input-group-btn:first-child>.btn-group:not(:first-child)>.btn{border-bottom-left-radius:0;border-top-left-radius:0}.input-group-addon:last-child{border-left:0}.input-group-btn{font-size:0;white-space:nowrap}.input-group-btn,.input-group-btn>.btn{position:relative}.input-group-btn>.btn+.btn{margin-left:-1px}.input-group-btn>.btn:hover,.input-group-btn>.btn:focus,.input-group-btn>.btn:active{z-index:2}.input-group-btn:first-child>.btn,.input-group-btn:first-child>.btn-group{margin-right:-1px}.input-group-btn:last-child>.btn,.input-group-btn:last-child>.btn-group{margin-left:-1px}.pagination{display:inline-block;padding-left:0;margin:20px 0;border-radius:4px}.pagination>li{display:inline}.pagination>li>a,.pagination>li>span{position:relative;float:left;padding:6px 12px;line-height:1.4285714;text-decoration:none;color:#428bca;background-color:#fff;border:1px solid #ddd;margin-left:-1px}.pagination>li:first-child>a,.pagination>li:first-child>span{margin-left:0;border-bottom-left-radius:4px;border-top-left-radius:4px}.pagination>li:last-child>a,.pagination>li:last-child>span{border-bottom-right-radius:4px;border-top-right-radius:4px}.pagination>li>a:hover,.pagination>li>a:focus,.pagination>li>span:hover,.pagination>li>span:focus{color:#2a6496;background-color:#eee;border-color:#ddd}.pagination>.active>a,.pagination>.active>a:hover,.pagination>.active>a:focus,.pagination>.active>span,.pagination>.active>span:hover,.pagination>.active>span:focus{z-index:2;color:#fff;background-color:#428bca;border-color:#428bca;cursor:default}.pagination>.disabled>span,.pagination>.disabled>span:hover,.pagination>.disabled>span:focus,.pagination>.disabled>a,.pagination>.disabled>a:hover,.pagination>.disabled>a:focus{color:#777;background-color:#fff;border-color:#ddd;cursor:not-allowed}.pagination-lg>li>a,.pagination-lg>li>span{padding:10px 16px;font-size:18px}.pagination-lg>li:first-child>a,.pagination-lg>li:first-child>span{border-bottom-left-radius:6px;border-top-left-radius:6px}.pagination-lg>li:last-child>a,.pagination-lg>li:last-child>span{border-bottom-right-radius:6px;border-top-right-radius:6px}.pagination-sm>li>a,.pagination-sm>li>span{padding:5px 10px;font-size:12px}.pagination-sm>li:first-child>a,.pagination-sm>li:first-child>span{border-bottom-left-radius:3px;border-top-left-radius:3px}.pagination-sm>li:last-child>a,.pagination-sm>li:last-child>span{border-bottom-right-radius:3px;border-top-right-radius:3px}.close{float:right;font-size:21px;font-weight:700;line-height:1;color:#000;text-shadow:0 1px 0 #fff;opacity:.2;filter:alpha(opacity=20)}.close:hover,.close:focus{color:#000;text-decoration:none;cursor:pointer;opacity:.5;filter:alpha(opacity=50)}button.close{padding:0;cursor:pointer;background:0 0;border:0;-webkit-appearance:none}.modal-open,.modal{overflow:hidden}.modal{display:none;position:fixed;top:0;right:0;bottom:0;left:0;z-index:1050;-webkit-overflow-scrolling:touch;outline:0}.modal.fade .modal-dialog{transform:translate3d(0,-25%,0);transition:transform .3s ease-out}.modal.in .modal-dialog{transform:translate3d(0,0,0)}.modal-open .modal{overflow-x:hidden;overflow-y:auto}.modal-dialog{position:relative;width:auto;margin:10px}.modal-content{position:relative;background-color:#fff;border:1px solid #999;border:1px solid rgba(0,0,0,.2);border-radius:6px;box-shadow:0 3px 9px rgba(0,0,0,.5);background-clip:padding-box;outline:0}.modal-backdrop{position:fixed;top:0;right:0;bottom:0;left:0;z-index:1040;background-color:#000}.modal-backdrop.fade{opacity:0;filter:alpha(opacity=0)}.modal-backdrop.in{opacity:.5;filter:alpha(opacity=50)}.modal-header{padding:15px;border-bottom:1px solid #e5e5e5;min-height:16.4285714px}.modal-header .close{margin-top:-2px}.modal-title{margin:0;line-height:1.4285714}.modal-body{position:relative;padding:15px}.modal-footer{padding:15px;text-align:right;border-top:1px solid #e5e5e5}.modal-footer:before,.modal-footer:after{content:" ";display:table}.modal-footer:after{clear:both}.modal-footer .btn+.btn{margin-left:5px;margin-bottom:0}.modal-footer .btn-group .btn+.btn{margin-left:-1px}.modal-footer .btn-block+.btn-block{margin-left:0}.modal-scrollbar-measure{position:absolute;top:-9999px;width:50px;height:50px;overflow:scroll}.clearfix:before,.clearfix:after{content:" ";display:table}.clearfix:after{clear:both}.center-block{display:block;margin-left:auto;margin-right:auto}.pull-right{float:right!important}.pull-left{float:left!important}.hide{display:none!important}.show{display:block!important}.invisible{visibility:hidden}.text-hide{font:0/0 a;color:transparent;text-shadow:none;background-color:transparent;border:0}.hidden{display:none!important;visibility:hidden!important}.affix{position:fixed;transform:translate3d(0,0,0)}.hljs{display:block;overflow-x:auto;padding:.5em;background:#002b36;color:#839496;-webkit-text-size-adjust:none}.hljs-comment,.hljs-template_comment,.diff .hljs-header,.hljs-doctype,.hljs-pi,.lisp .hljs-string,.hljs-javadoc{color:#586e75}.hljs-keyword,.hljs-winutils,.method,.hljs-addition,.css .hljs-tag,.hljs-request,.hljs-status,.nginx .hljs-title{color:#859900}.hljs-number,.hljs-command,.hljs-string,.hljs-tag .hljs-value,.hljs-rules .hljs-value,.hljs-phpdoc,.hljs-dartdoc,.tex .hljs-formula,.hljs-regexp,.hljs-hexcolor,.hljs-link_url{color:#2aa198}.hljs-title,.hljs-localvars,.hljs-chunk,.hljs-decorator,.hljs-built_in,.hljs-identifier,.vhdl .hljs-literal,.hljs-id,.css .hljs-function{color:#268bd2}.hljs-attribute,.hljs-variable,.lisp .hljs-body,.smalltalk .hljs-number,.hljs-constant,.hljs-class .hljs-title,.hljs-parent,.hljs-type,.hljs-link_reference{color:#b58900}.hljs-preprocessor,.hljs-preprocessor .hljs-keyword,.hljs-pragma,.hljs-shebang,.hljs-symbol,.hljs-symbol .hljs-string,.diff .hljs-change,.hljs-special,.hljs-attr_selector,.hljs-subst,.hljs-cdata,.css .hljs-pseudo,.hljs-header{color:#cb4b16}.hljs-deletion,.hljs-important{color:#dc322f}.hljs-link_label{color:#6c71c4}.tex .hljs-formula{background:#073642}*,*:before,*:after{box-sizing:border-box}html{-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section,summary{display:block}audio,canvas,progress,video{display:inline-block;vertical-align:baseline}audio:not([controls]){display:none;height:0}[hidden],template{display:none}a{background:0 0}a:active,a:hover{outline:0}abbr[title]{border-bottom:1px dotted}b,strong{font-weight:700}dfn{font-style:italic}h1{margin:.67em 0}mark{background:#ff0;color:#000}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sup{top:-.5em}sub{bottom:-.25em}images{border:0}svg:not(:root){overflow:hidden}figure{margin:1em 40px}hr{box-sizing:content-box;height:0}pre{overflow:auto}code,kbd{font-size:1em}code,kbd,pre,samp{font-family:monospace,monospace}samp{font-size:1em}button,input,optgroup,select,textarea{color:inherit;font:inherit;margin:0}button{overflow:visible}button,select{text-transform:none}button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}button[disabled],html input[disabled]{cursor:default}button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}input{line-height:normal}input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0;margin-right:5px}input[type="number"]::-webkit-inner-spin-button,input[type="number"]::-webkit-outer-spin-button{height:auto}input[type="search"]{-webkit-appearance:textfield;box-sizing:content-box}input[type="search"]::-webkit-search-cancel-button,input[type="search"]::-webkit-search-decoration{-webkit-appearance:none}fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}legend{border:0;padding:0}textarea{overflow:auto}optgroup{font-weight:700}table{border-collapse:collapse;border-spacing:0}.debug{background-color:#ffc0cb!important}.ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.ir{background-color:transparent;border:0;overflow:hidden}.ir::before{content:'';display:block;height:150%;width:0}html{font-size:.875em;background:#fff;color:#373D49}html,body{font-family:Georgia,Cambria,serif;height:100%}body{font-size:1rem;font-weight:400;line-height:2rem}ul,ol{margin-bottom:.83999rem;padding-top:.16001rem}li{font-feature-settings:'kern' 1,'onum' 1,'liga' 1;margin-left:1rem}li>ul,li>ol{margin-bottom:0}p{padding-top:.66001rem;font-feature-settings:'kern' 1,'onum' 1,'liga' 1;margin-top:0}p,pre{margin-bottom:1.33999rem}pre{font-size:1rem;padding:.66001rem 9.5px 9.5px;line-height:2rem;background:linear-gradient(to bottom,#fff 0,#fff .75rem,#f5f7fa .75rem,#f5f7fa 2.75rem,#fff 2.75rem,#fff 4rem);background-size:100% 4rem;border-color:#D3DAEA}blockquote{margin:0}blockquote p{font-size:1rem;margin-bottom:.33999rem;font-style:italic;padding:.66001rem 1rem 1rem;border-left:3px solid #A0AABF}th,td{padding:12px}h1,h2,h3,h4,h5,h6{font-family:"Source Sans Pro","Helvetica Neue",Helvetica,Arial,sans-serif;font-feature-settings:'dlig' 1,'liga' 1,'lnum' 1,'kern' 1;font-style:normal;font-weight:600;margin-top:0}h1{line-height:3rem;font-size:2.0571429rem;margin-bottom:.21999rem;padding-top:.78001rem}h2{font-size:1.953125rem;margin-bottom:.1835837rem;padding-top:.8164163rem}h2,h3{line-height:3rem}h3{font-size:1.6457143rem;margin-bottom:.07599rem;padding-top:.92401rem}h4{font-size:1.5625rem;margin-bottom:.546865rem;padding-top:.453135rem}h5{font-size:1.25rem;margin-bottom:-.56251rem;padding-top:.56251rem}h6{font-size:1rem;margin-bottom:-.65001rem;padding-top:.65001rem}a{cursor:pointer;color:#35D7BB;text-decoration:none}a:hover,a:focus{border-bottom-color:#35D7BB;color:#dff9f4}img{height:auto;max-width:100%}dt{font-style:italic;font-weight:600}.g{display:block}.g:after{clear:both;content:'';display:table}.g-b{float:left;margin:0;width:100%}.g{margin-left:-16px;margin-right:-16px}.g-b{padding-left:16px;padding-right:16px}.g-b--center{display:block;float:none;margin:0 auto}.g-b--right{float:right}.g-b--1of1{width:100%}.g-b--1of2,.g-b--2of4,.g-b--3of6,.g-b--4of8,.g-b--5of10,.g-b--6of12{width:50%}.g-b--1of3,.g-b--2of6,.g-b--4of12{width:33.333%}.g-b--2of3,.g-b--4of6,.g-b--8of12{width:66.666%}.g-b--1of4,.g-b--2of8,.g-b--3of12{width:25%}.g-b--3of4,.g-b--6of8,.g-b--9of12{width:75%}.g-b--1of5,.g-b--2of10{width:20%}.g-b--2of5,.g-b--4of10{width:40%}.g-b--3of5,.g-b--6of10{width:60%}.g-b--4of5,.g-b--8of10{width:80%}.g-b--1of6,.g-b--2of12{width:16.666%}.g-b--5of6,.g-b--10of12{width:83.333%}.g-b--1of8{width:12.5%}.g-b--3of8{width:37.5%}.g-b--5of8{width:62.5%}.g-b--7of8{width:87.5%}.g-b--1of10{width:10%}.g-b--3of10{width:30%}.g-b--7of10{width:70%}.g-b--9of10{width:90%}.g-b--1of12{width:8.333%}.g-b--5of12{width:41.666%}.g-b--7of12{width:58.333%}.g-b--11of12{width:91.666%}.g-b--push--1of1{margin-left:100%}.g-b--push--1of2,.g-b--push--2of4,.g-b--push--3of6,.g-b--push--4of8,.g-b--push--5of10,.g-b--push--6of12{margin-left:50%}.g-b--push--1of3,.g-b--push--2of6,.g-b--push--4of12{margin-left:33.333%}.g-b--push--2of3,.g-b--push--4of6,.g-b--push--8of12{margin-left:66.666%}.g-b--push--1of4,.g-b--push--2of8,.g-b--push--3of12{margin-left:25%}.g-b--push--3of4,.g-b--push--6of8,.g-b--push--9of12{margin-left:75%}.g-b--push--1of5,.g-b--push--2of10{margin-left:20%}.g-b--push--2of5,.g-b--push--4of10{margin-left:40%}.g-b--push--3of5,.g-b--push--6of10{margin-left:60%}.g-b--push--4of5,.g-b--push--8of10{margin-left:80%}.g-b--push--1of6,.g-b--push--2of12{margin-left:16.666%}.g-b--push--5of6,.g-b--push--10of12{margin-left:83.333%}.g-b--push--1of8{margin-left:12.5%}.g-b--push--3of8{margin-left:37.5%}.g-b--push--5of8{margin-left:62.5%}.g-b--push--7of8{margin-left:87.5%}.g-b--push--1of10{margin-left:10%}.g-b--push--3of10{margin-left:30%}.g-b--push--7of10{margin-left:70%}.g-b--push--9of10{margin-left:90%}.g-b--push--1of12{margin-left:8.333%}.g-b--push--5of12{margin-left:41.666%}.g-b--push--7of12{margin-left:58.333%}.g-b--push--11of12{margin-left:91.666%}.g-b--pull--1of1{margin-right:100%}.g-b--pull--1of2,.g-b--pull--2of4,.g-b--pull--3of6,.g-b--pull--4of8,.g-b--pull--5of10,.g-b--pull--6of12{margin-right:50%}.g-b--pull--1of3,.g-b--pull--2of6,.g-b--pull--4of12{margin-right:33.333%}.g-b--pull--2of3,.g-b--pull--4of6,.g-b--pull--8of12{margin-right:66.666%}.g-b--pull--1of4,.g-b--pull--2of8,.g-b--pull--3of12{margin-right:25%}.g-b--pull--3of4,.g-b--pull--6of8,.g-b--pull--9of12{margin-right:75%}.g-b--pull--1of5,.g-b--pull--2of10{margin-right:20%}.g-b--pull--2of5,.g-b--pull--4of10{margin-right:40%}.g-b--pull--3of5,.g-b--pull--6of10{margin-right:60%}.g-b--pull--4of5,.g-b--pull--8of10{margin-right:80%}.g-b--pull--1of6,.g-b--pull--2of12{margin-right:16.666%}.g-b--pull--5of6,.g-b--pull--10of12{margin-right:83.333%}.g-b--pull--1of8{margin-right:12.5%}.g-b--pull--3of8{margin-right:37.5%}.g-b--pull--5of8{margin-right:62.5%}.g-b--pull--7of8{margin-right:87.5%}.g-b--pull--1of10{margin-right:10%}.g-b--pull--3of10{margin-right:30%}.g-b--pull--7of10{margin-right:70%}.g-b--pull--9of10{margin-right:90%}.g-b--pull--1of12{margin-right:8.333%}.g-b--pull--5of12{margin-right:41.666%}.g-b--pull--7of12{margin-right:58.333%}.g-b--pull--11of12{margin-right:91.666%}.splashscreen{position:fixed;top:0;left:0;width:100%;height:100%;background-color:#373D49;z-index:22}.splashscreen-dillinger{width:260px;height:auto;display:block;margin:0 auto;padding-bottom:3rem}.splashscreen p{font-size:1.25rem;padding-top:.56251rem;font-family:"Source Sans Pro","Helvetica Neue",Helvetica,Arial,sans-serif;font-weight:400;text-align:center;max-width:500px;margin:0 auto;color:#FFF}.sp-center{position:relative;transform:translateY(-50%);top:50%}.open-menu>.wrapper{overflow-x:hidden}.page{margin:0 auto;position:relative;top:0;left:0;width:100%;height:100%;z-index:2;transition:all .25s ease-in-out;background-color:#fff;padding-top:51px;will-change:left}.open-menu .page{left:270px}.title{line-height:1rem;font-size:.8rem;margin-bottom:.77999rem;padding-top:.22001rem;font-weight:500;color:#A0AABF;letter-spacing:1px;text-transform:uppercase;padding-left:16px;padding-right:16px;margin-top:1rem}.split-preview .title{padding-left:0}.title-document{line-height:1rem;font-size:1.25rem;margin-bottom:.89999rem;padding-top:.10001rem;font-weight:400;font-family:"Ubuntu Mono",Monaco;color:#373D49;padding-left:16px;padding-right:16px;width:80%;min-width:300px;outline:0;border:none}.icon{display:block;margin:0 auto;width:36px;height:36px;border-radius:3px;text-align:center}.icon svg{display:inline-block;margin-left:auto;margin-right:auto}.icon-preview{background-color:#373D49;line-height:40px}.icon-preview svg{width:19px;height:12px}.icon-settings{background-color:#373D49;line-height:44px}.icon-settings svg{width:18px;height:18px}.icon-link{width:16px;height:16px;line-height:1;margin-right:24px;text-align:right}.navbar{background-color:#373D49;height:51px;width:100%;position:fixed;top:0;left:0;z-index:6;transition:all .25s ease-in-out;will-change:left}.navbar:after{content:"";display:table;clear:both}.open-menu .navbar{left:270px}.navbar-brand{float:left;margin:0 0 0 24px;padding:0;line-height:42px}.navbar-brand svg{width:85px;height:11px}.nav-left{float:left}.nav-right{float:right}.nav-sidebar{width:100%}.menu{list-style:none;margin:0;padding:0}.menu a{border:0;color:#A0AABF;font-family:"Source Sans Pro","Helvetica Neue",Helvetica,Arial,sans-serif;outline:none;text-transform:uppercase}.menu a:hover{color:#35D7BB}.menu .menu-item{border:0;display:none;float:left;margin:0;position:relative}.menu .menu-item>a{display:block;font-size:12px;height:51px;letter-spacing:1px;line-height:51px;padding:0 24px}.menu .menu-item--settings,.menu .menu-item--preview,.menu .menu-item--save-to.in-sidebar,.menu .menu-item--import-from.in-sidebar,.menu .menu-item--link-unlink.in-sidebar,.menu .menu-item--documents.in-sidebar{display:block}.menu .menu-item--documents{padding-bottom:1rem}.menu .menu-item.open>a{background-color:#1D212A}.menu .menu-item-icon>a{height:auto;padding:0}.menu .menu-item-icon:hover>a{background-color:transparent}.menu .menu-link.open i{background-color:#1D212A}.menu .menu-link.open g{fill:#35D7BB}.menu .menu-link-preview,.menu .menu-link-settings{margin-top:8px;width:51px}.menu-sidebar{width:100%}.menu-sidebar .menu-item{float:none;margin-bottom:1px;width:100%}.menu-sidebar .menu-item.open>a{background-color:#373D49}.menu-sidebar .open .caret{transform:rotate(180deg)}.menu-sidebar>.menu-item:hover .dropdown a,.menu-sidebar>.menu-item:hover .settings a{background-color:transparent}.menu-sidebar .menu-link{background-color:#373D49;font-weight:600}.menu-sidebar .menu-link:after{content:"";display:table;clear:both}.menu-sidebar .menu-link>span{float:left}.menu-sidebar .menu-link>.caret{float:right;text-align:right;top:22px}.menu-sidebar .dropdown,.menu-sidebar .settings{background-color:transparent;position:static;width:100%}.dropdown{position:absolute;right:0;top:51px;width:188px}.dropdown,.settings{display:none;background-color:#1D212A}.dropdown{padding:0}.dropdown,.settings,.sidebar-list{list-style:none;margin:0}.sidebar-list{padding:0}.dropdown li{margin:32px 0;padding:0 0 0 32px}.dropdown li,.settings li{line-height:1}.sidebar-list li{line-height:1;margin:32px 0;padding:0 0 0 32px}.dropdown a{color:#D0D6E2}.dropdown a,.settings a,.sidebar-list a{display:block;text-transform:none}.sidebar-list a{color:#D0D6E2}.dropdown a:after,.settings a:after,.sidebar-list a:after{content:"";display:table;clear:both}.dropdown .icon,.settings .icon,.sidebar-list .icon{float:right}.open .dropdown,.open .settings,.open .sidebar-list{display:block}.open .dropdown.collapse,.open .collapse.settings,.open .sidebar-list.collapse{display:none}.open .dropdown.collapse.in,.open .collapse.in.settings,.open .sidebar-list.collapse.in{display:block}.dropdown .unlinked .icon,.settings .unlinked .icon,.sidebar-list .unlinked .icon{opacity:.3}.dropdown.documents li,.documents.settings li,.sidebar-list.documents li{background-image:url("../img/icons/file.svg");background-position:240px center;background-repeat:no-repeat;background-size:14px 16px;padding:3px 32px}.dropdown.documents li.octocat,.documents.settings li.octocat,.sidebar-list.documents li.octocat{background-image:url("../img/icons/octocat.svg");background-position:234px center;background-size:24px 24px}.dropdown.documents li:last-child,.documents.settings li:last-child,.sidebar-list.documents li:last-child{margin-bottom:1rem}.dropdown.documents li.active a,.documents.settings li.active a,.sidebar-list.documents li.active a{color:#35D7BB}.settings{position:fixed;top:67px;right:16px;border-radius:3px;width:288px;background-color:#373D49;padding:16px;z-index:7}.show-settings .settings{display:block}.settings .has-checkbox{float:left}.settings form{display:-ms-flexbox;display:flex;-ms-flex-direction:row;flex-direction:row;-ms-flex-pack:justify;justify-content:space-between}.settings input{width:20%}.settings a{font-size:1.25rem;font-family:"Source Sans Pro","Helvetica Neue",Helvetica,Arial,sans-serif;font-weight:400;-webkit-font-smoothing:antialiased;line-height:28px;color:#D0D6E2}.settings a:after{content:"";display:table;clear:both}.settings a:hover{color:#35D7BB}.settings li{border-bottom:1px solid #4F535B;margin:0;padding:16px 0}.settings li:last-child{border-bottom:none}.brand{border:none;display:block}.brand:hover g{fill:#35D7BB}.toggle{display:block;float:left;height:16px;padding:25px 16px 26px;width:40px}.toggle span:after,.toggle span:before{content:'';left:0;position:absolute;top:-6px}.toggle span:after{top:6px}.toggle span{display:block;position:relative}.toggle span,.toggle span:after,.toggle span:before{-webkit-backface-visibility:hidden;backface-visibility:hidden;background-color:#D3DAEA;height:2px;transition:all .3s;width:20px}.open-menu .toggle span{background-color:transparent}.open-menu .toggle span:before{transform:rotate(45deg) translate(3px,3px)}.open-menu .toggle span:after{transform:rotate(-45deg) translate(5px,-6px)}.caret{display:inline-block;width:0;height:0;margin-left:6px;vertical-align:middle;position:relative;top:-1px;border-top:4px solid;border-right:4px solid transparent;border-left:4px solid transparent}.sidebar{overflow:auto;height:100%;padding-right:15px;padding-bottom:15px;width:285px}.sidebar-wrapper{-webkit-overflow-scrolling:touch;background-color:#2B2F36;left:0;height:100%;overflow-y:hidden;position:fixed;top:0;width:285px;z-index:1}.sidebar-branding{width:160px;padding:0;margin:16px auto}.header{border-bottom:1px solid #E8E8E8;position:relative}.words,.characters{line-height:1rem;font-size:.8rem;margin-bottom:.77999rem;padding-top:.22001rem;font-weight:500;font-family:"Source Sans Pro","Helvetica Neue",Helvetica,Arial,sans-serif;letter-spacing:1px;text-transform:uppercase;z-index:5;position:absolute;right:16px;top:0}.words span,.characters span{color:#A0AABF}.words .counter,.characters .counter{color:#000}.words+.characters{top:22px}.mr10{margin-right:10px}.btn{text-align:center;display:inline-block;width:100%;text-transform:uppercase;font-weight:600;font-family:"Source Sans Pro","Helvetica Neue",Helvetica,Arial,sans-serif;font-size:14px;text-shadow:0 1px 0 #1b8b77;padding:16px 24px;background-color:#35D7BB;border-radius:3px;margin:0 auto 16px;line-height:1;color:#fff;transition:all .15s linear;-webkit-font-smoothing:antialiased}.btn--new,.btn--save{display:block;width:238px}.btn--new:hover,.btn--new:focus,.btn--save:hover,.btn--save:focus{color:#fff;border-bottom-color:transparent;box-shadow:0 1px 3px #24b59c;text-shadow:0 1px 0 #24b59c}.btn--save{background-color:#4A5261;text-shadow:0 1px 1px #1e2127}.btn--save:hover,.btn--save:focus{color:#fff;border-bottom-color:transparent;box-shadow:0 1px 5px #08090a;text-shadow:none}.btn--delete{display:block;width:238px;background-color:transparent;font-size:12px;text-shadow:none}.btn--delete:hover,.btn--delete:focus{color:#fff;border-bottom-color:transparent;text-shadow:0 1px 0 #08090a;opacity:.8}.btn--delete-modal,.btn--ok,.btn--close{border-top:0;background-color:#4A5261;text-shadow:0 1px 0 #08090a;margin:0}.btn--delete-modal:hover,.btn--delete-modal:focus,.btn--ok:hover,.btn--ok:focus,.btn--close:hover,.btn--close:focus{color:#fff;background-color:#292d36;text-shadow:none}.btn--delete-modal{display:inline;width:auto}.overlay{position:absolute;top:0;left:0;width:100%;height:100%;background-color:rgba(55,61,73,.8);transition:all .25s ease-in-out;transition-timing-function:ease-out;will-change:left,opacity,visibility;z-index:5;opacity:0;visibility:hidden}.show-settings .overlay{visibility:visible;opacity:1}.switch{float:right;line-height:1}.switch input{display:none}.switch small{display:inline-block;cursor:pointer;padding:0 24px 0 0;transition:all ease .2s;background-color:#2B2F36;border-color:#2B2F36}.switch small,.switch small:before{border-radius:30px;box-shadow:inset 0 0 2px 0 #14171F}.switch small:before{display:block;content:'';width:28px;height:28px;background:#fff}.switch.checked small{padding-right:0;padding-left:24px;background-color:#35D7BB;box-shadow:none}.modal--dillinger.about .modal-dialog{font-size:1.25rem;max-width:500px}.modal--dillinger.scope .modal-dialog{max-width:300px;margin:5rem auto}.modal--dillinger .modal-dialog{max-width:600px;width:auto;margin:5rem auto}.modal--dillinger .modal-content{background:#373D49;border-radius:3px;box-shadow:0 2px 5px 0 #2C3B59;color:#fff;font-family:"Source Sans Pro","Helvetica Neue",Helvetica,Arial,sans-serif;font-weight:400;padding:2rem}.modal--dillinger ul{list-style-type:disc;margin:1rem 0;padding:0 0 0 1rem}.modal--dillinger li{padding:0;margin:0}.modal--dillinger .modal-header{border:0;padding:0}.modal--dillinger .modal-body{padding:0}.modal--dillinger .modal-footer{border:0;padding:0}.modal--dillinger .close{color:#fff;opacity:1}.modal-backdrop{background-color:#373D49}.pagination--dillinger{padding:0!important;margin:1.5rem 0!important;display:-ms-flexbox;display:flex;-ms-flex-pack:justify;justify-content:space-between;-ms-flex-direction:row;flex-direction:row;-ms-flex-align:center;align-items:center;-ms-flex-line-pack:stretch;align-content:stretch}.pagination--dillinger li{display:-ms-flexbox;display:flex;-ms-flex-positive:1;flex-grow:1;text-align:center}.pagination--dillinger li:first-child>a,.pagination--dillinger li.disabled>a,.pagination--dillinger li.disabled>a:hover,.pagination--dillinger li.disabled>a:focus,.pagination--dillinger li>a{background-color:transparent;border-color:#4F535B;border-right-color:transparent}.pagination--dillinger li.active>a,.pagination--dillinger li.active>a:hover,.pagination--dillinger li.active>a:focus{border-color:#4A5261;background-color:#4A5261;color:#fff}.pagination--dillinger li>a{float:none;color:#fff;width:100%;display:block;text-align:center;margin:0;border-right-color:transparent;padding:6px}.pagination--dillinger li>a:hover,.pagination--dillinger li>a:focus{border-color:#35D7BB;background-color:#35D7BB;color:#fff}.pagination--dillinger li:last-child a{border-color:#4F535B}.pagination--dillinger li:first-child a{border-right-color:transparent}.diNotify{position:absolute;z-index:9999;left:0;right:0;top:0;margin:0 auto;max-width:400px;text-align:center;transition:top .5s ease-in-out,opacity .5s ease-in-out;visibility:hidden}.diNotify-body{-webkit-font-smoothing:antialiased;background-color:#35D7BB;background:#666E7F;border-radius:3px;color:#fff;font-family:"Source Sans Pro","Helvetica Neue",Helvetica,Arial,sans-serif;font-weight:400;overflow:hidden;padding:1rem 2rem .5rem;display:-ms-flexbox;display:flex;-ms-flex-align:baseline;align-items:baseline;-ms-flex-pack:center;justify-content:center}.diNotify-icon{display:block;width:16px;height:16px;line-height:16px;position:relative;top:3px}.diNotify-message{padding-left:1rem}.zen-wrapper{position:fixed;top:0;left:0;right:0;bottom:0;width:100%;height:100%;z-index:10;background-color:#FFF;opacity:0;transition:opacity .25s ease-in-out}.zen-wrapper.on{opacity:1}.enter-zen-mode{background-image:url("../img/icons/enter-zen.svg");right:.5rem;top:.313rem;display:none}.enter-zen-mode,.close-zen-mode{font:0/0 a;color:transparent;text-shadow:none;background-color:transparent;border:0;background-repeat:no-repeat;width:32px;height:32px;display:block;position:absolute}.close-zen-mode{background-image:url("../img/icons/exit-zen.svg");right:1rem;top:1rem}.zen-page{position:relative;top:0;bottom:0;z-index:11;height:100%;width:100%}#zen{font-size:1.25rem;width:300px;height:80%;margin:0 auto;position:relative;top:10%}#zen:before,#zen:after{content:"";position:absolute;height:10%;width:100%;z-index:12;pointer-events:none}#preview .table{width:auto}.ui-resizable{position:relative}.ui-resizable-handle{position:absolute;font-size:.1px;z-index:99999;display:block}.ui-resizable-e{background-color:#666;border-right:8px solid #e8e8e8;border-left:1px solid #222;width:10px;z-index:88!important;position:relative}.ui-resizable-e:after{content:"-";display:block;position:absolute;top:calc(50% - 16px);left:0;height:25px;width:2px;background-color:rgba(0,0,0,.4);margin:3px}#editor{cursor:ew-resize;position:relative;z-index:auto}.profile-pic{float:left;width:250px}#_default_ a::before{color:#A0AABF}#_default_ img{display:none}#_default_ #_default_{display:block;float:left;max-width:38%;word-wrap:break-word}#_default_ .default-ad{display:none}#_default_ ._default_{display:block}#_default_ a{color:#35d7bb;text-decoration:none}#_default_ a:hover{color:#8ae8d8}#_default_ .default-image{display:none}#_default_ .default-title:after{content:" — "}#_default_ .default-title,#_default_ .default-text,#_default_ .default-description{display:inline}#_default_ .default-title{position:relative;font-weight:600;display:none}#_default_ a:before{position:relative;top:0;padding:5px;color:#a0aabf;content:"Ad";text-transform:uppercase;font-size:8px;font-family:Verdana,sans-serif}#_default_{display:block;float:left;max-width:38%;word-wrap:break-word}#_default_ ._default_{display:block;font-size:.75rem;height:51px;letter-spacing:1px;line-height:1rem;padding:18px 24px}body{max-width:1024px;margin:0 auto;overflow:auto;padding:2%}.split{overflow:scroll;padding:0!important;-webkit-overflow-scrolling:touch}.split-editor{padding-left:0;padding-right:0;position:relative;z-index:3}.show-preview .split-editor{display:none}.split-preview{background-color:#fff;display:none;top:0;position:relative;z-index:4}.show-preview .split-preview{display:block}#editor{font-size:1rem;font-family:"Ubuntu Mono",Monaco;font-weight:400;line-height:2rem;width:100%;height:100%}#editor .ace_gutter{-webkit-font-smoothing:antialiased}.editor-header{width:50%;float:left;border-bottom:1px solid #E8E8E8;position:relative}.editor-header--first{border-right:1px solid #E8E8E8}.editor-header .title{display:inline-block}.preview-html{padding:15px}.preview-html a{color:#A0AABF;text-decoration:underline}.preview-src{white-space:normal}.preview-mode-toggle-src{background-image:url("../img/icons/code.svg")}.preview-mode-toggle-src,.preview-mode-toggle-html{font:0/0 a;color:transparent;text-shadow:none;background-color:transparent;border:0;background-repeat:no-repeat;width:32px;height:32px;display:block;position:absolute;right:.5rem;top:.5rem;display:none}.preview-mode-toggle-html{background-image:url("../img/icons/eye.svg")}.sr-only{visibility:hidden;text-overflow:110%;overflow:hidden;top:-100px;position:absolute}.mnone{margin:0!important}@media screen and (min-width:27.5em){html{font-size:.875em}body{font-size:1rem}ul,ol{margin-bottom:.83999rem;padding-top:.16001rem}p{padding-top:.66001rem}p,pre{margin-bottom:1.33999rem}pre,blockquote p{font-size:1rem;padding-top:.66001rem}blockquote p{margin-bottom:.33999rem}h1{font-size:2.0571429rem;margin-bottom:.21999rem;padding-top:.78001rem}h2{font-size:1.953125rem;margin-bottom:.1835837rem;padding-top:.8164163rem}h3{font-size:1.6457143rem;margin-bottom:.07599rem;padding-top:.92401rem}h4{font-size:1.5625rem;margin-bottom:.546865rem;padding-top:.453135rem}h5{font-size:1.25rem;margin-bottom:-.56251rem;padding-top:.56251rem}h6{font-size:1rem;margin-bottom:-.65001rem;padding-top:.65001rem}.g{margin-left:-16px;margin-right:-16px}.g-b{padding-left:16px;padding-right:16px}.g-b--m1of1{width:100%}.g-b--m1of2,.g-b--m2of4,.g-b--m3of6,.g-b--m4of8,.g-b--m5of10,.g-b--m6of12{width:50%}.g-b--m1of3,.g-b--m2of6,.g-b--m4of12{width:33.333%}.g-b--m2of3,.g-b--m4of6,.g-b--m8of12{width:66.666%}.g-b--m1of4,.g-b--m2of8,.g-b--m3of12{width:25%}.g-b--m3of4,.g-b--m6of8,.g-b--m9of12{width:75%}.g-b--m1of5,.g-b--m2of10{width:20%}.g-b--m2of5,.g-b--m4of10{width:40%}.g-b--m3of5,.g-b--m6of10{width:60%}.g-b--m4of5,.g-b--m8of10{width:80%}.g-b--m1of6,.g-b--m2of12{width:16.666%}.g-b--m5of6,.g-b--m10of12{width:83.333%}.g-b--m1of8{width:12.5%}.g-b--m3of8{width:37.5%}.g-b--m5of8{width:62.5%}.g-b--m7of8{width:87.5%}.g-b--m1of10{width:10%}.g-b--m3of10{width:30%}.g-b--m7of10{width:70%}.g-b--m9of10{width:90%}.g-b--m1of12{width:8.333%}.g-b--m5of12{width:41.666%}.g-b--m7of12{width:58.333%}.g-b--m11of12{width:91.666%}.g-b--push--m1of1{margin-left:100%}.g-b--push--m1of2,.g-b--push--m2of4,.g-b--push--m3of6,.g-b--push--m4of8,.g-b--push--m5of10,.g-b--push--m6of12{margin-left:50%}.g-b--push--m1of3,.g-b--push--m2of6,.g-b--push--m4of12{margin-left:33.333%}.g-b--push--m2of3,.g-b--push--m4of6,.g-b--push--m8of12{margin-left:66.666%}.g-b--push--m1of4,.g-b--push--m2of8,.g-b--push--m3of12{margin-left:25%}.g-b--push--m3of4,.g-b--push--m6of8,.g-b--push--m9of12{margin-left:75%}.g-b--push--m1of5,.g-b--push--m2of10{margin-left:20%}.g-b--push--m2of5,.g-b--push--m4of10{margin-left:40%}.g-b--push--m3of5,.g-b--push--m6of10{margin-left:60%}.g-b--push--m4of5,.g-b--push--m8of10{margin-left:80%}.g-b--push--m1of6,.g-b--push--m2of12{margin-left:16.666%}.g-b--push--m5of6,.g-b--push--m10of12{margin-left:83.333%}.g-b--push--m1of8{margin-left:12.5%}.g-b--push--m3of8{margin-left:37.5%}.g-b--push--m5of8{margin-left:62.5%}.g-b--push--m7of8{margin-left:87.5%}.g-b--push--m1of10{margin-left:10%}.g-b--push--m3of10{margin-left:30%}.g-b--push--m7of10{margin-left:70%}.g-b--push--m9of10{margin-left:90%}.g-b--push--m1of12{margin-left:8.333%}.g-b--push--m5of12{margin-left:41.666%}.g-b--push--m7of12{margin-left:58.333%}.g-b--push--m11of12{margin-left:91.666%}.g-b--pull--m1of1{margin-right:100%}.g-b--pull--m1of2,.g-b--pull--m2of4,.g-b--pull--m3of6,.g-b--pull--m4of8,.g-b--pull--m5of10,.g-b--pull--m6of12{margin-right:50%}.g-b--pull--m1of3,.g-b--pull--m2of6,.g-b--pull--m4of12{margin-right:33.333%}.g-b--pull--m2of3,.g-b--pull--m4of6,.g-b--pull--m8of12{margin-right:66.666%}.g-b--pull--m1of4,.g-b--pull--m2of8,.g-b--pull--m3of12{margin-right:25%}.g-b--pull--m3of4,.g-b--pull--m6of8,.g-b--pull--m9of12{margin-right:75%}.g-b--pull--m1of5,.g-b--pull--m2of10{margin-right:20%}.g-b--pull--m2of5,.g-b--pull--m4of10{margin-right:40%}.g-b--pull--m3of5,.g-b--pull--m6of10{margin-right:60%}.g-b--pull--m4of5,.g-b--pull--m8of10{margin-right:80%}.g-b--pull--m1of6,.g-b--pull--m2of12{margin-right:16.666%}.g-b--pull--m5of6,.g-b--pull--m10of12{margin-right:83.333%}.g-b--pull--m1of8{margin-right:12.5%}.g-b--pull--m3of8{margin-right:37.5%}.g-b--pull--m5of8{margin-right:62.5%}.g-b--pull--m7of8{margin-right:87.5%}.g-b--pull--m1of10{margin-right:10%}.g-b--pull--m3of10{margin-right:30%}.g-b--pull--m7of10{margin-right:70%}.g-b--pull--m9of10{margin-right:90%}.g-b--pull--m1of12{margin-right:8.333%}.g-b--pull--m5of12{margin-right:41.666%}.g-b--pull--m7of12{margin-right:58.333%}.g-b--pull--m11of12{margin-right:91.666%}.splashscreen p{font-size:1.25rem;margin-bottom:1.43749rem;padding-top:.56251rem}.title{font-size:.8rem;margin-bottom:.77999rem;padding-top:.22001rem}.title-document{margin-bottom:.89999rem;padding-top:.10001rem}.title-document,.settings a{font-size:1.25rem}.words,.characters{font-size:.8rem;margin-bottom:.77999rem;padding-top:.22001rem}.modal--dillinger.about .modal-dialog,#zen{font-size:1.25rem}#zen{width:400px}#editor{font-size:1rem}}@media screen and (min-width:46.25em){html{font-size:.875em}body{font-size:1rem}ul,ol{margin-bottom:.83999rem;padding-top:.16001rem}p{padding-top:.66001rem}p,pre{margin-bottom:1.33999rem}pre,blockquote p{font-size:1rem;padding-top:.66001rem}blockquote p{margin-bottom:.33999rem}h1{font-size:2.0571429rem;margin-bottom:.21999rem;padding-top:.78001rem}h2{font-size:1.953125rem;margin-bottom:.1835837rem;padding-top:.8164163rem}h3{font-size:1.6457143rem;margin-bottom:.07599rem;padding-top:.92401rem}h4{font-size:1.5625rem;margin-bottom:.546865rem;padding-top:.453135rem}h5{font-size:1.25rem;margin-bottom:-.56251rem;padding-top:.56251rem}h6{font-size:1rem;margin-bottom:-.65001rem;padding-top:.65001rem}.g{margin-left:-16px;margin-right:-16px}.g-b{padding-left:16px;padding-right:16px}.g-b--t1of1{width:100%}.g-b--t1of2,.g-b--t2of4,.g-b--t3of6,.g-b--t4of8,.g-b--t5of10,.g-b--t6of12{width:50%}.g-b--t1of3,.g-b--t2of6,.g-b--t4of12{width:33.333%}.g-b--t2of3,.g-b--t4of6,.g-b--t8of12{width:66.666%}.g-b--t1of4,.g-b--t2of8,.g-b--t3of12{width:25%}.g-b--t3of4,.g-b--t6of8,.g-b--t9of12{width:75%}.g-b--t1of5,.g-b--t2of10{width:20%}.g-b--t2of5,.g-b--t4of10{width:40%}.g-b--t3of5,.g-b--t6of10{width:60%}.g-b--t4of5,.g-b--t8of10{width:80%}.g-b--t1of6,.g-b--t2of12{width:16.666%}.g-b--t5of6,.g-b--t10of12{width:83.333%}.g-b--t1of8{width:12.5%}.g-b--t3of8{width:37.5%}.g-b--t5of8{width:62.5%}.g-b--t7of8{width:87.5%}.g-b--t1of10{width:10%}.g-b--t3of10{width:30%}.g-b--t7of10{width:70%}.g-b--t9of10{width:90%}.g-b--t1of12{width:8.333%}.g-b--t5of12{width:41.666%}.g-b--t7of12{width:58.333%}.g-b--t11of12{width:91.666%}.g-b--push--t1of1{margin-left:100%}.g-b--push--t1of2,.g-b--push--t2of4,.g-b--push--t3of6,.g-b--push--t4of8,.g-b--push--t5of10,.g-b--push--t6of12{margin-left:50%}.g-b--push--t1of3,.g-b--push--t2of6,.g-b--push--t4of12{margin-left:33.333%}.g-b--push--t2of3,.g-b--push--t4of6,.g-b--push--t8of12{margin-left:66.666%}.g-b--push--t1of4,.g-b--push--t2of8,.g-b--push--t3of12{margin-left:25%}.g-b--push--t3of4,.g-b--push--t6of8,.g-b--push--t9of12{margin-left:75%}.g-b--push--t1of5,.g-b--push--t2of10{margin-left:20%}.g-b--push--t2of5,.g-b--push--t4of10{margin-left:40%}.g-b--push--t3of5,.g-b--push--t6of10{margin-left:60%}.g-b--push--t4of5,.g-b--push--t8of10{margin-left:80%}.g-b--push--t1of6,.g-b--push--t2of12{margin-left:16.666%}.g-b--push--t5of6,.g-b--push--t10of12{margin-left:83.333%}.g-b--push--t1of8{margin-left:12.5%}.g-b--push--t3of8{margin-left:37.5%}.g-b--push--t5of8{margin-left:62.5%}.g-b--push--t7of8{margin-left:87.5%}.g-b--push--t1of10{margin-left:10%}.g-b--push--t3of10{margin-left:30%}.g-b--push--t7of10{margin-left:70%}.g-b--push--t9of10{margin-left:90%}.g-b--push--t1of12{margin-left:8.333%}.g-b--push--t5of12{margin-left:41.666%}.g-b--push--t7of12{margin-left:58.333%}.g-b--push--t11of12{margin-left:91.666%}.g-b--pull--t1of1{margin-right:100%}.g-b--pull--t1of2,.g-b--pull--t2of4,.g-b--pull--t3of6,.g-b--pull--t4of8,.g-b--pull--t5of10,.g-b--pull--t6of12{margin-right:50%}.g-b--pull--t1of3,.g-b--pull--t2of6,.g-b--pull--t4of12{margin-right:33.333%}.g-b--pull--t2of3,.g-b--pull--t4of6,.g-b--pull--t8of12{margin-right:66.666%}.g-b--pull--t1of4,.g-b--pull--t2of8,.g-b--pull--t3of12{margin-right:25%}.g-b--pull--t3of4,.g-b--pull--t6of8,.g-b--pull--t9of12{margin-right:75%}.g-b--pull--t1of5,.g-b--pull--t2of10{margin-right:20%}.g-b--pull--t2of5,.g-b--pull--t4of10{margin-right:40%}.g-b--pull--t3of5,.g-b--pull--t6of10{margin-right:60%}.g-b--pull--t4of5,.g-b--pull--t8of10{margin-right:80%}.g-b--pull--t1of6,.g-b--pull--t2of12{margin-right:16.666%}.g-b--pull--t5of6,.g-b--pull--t10of12{margin-right:83.333%}.g-b--pull--t1of8{margin-right:12.5%}.g-b--pull--t3of8{margin-right:37.5%}.g-b--pull--t5of8{margin-right:62.5%}.g-b--pull--t7of8{margin-right:87.5%}.g-b--pull--t1of10{margin-right:10%}.g-b--pull--t3of10{margin-right:30%}.g-b--pull--t7of10{margin-right:70%}.g-b--pull--t9of10{margin-right:90%}.g-b--pull--t1of12{margin-right:8.333%}.g-b--pull--t5of12{margin-right:41.666%}.g-b--pull--t7of12{margin-right:58.333%}.g-b--pull--t11of12{margin-right:91.666%}.splashscreen-dillinger{width:500px}.splashscreen p{font-size:1.25rem;margin-bottom:1.43749rem;padding-top:.56251rem}.title{font-size:.8rem;margin-bottom:.77999rem;padding-top:.22001rem}.title-document{font-size:1.25rem;margin-bottom:.89999rem;padding-top:.10001rem}.menu .menu-item--save-to,.menu .menu-item--import-from{display:block}.menu .menu-item--preview,.menu .menu-item--save-to.in-sidebar,.menu .menu-item--import-from.in-sidebar{display:none}.settings a{font-size:1.25rem}.words,.characters{font-size:.8rem;margin-bottom:.77999rem;padding-top:.22001rem}.modal--dillinger.about .modal-dialog{font-size:1.25rem}.enter-zen-mode{display:block}.close-zen-mode{right:3rem;top:3rem}#zen{font-size:1.25rem;width:500px}.split-editor{border-right:1px solid #E8E8E8;float:left;padding-right:16px;width:50%}.show-preview .split-editor{display:block}.split-preview{display:block;float:right;position:relative;top:0;width:50%}#editor{font-size:1rem}.preview-mode-toggle-src,.preview-mode-toggle-html{display:block}}@media screen and (min-width:62.5em){html{font-size:.875em}body{font-size:1rem}ul,ol{margin-bottom:.83999rem;padding-top:.16001rem}p{padding-top:.66001rem}p,pre{margin-bottom:1.33999rem}pre,blockquote p{font-size:1rem;padding-top:.66001rem}blockquote p{margin-bottom:.33999rem}h1{font-size:2.0571429rem;margin-bottom:.21999rem;padding-top:.78001rem}h2{font-size:1.953125rem;margin-bottom:.1835837rem;padding-top:.8164163rem}h3{font-size:1.6457143rem;margin-bottom:.07599rem;padding-top:.92401rem}h4{font-size:1.5625rem;margin-bottom:.546865rem;padding-top:.453135rem}h5{font-size:1.25rem;margin-bottom:-.56251rem;padding-top:.56251rem}h6{font-size:1rem;margin-bottom:-.65001rem;padding-top:.65001rem}.g{margin-left:-16px;margin-right:-16px}.g-b{padding-left:16px;padding-right:16px}.g-b--d1of1{width:100%}.g-b--d1of2,.g-b--d2of4,.g-b--d3of6,.g-b--d4of8,.g-b--d5of10,.g-b--d6of12{width:50%}.g-b--d1of3,.g-b--d2of6,.g-b--d4of12{width:33.333%}.g-b--d2of3,.g-b--d4of6,.g-b--d8of12{width:66.666%}.g-b--d1of4,.g-b--d2of8,.g-b--d3of12{width:25%}.g-b--d3of4,.g-b--d6of8,.g-b--d9of12{width:75%}.g-b--d1of5,.g-b--d2of10{width:20%}.g-b--d2of5,.g-b--d4of10{width:40%}.g-b--d3of5,.g-b--d6of10{width:60%}.g-b--d4of5,.g-b--d8of10{width:80%}.g-b--d1of6,.g-b--d2of12{width:16.666%}.g-b--d5of6,.g-b--d10of12{width:83.333%}.g-b--d1of8{width:12.5%}.g-b--d3of8{width:37.5%}.g-b--d5of8{width:62.5%}.g-b--d7of8{width:87.5%}.g-b--d1of10{width:10%}.g-b--d3of10{width:30%}.g-b--d7of10{width:70%}.g-b--d9of10{width:90%}.g-b--d1of12{width:8.333%}.g-b--d5of12{width:41.666%}.g-b--d7of12{width:58.333%}.g-b--d11of12{width:91.666%}.g-b--push--d1of1{margin-left:100%}.g-b--push--d1of2,.g-b--push--d2of4,.g-b--push--d3of6,.g-b--push--d4of8,.g-b--push--d5of10,.g-b--push--d6of12{margin-left:50%}.g-b--push--d1of3,.g-b--push--d2of6,.g-b--push--d4of12{margin-left:33.333%}.g-b--push--d2of3,.g-b--push--d4of6,.g-b--push--d8of12{margin-left:66.666%}.g-b--push--d1of4,.g-b--push--d2of8,.g-b--push--d3of12{margin-left:25%}.g-b--push--d3of4,.g-b--push--d6of8,.g-b--push--d9of12{margin-left:75%}.g-b--push--d1of5,.g-b--push--d2of10{margin-left:20%}.g-b--push--d2of5,.g-b--push--d4of10{margin-left:40%}.g-b--push--d3of5,.g-b--push--d6of10{margin-left:60%}.g-b--push--d4of5,.g-b--push--d8of10{margin-left:80%}.g-b--push--d1of6,.g-b--push--d2of12{margin-left:16.666%}.g-b--push--d5of6,.g-b--push--d10of12{margin-left:83.333%}.g-b--push--d1of8{margin-left:12.5%}.g-b--push--d3of8{margin-left:37.5%}.g-b--push--d5of8{margin-left:62.5%}.g-b--push--d7of8{margin-left:87.5%}.g-b--push--d1of10{margin-left:10%}.g-b--push--d3of10{margin-left:30%}.g-b--push--d7of10{margin-left:70%}.g-b--push--d9of10{margin-left:90%}.g-b--push--d1of12{margin-left:8.333%}.g-b--push--d5of12{margin-left:41.666%}.g-b--push--d7of12{margin-left:58.333%}.g-b--push--d11of12{margin-left:91.666%}.g-b--pull--d1of1{margin-right:100%}.g-b--pull--d1of2,.g-b--pull--d2of4,.g-b--pull--d3of6,.g-b--pull--d4of8,.g-b--pull--d5of10,.g-b--pull--d6of12{margin-right:50%}.g-b--pull--d1of3,.g-b--pull--d2of6,.g-b--pull--d4of12{margin-right:33.333%}.g-b--pull--d2of3,.g-b--pull--d4of6,.g-b--pull--d8of12{margin-right:66.666%}.g-b--pull--d1of4,.g-b--pull--d2of8,.g-b--pull--d3of12{margin-right:25%}.g-b--pull--d3of4,.g-b--pull--d6of8,.g-b--pull--d9of12{margin-right:75%}.g-b--pull--d1of5,.g-b--pull--d2of10{margin-right:20%}.g-b--pull--d2of5,.g-b--pull--d4of10{margin-right:40%}.g-b--pull--d3of5,.g-b--pull--d6of10{margin-right:60%}.g-b--pull--d4of5,.g-b--pull--d8of10{margin-right:80%}.g-b--pull--d1of6,.g-b--pull--d2of12{margin-right:16.666%}.g-b--pull--d5of6,.g-b--pull--d10of12{margin-right:83.333%}.g-b--pull--d1of8{margin-right:12.5%}.g-b--pull--d3of8{margin-right:37.5%}.g-b--pull--d5of8{margin-right:62.5%}.g-b--pull--d7of8{margin-right:87.5%}.g-b--pull--d1of10{margin-right:10%}.g-b--pull--d3of10{margin-right:30%}.g-b--pull--d7of10{margin-right:70%}.g-b--pull--d9of10{margin-right:90%}.g-b--pull--d1of12{margin-right:8.333%}.g-b--pull--d5of12{margin-right:41.666%}.g-b--pull--d7of12{margin-right:58.333%}.g-b--pull--d11of12{margin-right:91.666%}.splashscreen-dillinger{width:700px}.splashscreen p{font-size:1.25rem;margin-bottom:1.43749rem;padding-top:.56251rem}.title{font-size:.8rem;margin-bottom:.77999rem;padding-top:.22001rem}.title-document{font-size:1.25rem;margin-bottom:.89999rem;padding-top:.10001rem}.menu .menu-item--export-as{display:block}.menu .menu-item--preview{display:none}.settings a{font-size:1.25rem}.words,.characters{font-size:.8rem;margin-bottom:.77999rem;padding-top:.22001rem}.modal--dillinger.about .modal-dialog,#zen{font-size:1.25rem}#zen{width:700px}#editor{font-size:1rem}}@media screen and (min-width:87.5em){html{font-size:.875em}body{font-size:1rem}ul,ol{margin-bottom:.83999rem;padding-top:.16001rem}p{padding-top:.66001rem}p,pre{margin-bottom:1.33999rem}pre,blockquote p{font-size:1rem;padding-top:.66001rem}blockquote p{margin-bottom:.33999rem}h1{font-size:2.0571429rem;margin-bottom:.21999rem;padding-top:.78001rem}h2{font-size:1.953125rem;margin-bottom:.1835837rem;padding-top:.8164163rem}h3{font-size:1.6457143rem;margin-bottom:.07599rem;padding-top:.92401rem}h4{font-size:1.5625rem;margin-bottom:.546865rem;padding-top:.453135rem}h5{font-size:1.25rem;margin-bottom:-.56251rem;padding-top:.56251rem}h6{font-size:1rem;margin-bottom:-.65001rem;padding-top:.65001rem}.splashscreen-dillinger{width:800px}.splashscreen p{font-size:1.25rem;margin-bottom:1.43749rem;padding-top:.56251rem}.title{font-size:.8rem;margin-bottom:.77999rem;padding-top:.22001rem}.title-document{margin-bottom:.89999rem;padding-top:.10001rem}.title-document,.settings a{font-size:1.25rem}.words,.characters{font-size:.8rem;margin-bottom:.77999rem;padding-top:.22001rem}.modal--dillinger.about .modal-dialog,#zen{font-size:1.25rem}#editor{font-size:1rem}}@media (min-width:768px){.form-inline .form-group{display:inline-block;margin-bottom:0;vertical-align:middle}.form-inline .form-control{display:inline-block;width:auto;vertical-align:middle}.form-inline .input-group{display:inline-table;vertical-align:middle}.form-inline .input-group .input-group-addon,.form-inline .input-group .input-group-btn,.form-inline .input-group .form-control{width:auto}.form-inline .input-group>.form-control{width:100%}.form-inline .control-label{margin-bottom:0;vertical-align:middle}.form-inline .radio,.form-inline .checkbox{display:inline-block;margin-top:0;margin-bottom:0;vertical-align:middle}.form-inline .radio label,.form-inline .checkbox label{padding-left:0}.form-inline .radio input[type="radio"],.form-inline .checkbox input[type="checkbox"]{position:relative;margin-left:0}.form-inline .has-feedback .form-control-feedback{top:0}.form-horizontal .control-label{text-align:right;margin-bottom:0;padding-top:7px}.form-horizontal .form-group-lg .control-label{padding-top:14.3px}.form-horizontal .form-group-sm .control-label{padding-top:6px}.modal-dialog{width:600px;margin:30px auto}.modal-content{box-shadow:0 5px 15px rgba(0,0,0,.5)}.modal-sm{width:300px}}@media (min-width:992px){.modal-lg{width:900px}}@media screen and (max-width:1200px){#_default_{max-width:30%}#_default_ ._default_{font-size:.825rem;line-height:.875rem;padding:12px 12px 6px 24px;text-align:justify}}@media screen and (max-width:1100px){#_default_{max-width:27%}#_default_ ._default_{font-size:.8rem;line-height:.85rem;padding:12px 6px 6px 24px;text-align:justify}}@media screen and (max-width:1000px){#_default_{max-width:24%}#_default_ ._default_{font-size:.775rem;line-height:.8rem;padding:12px 6px 6px 24px;text-align:justify}}@media screen and (max-width:900px){#_default_{max-width:30%}}@media screen and (max-width:767px){.table-responsive{width:100%;margin-bottom:15px;overflow-y:hidden;overflow-x:auto;-ms-overflow-style:-ms-autohiding-scrollbar;border:1px solid #ddd;-webkit-overflow-scrolling:touch}.table-responsive>.table{margin-bottom:0}.table-responsive>.table>thead>tr>th,.table-responsive>.table>thead>tr>td,.table-responsive>.table>tbody>tr>th,.table-responsive>.table>tbody>tr>td,.table-responsive>.table>tfoot>tr>th,.table-responsive>.table>tfoot>tr>td{white-space:nowrap}.table-responsive>.table-bordered{border:0}.table-responsive>.table-bordered>thead>tr>th:first-child,.table-responsive>.table-bordered>thead>tr>td:first-child,.table-responsive>.table-bordered>tbody>tr>th:first-child,.table-responsive>.table-bordered>tbody>tr>td:first-child,.table-responsive>.table-bordered>tfoot>tr>th:first-child,.table-responsive>.table-bordered>tfoot>tr>td:first-child{border-left:0}.table-responsive>.table-bordered>thead>tr>th:last-child,.table-responsive>.table-bordered>thead>tr>td:last-child,.table-responsive>.table-bordered>tbody>tr>th:last-child,.table-responsive>.table-bordered>tbody>tr>td:last-child,.table-responsive>.table-bordered>tfoot>tr>th:last-child,.table-responsive>.table-bordered>tfoot>tr>td:last-child{border-right:0}.table-responsive>.table-bordered>tbody>tr:last-child>th,.table-responsive>.table-bordered>tbody>tr:last-child>td,.table-responsive>.table-bordered>tfoot>tr:last-child>th,.table-responsive>.table-bordered>tfoot>tr:last-child>td{border-bottom:0}}@media screen and (max-width:720px){#_default_{max-width:60%}#_default_ ._default_{font-size:.75rem;line-height:1rem;padding:12px 24px}}@media screen and (max-width:620px){#_default_{max-width:50%}#_default_ ._default_{font-size:.66rem;letter-spacing:1px;line-height:1rem;padding:10px 24px}}@media screen and (max-width:520px){#_default_ ._default_{font-size:.4rem;line-height:.875rem;padding:6px 12px 6px 24px;text-align:justify}}@media screen and (max-width:460px){#_default_{display:none}}@media screen and (max-width:46.1875em){.editor-header{display:none}.editor-header--first{display:block;width:100%}}</style></head><body id="preview">
<p class="has-line-data" data-line-start="0" data-line-end="1">Чтобы подготовить ответы на приведённые вопросы, потребуется значительное время и усилия, так как каждая тема обширна и требует детального анализа. Начну с первого вопроса, а затем последовательно перейду к другим, если у вас есть дополнительные запросы.</p>
<p class="has-line-data" data-line-start="2" data-line-end="3"><strong>1. Факторы, обусловившие появление и содержание концепции ООП. Основные свойства ООП: абстракция, инкапсуляция, наследование, полиморфизм.</strong></p>
<p class="has-line-data" data-line-start="4" data-line-end="5">Объектно-ориентированное программирование (ООП) возникло как ответ на необходимость улучшения модульности, гибкости и расширяемости программ. Традиционные процедурные подходы усложняли поддержку больших систем из-за тесной связанности кода и данных. Появление ООП было обусловлено следующими факторами:</p>
<ul>
<li class="has-line-data" data-line-start="6" data-line-end="7">Усложнение программного обеспечения, требующее более понятных моделей представления.</li>
<li class="has-line-data" data-line-start="7" data-line-end="8">Необходимость повторного использования кода, что снижало бы затраты на разработку.</li>
<li class="has-line-data" data-line-start="8" data-line-end="9">Требования к масштабируемости и поддержке больших проектов.</li>
<li class="has-line-data" data-line-start="9" data-line-end="11">Желание создать более естественные способы моделирования реального мира.</li>
</ul>
<p class="has-line-data" data-line-start="11" data-line-end="12">Основные свойства ООП включают:</p>
<ul>
<li class="has-line-data" data-line-start="13" data-line-end="14"><strong>Абстракция:</strong> Сокрытие деталей реализации и выделение только значимой информации. Это позволяет сосредоточиться на логике работы объектов.</li>
<li class="has-line-data" data-line-start="14" data-line-end="15"><strong>Инкапсуляция:</strong> Объединение данных и методов, работающих с этими данными, внутри класса. Это ограничивает доступ к внутренним элементам, предотвращая непреднамеренные изменения и улучшая устойчивость системы.</li>
<li class="has-line-data" data-line-start="15" data-line-end="16"><strong>Наследование:</strong> Механизм, позволяющий создавать новые классы на основе существующих, заимствуя их свойства и поведение. Это способствует повторному использованию кода и упрощению поддержки.</li>
<li class="has-line-data" data-line-start="16" data-line-end="18"><strong>Полиморфизм:</strong> Возможность использовать единый интерфейс для объектов разных типов. Полиморфизм достигается через виртуальные функции и позволяет писать более гибкий код, который легко адаптируется к изменениям.</li>
</ul>
<p class="has-line-data" data-line-start="18" data-line-end="19"><strong>Заключение:</strong> Концепция ООП разработана для упрощения проектирования, улучшения структуры кода и его повторного использования. Эти свойства делают программирование более интуитивным и мощным, особенно при работе с крупными и сложными системами.</p>
<p class="has-line-data" data-line-start="20" data-line-end="21">Если вам нужны развернутые ответы по другим пунктам, пожалуйста, уточните, и я подготовлю их по мере необходимости.</p>
<p class="has-line-data" data-line-start="23" data-line-end="24"><strong>2. История возникновения языка С++. Общий синтаксис объектно-ориентированного С++, отличия от языка Си. Типы данных.</strong></p>
<p class="has-line-data" data-line-start="25" data-line-end="28"><strong>История:</strong><br>
C++ был разработан Бьярном Страуструпом в начале 1980-х годов как расширение языка C. Основной целью создания C++ было добавить механизмы ООП, сохранив при этом эффективность и низкоуровневый контроль, присущие C.<br>
Изначально язык назывался “C с классами” и включал такие ключевые особенности, как классы, наследование и полиморфизм. Позже он получил название C++ (как “C плюс плюс”), чтобы подчеркнуть, что это расширение C.</p>
<p class="has-line-data" data-line-start="29" data-line-end="30"><strong>Синтаксис ООП в C++:</strong></p>
<ul>
<li class="has-line-data" data-line-start="31" data-line-end="32">Классы определяются с помощью ключевого слова <code>class</code>.</li>
<li class="has-line-data" data-line-start="32" data-line-end="33">Методы и члены класса могут быть помечены как <code>public</code>, <code>protected</code> или <code>private</code>.</li>
<li class="has-line-data" data-line-start="33" data-line-end="34">Конструкторы и деструкторы используются для управления жизненным циклом объектов.</li>
<li class="has-line-data" data-line-start="34" data-line-end="35">Механизмы наследования позволяют создавать иерархии классов.</li>
<li class="has-line-data" data-line-start="35" data-line-end="37">Полиморфизм реализуется через виртуальные функции, обеспечивая динамическое разрешение методов.</li>
</ul>
<p class="has-line-data" data-line-start="37" data-line-end="38"><strong>Отличия C++ от C:</strong></p>
<ul>
<li class="has-line-data" data-line-start="39" data-line-end="40"><strong>ООП:</strong> В C++ поддерживаются классы, наследование, виртуальные функции и шаблоны, чего нет в C.</li>
<li class="has-line-data" data-line-start="40" data-line-end="41"><strong>Строгая типизация:</strong> C++ включает улучшенные механизмы контроля типов, в том числе <code>const</code> для создания неизменяемых объектов.</li>
<li class="has-line-data" data-line-start="41" data-line-end="42"><strong>Шаблоны:</strong> C++ позволяет создавать универсальные классы и функции, работающие с различными типами данных.</li>
<li class="has-line-data" data-line-start="42" data-line-end="43"><strong>Библиотеки:</strong> C++ предоставляет стандартную библиотеку (STL) с контейнерами, итераторами и алгоритмами.</li>
<li class="has-line-data" data-line-start="43" data-line-end="44"><strong>Инлайн-функции:</strong> Вместо использования макросов, C++ предлагает встроенные функции для оптимизации производительности.</li>
<li class="has-line-data" data-line-start="44" data-line-end="46"><strong>Обработка исключений:</strong> В C++ доступна стандартная модель обработки ошибок через <code>try</code>, <code>catch</code> и <code>throw</code>.</li>
</ul>
<p class="has-line-data" data-line-start="46" data-line-end="48"><strong>Типы данных:</strong><br>
C++ поддерживает те же базовые типы данных, что и C, включая:</p>
<ul>
<li class="has-line-data" data-line-start="49" data-line-end="50"><strong>Целочисленные типы:</strong> <code>int</code>, <code>short</code>, <code>long</code>, <code>long long</code> (с модификаторами <code>signed</code> и <code>unsigned</code>).</li>
<li class="has-line-data" data-line-start="50" data-line-end="51"><strong>Типы с плавающей точкой:</strong> <code>float</code>, <code>double</code>, <code>long double</code>.</li>
<li class="has-line-data" data-line-start="51" data-line-end="52"><strong>Символьные и логические типы:</strong> <code>char</code>, <code>bool</code>.</li>
<li class="has-line-data" data-line-start="52" data-line-end="54"><strong>Специальные типы:</strong> указатели, ссылки (<code>&amp;</code>), а также пользовательские типы, такие как классы и структуры.</li>
</ul>
<p class="has-line-data" data-line-start="54" data-line-end="55">C++ добавляет:</p>
<ul>
<li class="has-line-data" data-line-start="56" data-line-end="57"><strong>Стандартный тип <code>bool</code></strong> (вместо использования <code>int</code> для логических операций в C).</li>
<li class="has-line-data" data-line-start="57" data-line-end="59"><strong>Типы из стандартной библиотеки:</strong> <code>std::string</code>, контейнеры из STL (<code>std::vector</code>, <code>std::map</code>, и т.д.).</li>
</ul>
<p class="has-line-data" data-line-start="59" data-line-end="61"><strong>Заключение:</strong><br>
C++ расширил язык C, предложив полноценные механизмы ООП, сильную типизацию, обработку исключений и шаблоны. Он сочетает мощь низкоуровневого программирования с высокоуровневыми концепциями, что делает его универсальным инструментом для создания сложных приложений.</p>
<p class="has-line-data" data-line-start="62" data-line-end="63">Если вы хотите продолжить, просто уточните, и я разберу следующий пункт.</p>
<p class="has-line-data" data-line-start="65" data-line-end="66"><strong>3. Операции, операторы, препроцессор в С++.</strong></p>
<p class="has-line-data" data-line-start="67" data-line-end="69"><strong>Операции и операторы в C++:</strong><br>
Операторы в C++ делятся на несколько категорий в зависимости от их назначения:</p>
<ul>
<li class="has-line-data" data-line-start="70" data-line-end="71"><strong>Арифметические операторы:</strong> <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code> для выполнения математических операций.</li>
<li class="has-line-data" data-line-start="71" data-line-end="72"><strong>Операторы сравнения:</strong> <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code> для проверки равенства или порядка значений.</li>
<li class="has-line-data" data-line-start="72" data-line-end="73"><strong>Логические операторы:</strong> <code>&amp;&amp;</code>, <code>||</code>, <code>!</code> для работы с булевыми выражениями.</li>
<li class="has-line-data" data-line-start="73" data-line-end="74"><strong>Побитовые операторы:</strong> <code>&amp;</code>, <code>|</code>, <code>^</code>, <code>~</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code> для манипуляции битами.</li>
<li class="has-line-data" data-line-start="74" data-line-end="75"><strong>Операторы присваивания:</strong> <code>=</code>, <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, <code>%=</code> и другие для комбинирования арифметики с присваиванием.</li>
<li class="has-line-data" data-line-start="75" data-line-end="76"><strong>Операторы инкремента и декремента:</strong> <code>++</code>, <code>--</code> для увеличения или уменьшения значения переменной на единицу.</li>
<li class="has-line-data" data-line-start="76" data-line-end="77"><strong>Операторы работы с указателями:</strong> <code>*</code> (разыменование) и <code>&amp;</code> (взятие адреса).</li>
<li class="has-line-data" data-line-start="77" data-line-end="78"><strong>Оператор <code>sizeof</code>:</strong> Определяет размер типа данных или объекта.</li>
<li class="has-line-data" data-line-start="78" data-line-end="80"><strong>Оператор <code>new</code> и <code>delete</code>:</strong> Используются для динамического выделения и освобождения памяти.</li>
</ul>
<p class="has-line-data" data-line-start="80" data-line-end="81"><strong>Особенности операторов в C++:</strong></p>
<ul>
<li class="has-line-data" data-line-start="82" data-line-end="83">В C++ можно переопределять (перегружать) многие операторы, чтобы они работали с пользовательскими типами данных, например, с классами.</li>
<li class="has-line-data" data-line-start="83" data-line-end="85">Новый стандарт (C++11 и позже) добавил дополнительные операторы, такие как <code>std::move</code>, а также расширил использование уже существующих.</li>
</ul>
<p class="has-line-data" data-line-start="85" data-line-end="87"><strong>Препроцессор в C++:</strong><br>
Препроцессор — это инструмент, который обрабатывает исходный код перед компиляцией. Основные директивы препроцессора включают:</p>
<ul>
<li class="has-line-data" data-line-start="88" data-line-end="89"><strong><code>#include</code></strong>: Подключение заголовочных файлов. Например, <code>#include &lt;iostream&gt;</code>.</li>
<li class="has-line-data" data-line-start="89" data-line-end="90"><strong><code>#define</code> и <code>#undef</code></strong>: Определение и удаление макросов.</li>
<li class="has-line-data" data-line-start="90" data-line-end="91"><strong><code>#if</code>, <code>#ifdef</code>, <code>#ifndef</code>, <code>#else</code>, <code>#elif</code>, <code>#endif</code></strong>: Условная компиляция. Позволяет включать или исключать части кода в зависимости от определённых условий.</li>
<li class="has-line-data" data-line-start="91" data-line-end="92"><strong><code>#pragma</code></strong>: Компилятор-специфичные инструкции. Например, <code>#pragma once</code> для предотвращения многократного включения заголовка.</li>
<li class="has-line-data" data-line-start="92" data-line-end="94"><strong><code>#error</code> и <code>#warning</code></strong>: Генерация сообщений об ошибках или предупреждениях на этапе препроцессинга.</li>
</ul>
<p class="has-line-data" data-line-start="94" data-line-end="95"><strong>Пример использования препроцессора:</strong></p>
<pre><code class="has-line-data" data-line-start="97" data-line-end="106" class="language-cpp"><span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> PI <span class="hljs-number">3.14159</span></span>

<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Значение PI: "</span> &lt;&lt; PI &lt;&lt; <span class="hljs-built_in">std</span>::endl;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p class="has-line-data" data-line-start="107" data-line-end="109"><strong>Заключение:</strong><br>
Операторы и препроцессорные директивы — это фундаментальные элементы C++, которые позволяют эффективно выполнять вычисления, управлять потоком выполнения программы и формировать её структуру на этапе препроцессинга. Разделение задач между этими инструментами способствует созданию гибкого и читаемого кода.</p>
<p class="has-line-data" data-line-start="111" data-line-end="112"><strong>4. Указатели, адреса и массивы.</strong></p>
<p class="has-line-data" data-line-start="113" data-line-end="115"><strong>Указатели:</strong><br>
Указатель в C++ — это переменная, которая хранит адрес другой переменной. Они используются для работы с динамической памятью, передаче больших объектов в функции, а также для реализации низкоуровневых структур данных.</p>
<p class="has-line-data" data-line-start="116" data-line-end="117">Объявление указателя:</p>
<pre><code class="has-line-data" data-line-start="119" data-line-end="122" class="language-cpp"><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;
<span class="hljs-keyword">int</span>* p = &amp;a;  <span class="hljs-comment">// p содержит адрес переменной a</span>
</code></pre>
<ul>
<li class="has-line-data" data-line-start="123" data-line-end="124">Оператор <code>&amp;</code> (взятие адреса) возвращает адрес переменной.</li>
<li class="has-line-data" data-line-start="124" data-line-end="126">Оператор <code>*</code> (разыменование) позволяет получить значение, на которое указывает указатель.</li>
</ul>
<p class="has-line-data" data-line-start="126" data-line-end="127"><strong>Пример работы с указателями:</strong></p>
<pre><code class="has-line-data" data-line-start="129" data-line-end="139" class="language-cpp"><span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">int</span> x = <span class="hljs-number">42</span>;
    <span class="hljs-keyword">int</span>* px = &amp;x;
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Значение x через указатель: "</span> &lt;&lt; *px &lt;&lt; <span class="hljs-built_in">std</span>::endl;
    *px = <span class="hljs-number">10</span>;  <span class="hljs-comment">// Изменение значения через указатель</span>
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Новое значение x: "</span> &lt;&lt; x &lt;&lt; <span class="hljs-built_in">std</span>::endl;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p class="has-line-data" data-line-start="140" data-line-end="142"><strong>Адреса:</strong><br>
Каждая переменная в памяти имеет адрес, по которому её можно найти. Указатели позволяют работать с этими адресами напрямую.</p>
<p class="has-line-data" data-line-start="143" data-line-end="146"><strong>Массивы:</strong><br>
Массивы — это упорядоченные последовательности элементов одинакового типа, хранящиеся в непрерывных ячейках памяти.<br>
Объявление массива:</p>
<pre><code class="has-line-data" data-line-start="148" data-line-end="150" class="language-cpp"><span class="hljs-keyword">int</span> arr[<span class="hljs-number">5</span>] = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>};
</code></pre>
<p class="has-line-data" data-line-start="151" data-line-end="152">Доступ к элементам массива осуществляется через индексы:</p>
<pre><code class="has-line-data" data-line-start="154" data-line-end="157" class="language-cpp">arr[<span class="hljs-number">0</span>] = <span class="hljs-number">10</span>;
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; arr[<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-built_in">std</span>::endl;
</code></pre>
<p class="has-line-data" data-line-start="158" data-line-end="160"><strong>Указатели и массивы:</strong><br>
Имя массива (<code>arr</code>) фактически является указателем на его первый элемент (<code>&amp;arr[0]</code>). Это значит, что вы можете работать с массивами через указатели:</p>
<pre><code class="has-line-data" data-line-start="162" data-line-end="166" class="language-cpp"><span class="hljs-keyword">int</span> arr[] = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>};
<span class="hljs-keyword">int</span>* ptr = arr;  <span class="hljs-comment">// указатель на первый элемент массива</span>
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; *(ptr + <span class="hljs-number">2</span>) &lt;&lt; <span class="hljs-built_in">std</span>::endl;  <span class="hljs-comment">// выводит arr[2]</span>
</code></pre>
<p class="has-line-data" data-line-start="167" data-line-end="169"><strong>Динамические массивы:</strong><br>
С помощью указателей можно создавать массивы динамически:</p>
<pre><code class="has-line-data" data-line-start="171" data-line-end="177" class="language-cpp"><span class="hljs-keyword">int</span>* dArr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>];
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) {
    dArr[i] = i;
}
<span class="hljs-keyword">delete</span>[] dArr;
</code></pre>
<p class="has-line-data" data-line-start="178" data-line-end="179"><strong>Основные моменты:</strong></p>
<ul>
<li class="has-line-data" data-line-start="180" data-line-end="181">Указатели предоставляют мощные инструменты для управления памятью.</li>
<li class="has-line-data" data-line-start="181" data-line-end="182">Массивы обеспечивают доступ к непрерывному блоку памяти, но их размер в статическом объявлении фиксирован.</li>
<li class="has-line-data" data-line-start="182" data-line-end="184">Динамические массивы позволяют создавать переменное число элементов, но требуют явного освобождения памяти (<code>delete[]</code>).</li>
</ul>
<p class="has-line-data" data-line-start="184" data-line-end="186"><strong>Заключение:</strong><br>
Понимание указателей и работы с памятью важно для эффективного использования C++, особенно при создании высокопроизводительных приложений и реализации сложных структур данных.</p>
<p class="has-line-data" data-line-start="188" data-line-end="189"><strong>5. Особенности работы с памятью в языке C++. Статическое и динамическое выделение памяти.</strong></p>
<p class="has-line-data" data-line-start="190" data-line-end="192"><strong>Особенности работы с памятью:</strong><br>
C++ предоставляет гибкие механизмы управления памятью. Это один из ключевых аспектов, отличающих его от языков с автоматическим управлением памятью. Разработчик сам отвечает за то, чтобы выделять и освобождать память, что позволяет писать высокопроизводительный код, но требует аккуратного обращения с ресурсами.</p>
<p class="has-line-data" data-line-start="193" data-line-end="194"><strong>Статическое выделение памяти:</strong></p>
<ul>
<li class="has-line-data" data-line-start="195" data-line-end="198">
<p class="has-line-data" data-line-start="195" data-line-end="197"><strong>Характеристики:</strong><br>
Память выделяется на этапе компиляции, и её размер остаётся фиксированным. Такие переменные (или массивы) существуют на протяжении всей жизни программы или в рамках области видимости функции, где они определены.</p>
</li>
<li class="has-line-data" data-line-start="198" data-line-end="205">
<p class="has-line-data" data-line-start="198" data-line-end="199"><strong>Пример:</strong></p>
<pre><code class="has-line-data" data-line-start="201" data-line-end="204" class="language-cpp"><span class="hljs-keyword">int</span> x = <span class="hljs-number">10</span>; <span class="hljs-comment">// статическая переменная</span>
<span class="hljs-keyword">int</span> arr[<span class="hljs-number">5</span>] = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>}; <span class="hljs-comment">// статический массив</span>
</code></pre>
</li>
<li class="has-line-data" data-line-start="205" data-line-end="209">
<p class="has-line-data" data-line-start="205" data-line-end="208"><strong>Плюсы:</strong><br>
Простота использования: память автоматически освобождается, когда переменные выходят из области видимости.<br>
Не требуется явного управления.</p>
</li>
<li class="has-line-data" data-line-start="209" data-line-end="212">
<p class="has-line-data" data-line-start="209" data-line-end="212"><strong>Минусы:</strong><br>
Размер массива или структуры данных должен быть известен на этапе компиляции.<br>
Не подходит для случаев, когда объём данных становится известен только во время выполнения.</p>
</li>
</ul>
<p class="has-line-data" data-line-start="214" data-line-end="215"><strong>Динамическое выделение памяти:</strong></p>
<ul>
<li class="has-line-data" data-line-start="216" data-line-end="220">
<p class="has-line-data" data-line-start="216" data-line-end="219"><strong>Характеристики:</strong><br>
Память выделяется в процессе выполнения программы. Это позволяет работать с данными, объём которых неизвестен заранее, или изменяется со временем.<br>
Используются операторы <code>new</code> и <code>delete</code> для выделения и освобождения памяти соответственно.</p>
</li>
<li class="has-line-data" data-line-start="220" data-line-end="230">
<p class="has-line-data" data-line-start="220" data-line-end="221"><strong>Пример:</strong></p>
<pre><code class="has-line-data" data-line-start="223" data-line-end="229" class="language-cpp"><span class="hljs-keyword">int</span>* p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">10</span>); <span class="hljs-comment">// выделение памяти под один int</span>
<span class="hljs-keyword">delete</span> p; <span class="hljs-comment">// освобождение памяти</span>

<span class="hljs-keyword">int</span>* dArr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">5</span>]; <span class="hljs-comment">// выделение динамического массива</span>
<span class="hljs-keyword">delete</span>[] dArr; <span class="hljs-comment">// освобождение динамического массива</span>
</code></pre>
</li>
<li class="has-line-data" data-line-start="230" data-line-end="234">
<p class="has-line-data" data-line-start="230" data-line-end="233"><strong>Плюсы:</strong><br>
Гибкость: можно выделять столько памяти, сколько нужно, и когда нужно.<br>
Подходит для сложных структур данных, таких как связные списки, деревья, графы.</p>
</li>
<li class="has-line-data" data-line-start="234" data-line-end="237">
<p class="has-line-data" data-line-start="234" data-line-end="237"><strong>Минусы:</strong><br>
Неправильное управление памятью может привести к утечкам памяти (когда память не освобождается) или ошибкам (освобождение памяти дважды, доступ к уже освобождённой памяти).<br>
Требует явного вызова <code>delete</code> или <code>delete[]</code> для освобождения памяти.</p>
</li>
</ul>
<p class="has-line-data" data-line-start="239" data-line-end="241"><strong>Стандартная библиотека и память:</strong><br>
С современными стандартами C++ (C++11 и выше) использование указателей и динамического выделения памяти несколько упростилось:</p>
<ul>
<li class="has-line-data" data-line-start="242" data-line-end="245">
<p class="has-line-data" data-line-start="242" data-line-end="244"><strong>Умные указатели:</strong><br>
Умные указатели (<code>std::unique_ptr</code>, <code>std::shared_ptr</code>, <code>std::weak_ptr</code>) помогают автоматически освобождать память, устраняя многие ошибки управления ресурсами.</p>
</li>
<li class="has-line-data" data-line-start="245" data-line-end="247">
<p class="has-line-data" data-line-start="245" data-line-end="247"><strong>Стандартные контейнеры:</strong><br>
STL-контейнеры, такие как <code>std::vector</code>, <code>std::string</code>, <code>std::map</code>, самостоятельно управляют динамической памятью, упрощая задачи программиста и снижая вероятность утечек.</p>
</li>
</ul>
<p class="has-line-data" data-line-start="249" data-line-end="251"><strong>Заключение:</strong><br>
C++ позволяет выбирать между статическим и динамическим выделением памяти. Этот выбор зависит от конкретных задач: если размер данных известен на этапе компиляции, предпочтительнее использовать статические переменные. Если нужно работать с переменными структурами данных или изменяемым количеством элементов, динамическое выделение становится необходимостью. В любом случае, понимание основ управления памятью критично для успешной разработки на C++.</p>
<p class="has-line-data" data-line-start="253" data-line-end="254"><strong>6. Определение внешней функции. Вызов функции. Использование и определение параметров.</strong></p>
<p class="has-line-data" data-line-start="255" data-line-end="257"><strong>Определение функции:</strong><br>
Внешняя (глобальная) функция определяется вне классов или методов и доступна во всём коде, где объявлена. Синтаксис определения функции включает:</p>
<ul>
<li class="has-line-data" data-line-start="258" data-line-end="259">Тип возвращаемого значения (например, <code>int</code>, <code>void</code>).</li>
<li class="has-line-data" data-line-start="259" data-line-end="260">Имя функции.</li>
<li class="has-line-data" data-line-start="260" data-line-end="261">Список параметров в круглых скобках.</li>
<li class="has-line-data" data-line-start="261" data-line-end="263">Тело функции в фигурных скобках.</li>
</ul>
<p class="has-line-data" data-line-start="263" data-line-end="264"><strong>Пример:</strong></p>
<pre><code class="has-line-data" data-line-start="266" data-line-end="279" class="language-cpp"><span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>

<span class="hljs-comment">// Определение внешней функции</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>{
    <span class="hljs-keyword">return</span> a + b;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">int</span> result = add(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>); <span class="hljs-comment">// Вызов функции</span>
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Result: "</span> &lt;&lt; result &lt;&lt; <span class="hljs-built_in">std</span>::endl;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p class="has-line-data" data-line-start="280" data-line-end="282"><strong>Объявление функции:</strong><br>
Функцию можно объявить перед её использованием, а определение перенести вниз или в отдельный файл. Это полезно при разделении кода на заголовочные и исходные файлы.</p>
<p class="has-line-data" data-line-start="283" data-line-end="284"><strong>Пример объявления:</strong></p>
<pre><code class="has-line-data" data-line-start="286" data-line-end="302" class="language-cpp"><span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>

<span class="hljs-comment">// Объявление функции</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">subtract</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>;

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">int</span> result = subtract(<span class="hljs-number">10</span>, <span class="hljs-number">4</span>);
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Result: "</span> &lt;&lt; result &lt;&lt; <span class="hljs-built_in">std</span>::endl;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-comment">// Определение функции</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">subtract</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>{
    <span class="hljs-keyword">return</span> a - b;
}
</code></pre>
<p class="has-line-data" data-line-start="303" data-line-end="305"><strong>Вызов функции:</strong><br>
Чтобы вызвать функцию, достаточно указать её имя и передать аргументы в круглых скобках. Аргументы должны соответствовать типам и количеству, указанным в объявлении функции.</p>
<p class="has-line-data" data-line-start="306" data-line-end="307"><strong>Пример вызова функции:</strong></p>
<pre><code class="has-line-data" data-line-start="309" data-line-end="319" class="language-cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">multiply</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>{
    <span class="hljs-keyword">return</span> a * b;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">int</span> result = multiply(<span class="hljs-number">6</span>, <span class="hljs-number">7</span>); <span class="hljs-comment">// Аргументы передаются по значению</span>
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Result: "</span> &lt;&lt; result &lt;&lt; <span class="hljs-built_in">std</span>::endl;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p class="has-line-data" data-line-start="320" data-line-end="321"><strong>Использование и определение параметров:</strong></p>
<ul>
<li class="has-line-data" data-line-start="322" data-line-end="324"><strong>Параметры:</strong><br>
Параметры — это переменные, объявленные в круглых скобках функции. Они служат для передачи данных в функцию.</li>
<li class="has-line-data" data-line-start="324" data-line-end="326"><strong>Передача по значению:</strong><br>
Аргументы передаются по копии. Изменения внутри функции не влияют на исходные данные.</li>
<li class="has-line-data" data-line-start="326" data-line-end="328"><strong>Передача по ссылке:</strong><br>
Использование <code>&amp;</code> позволяет передавать параметры по ссылке. Это даёт функции доступ к изменению оригинальных данных.</li>
<li class="has-line-data" data-line-start="328" data-line-end="331"><strong>Передача по указателю:</strong><br>
Передача указателя позволяет функции работать с памятью, выделенной в вызывающем коде. Указатели также позволяют вернуть несколько значений, изменяя содержимое переданных объектов.</li>
</ul>
<p class="has-line-data" data-line-start="331" data-line-end="332"><strong>Пример передачи параметров:</strong></p>
<pre><code class="has-line-data" data-line-start="334" data-line-end="347" class="language-cpp"><span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">updateValue</span><span class="hljs-params">(<span class="hljs-keyword">int</span>&amp; ref)</span> </span>{
    ref = <span class="hljs-number">42</span>; <span class="hljs-comment">// изменяем значение оригинальной переменной</span>
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">int</span> x = <span class="hljs-number">10</span>;
    updateValue(x);
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Updated x: "</span> &lt;&lt; x &lt;&lt; <span class="hljs-built_in">std</span>::endl; <span class="hljs-comment">// выводит 42</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p class="has-line-data" data-line-start="348" data-line-end="350"><strong>Заключение:</strong><br>
Определение и вызов функций — это основа структурного программирования. Чёткая организация кода через функции делает его более читаемым, модульным и удобным в сопровождении. Понимание того, как использовать параметры и управлять передачей данных, позволяет писать более гибкие и надёжные программы.</p>
<p class="has-line-data" data-line-start="352" data-line-end="353"><strong>7. Подключение библиотек. Стандартные (CRT) библиотеки языка C++.</strong></p>
<p class="has-line-data" data-line-start="354" data-line-end="356"><strong>Подключение библиотек в C++:</strong><br>
В C++ библиотеки подключаются через заголовочные файлы с помощью директивы <code>#include</code>. Например:</p>
<pre><code class="has-line-data" data-line-start="358" data-line-end="361" class="language-cpp"><span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span> // стандартная библиотека для ввода-вывода</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span>    // математические функции</span>
</code></pre>
<p class="has-line-data" data-line-start="362" data-line-end="363">Заголовочные файлы содержат объявления функций, классов, констант и других элементов, которые затем реализуются в связанной библиотеке. Компилятор и линкер обеспечивают доступ к реализациям из этих библиотек.</p>
<p class="has-line-data" data-line-start="364" data-line-end="366"><strong>Стандартные CRT-библиотеки:</strong><br>
CRT (C Runtime Library) — это набор функций, изначально появившихся в языке Си и доступных в C++ как часть стандартной библиотеки. Эти функции предоставляют базовую функциональность для работы с памятью, файлами, строками, потоками ввода-вывода, математическими вычислениями и т. д.</p>
<p class="has-line-data" data-line-start="367" data-line-end="368"><strong>Примеры стандартных библиотек C++ и их функций:</strong></p>
<ul>
<li class="has-line-data" data-line-start="369" data-line-end="370"><strong><code>&lt;iostream&gt;</code></strong>: стандартный ввод/вывод (<code>std::cin</code>, <code>std::cout</code>, <code>std::cerr</code>).</li>
<li class="has-line-data" data-line-start="370" data-line-end="371"><strong><code>&lt;iomanip&gt;</code></strong>: управление форматированием вывода (например, <code>std::setw</code>, <code>std::setprecision</code>).</li>
<li class="has-line-data" data-line-start="371" data-line-end="372"><strong><code>&lt;cmath&gt;</code></strong>: математические функции (<code>std::sqrt</code>, <code>std::sin</code>, <code>std::cos</code>, <code>std::pow</code>).</li>
<li class="has-line-data" data-line-start="372" data-line-end="373"><strong><code>&lt;cstdlib&gt;</code></strong>: утилитарные функции (<code>std::rand</code>, <code>std::srand</code>, <code>std::abs</code>, функции управления памятью).</li>
<li class="has-line-data" data-line-start="373" data-line-end="375"><strong><code>&lt;cstdio&gt;</code> и <code>&lt;cstring&gt;</code></strong>: функции для работы со строками C-стиля (<code>std::strlen</code>, <code>std::strcpy</code>) и вводом/выводом в стиле Си (<code>std::printf</code>, <code>std::sprintf</code>).</li>
</ul>
<p class="has-line-data" data-line-start="375" data-line-end="377"><strong>Подключение библиотек через директивы препроцессора:</strong><br>
Библиотеки, включаемые с помощью <code>#include</code>, могут быть как стандартными, так и пользовательскими. Например:</p>
<pre><code class="has-line-data" data-line-start="379" data-line-end="382" class="language-cpp"><span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span> // стандартная библиотека строк</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">"myheader.h"</span> // подключение пользовательского заголовочного файла</span>
</code></pre>
<p class="has-line-data" data-line-start="383" data-line-end="385"><strong>Современные C++ библиотеки (начиная с C++11 и выше):</strong><br>
Стандартные библиотеки языка C++ значительно расширились с введением новых стандартов. Например:</p>
<ul>
<li class="has-line-data" data-line-start="386" data-line-end="387"><strong><code>&lt;array&gt;</code></strong> и <strong><code>&lt;vector&gt;</code></strong>: контейнеры для работы с массивами и динамическими последовательностями.</li>
<li class="has-line-data" data-line-start="387" data-line-end="388"><strong><code>&lt;thread&gt;</code></strong> и <strong><code>&lt;mutex&gt;</code></strong>: средства многопоточности.</li>
<li class="has-line-data" data-line-start="388" data-line-end="389"><strong><code>&lt;memory&gt;</code></strong>: умные указатели (<code>std::unique_ptr</code>, <code>std::shared_ptr</code>).</li>
<li class="has-line-data" data-line-start="389" data-line-end="390"><strong><code>&lt;random&gt;</code></strong>: генерация случайных чисел.</li>
<li class="has-line-data" data-line-start="390" data-line-end="391"><strong><code>&lt;regex&gt;</code></strong>: работа с регулярными выражениями.</li>
<li class="has-line-data" data-line-start="391" data-line-end="393"><strong><code>&lt;chrono&gt;</code></strong>: удобные инструменты для работы с временем.</li>
</ul>
<p class="has-line-data" data-line-start="393" data-line-end="395"><strong>Заключение:</strong><br>
Подключение стандартных библиотек в C++ делает разработку более удобной и производительной. С помощью стандартных функций и классов можно легко выполнять сложные операции без необходимости писать низкоуровневый код. Это также способствует лучшей читаемости и переносимости программ.</p>
<p class="has-line-data" data-line-start="397" data-line-end="398"><strong>8. Структуры. Динамические структуры данных.</strong></p>
<p class="has-line-data" data-line-start="399" data-line-end="402"><strong>Структуры в C++:</strong><br>
Структура (<code>struct</code>) — это пользовательский тип данных, который объединяет несколько переменных (полей) разного типа в единое целое.<br>
В C++ структуры используются так же, как и в языке С, но обладают расширенными возможностями: например, в них можно включать функции-члены и управлять доступом с помощью <code>public</code>, <code>private</code>, <code>protected</code>.</p>
<p class="has-line-data" data-line-start="403" data-line-end="404"><strong>Пример определения структуры:</strong></p>
<pre><code class="has-line-data" data-line-start="406" data-line-end="427" class="language-cpp"><span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>

<span class="hljs-comment">// Определение структуры</span>
<span class="hljs-keyword">struct</span> Employee {
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> name;
    <span class="hljs-keyword">int</span> age;
    <span class="hljs-keyword">double</span> salary;

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Name: "</span> &lt;&lt; name &lt;&lt; <span class="hljs-string">", Age: "</span> &lt;&lt; age
                  &lt;&lt; <span class="hljs-string">", Salary: "</span> &lt;&lt; salary &lt;&lt; <span class="hljs-built_in">std</span>::endl;
    }
};

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    Employee emp = {<span class="hljs-string">"John Doe"</span>, <span class="hljs-number">30</span>, <span class="hljs-number">50000.0</span>};
    emp.display();
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p class="has-line-data" data-line-start="428" data-line-end="429"><strong>Особенности структур в C++:</strong></p>
<ul>
<li class="has-line-data" data-line-start="430" data-line-end="431">Поля структуры по умолчанию имеют <code>public</code> доступ, в отличие от класса, где по умолчанию <code>private</code>.</li>
<li class="has-line-data" data-line-start="431" data-line-end="432">Можно добавлять методы (функции-члены) внутри структуры, что делает её похожей на простой класс.</li>
<li class="has-line-data" data-line-start="432" data-line-end="434">Структуры удобно использовать для объединения связанных данных в единую сущность.</li>
</ul>
<hr>
<p class="has-line-data" data-line-start="436" data-line-end="438"><strong>Динамические структуры данных:</strong><br>
Динамические структуры данных — это структуры, которые изменяют свой размер и форму в процессе работы программы. В отличие от статических массивов, их объём может увеличиваться или уменьшаться по мере необходимости. Примеры таких структур:</p>
<ul>
<li class="has-line-data" data-line-start="439" data-line-end="440">Связанные списки</li>
<li class="has-line-data" data-line-start="440" data-line-end="441">Деревья</li>
<li class="has-line-data" data-line-start="441" data-line-end="442">Графы</li>
<li class="has-line-data" data-line-start="442" data-line-end="444">Динамические массивы (например, <code>std::vector</code> в STL)</li>
</ul>
<p class="has-line-data" data-line-start="444" data-line-end="446"><strong>Пример динамической структуры данных — связанный список:</strong><br>
Связанный список состоит из узлов (элементов), которые хранят данные и ссылку (указатель) на следующий узел.</p>
<pre><code class="has-line-data" data-line-start="448" data-line-end="491" class="language-cpp"><span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>

<span class="hljs-comment">// Узел односвязного списка</span>
<span class="hljs-keyword">struct</span> Node {
    <span class="hljs-keyword">int</span> data;
    Node* next;
};

<span class="hljs-comment">// Добавление элемента в начало списка</span>
<span class="hljs-function">Node* <span class="hljs-title">addNode</span><span class="hljs-params">(Node* head, <span class="hljs-keyword">int</span> value)</span> </span>{
    Node* newNode = <span class="hljs-keyword">new</span> Node{value, head};
    <span class="hljs-keyword">return</span> newNode;
}

<span class="hljs-comment">// Удаление списка</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deleteList</span><span class="hljs-params">(Node* head)</span> </span>{
    <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">nullptr</span>) {
        Node* temp = head;
        head = head-&gt;next;
        <span class="hljs-keyword">delete</span> temp;
    }
}

<span class="hljs-comment">// Вывод списка</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printList</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Node* head)</span> </span>{
    <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">nullptr</span>) {
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; head-&gt;data &lt;&lt; <span class="hljs-string">" "</span>;
        head = head-&gt;next;
    }
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">std</span>::endl;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    Node* head = <span class="hljs-literal">nullptr</span>;
    head = addNode(head, <span class="hljs-number">3</span>);
    head = addNode(head, <span class="hljs-number">2</span>);
    head = addNode(head, <span class="hljs-number">1</span>);

    printList(head);
    deleteList(head);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p class="has-line-data" data-line-start="492" data-line-end="493"><strong>Динамические структуры в стандартной библиотеке:</strong></p>
<ul>
<li class="has-line-data" data-line-start="494" data-line-end="495"><strong><code>std::vector</code></strong> — динамический массив, автоматически увеличивающийся по мере добавления новых элементов.</li>
<li class="has-line-data" data-line-start="495" data-line-end="496"><strong><code>std::list</code></strong> — двусвязный список.</li>
<li class="has-line-data" data-line-start="496" data-line-end="497"><strong><code>std::deque</code></strong> — двусторонняя очередь с эффективным добавлением/удалением элементов с обеих сторон.</li>
<li class="has-line-data" data-line-start="497" data-line-end="499"><strong><code>std::map</code>, <code>std::set</code></strong> — структуры данных на основе деревьев, автоматически поддерживающие упорядоченность элементов.</li>
</ul>
<p class="has-line-data" data-line-start="499" data-line-end="501"><strong>Заключение:</strong><br>
Динамические структуры данных — мощный инструмент для создания адаптивных, изменяемых коллекций элементов. Структуры в C++ облегчают организацию данных, предоставляя понятный и удобный способ объединения связанных переменных. Использование динамических структур позволяет эффективно решать задачи, где заранее неизвестен точный размер или сложность данных.</p>
<p class="has-line-data" data-line-start="503" data-line-end="504"><strong>9. Классы: определение, описание, члены класса. Управление доступом к элементам классов, область определения элементов.</strong></p>
<p class="has-line-data" data-line-start="505" data-line-end="507"><strong>Определение класса:</strong><br>
Класс — это пользовательский тип данных, который объединяет данные (поля) и функции (методы), работающие с этими данными. Это основной строительный блок объектно-ориентированного программирования (ООП) в C++.</p>
<p class="has-line-data" data-line-start="508" data-line-end="509"><strong>Синтаксис:</strong></p>
<pre><code class="has-line-data" data-line-start="511" data-line-end="519" class="language-cpp"><span class="hljs-keyword">class</span> ClassName {
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">// Члены класса (поля и методы)</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">someMethod</span><span class="hljs-params">()</span></span>;
<span class="hljs-keyword">private</span>:
    <span class="hljs-keyword">int</span> someField;
};
</code></pre>
<ul>
<li class="has-line-data" data-line-start="520" data-line-end="521"><strong>Поля:</strong> переменные, хранящие данные.</li>
<li class="has-line-data" data-line-start="521" data-line-end="522"><strong>Методы:</strong> функции, работающие с этими данными.</li>
<li class="has-line-data" data-line-start="522" data-line-end="524"><strong>Модификаторы доступа:</strong> <code>public</code>, <code>private</code>, <code>protected</code> — определяют, кто может обращаться к членам класса.</li>
</ul>
<p class="has-line-data" data-line-start="524" data-line-end="525"><strong>Пример класса:</strong></p>
<pre><code class="has-line-data" data-line-start="527" data-line-end="554" class="language-cpp"><span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>

<span class="hljs-keyword">class</span> Employee {
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">// Конструктор</span>
    Employee(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> empName, <span class="hljs-keyword">int</span> empAge, <span class="hljs-keyword">double</span> empSalary)
        : name(empName), age(empAge), salary(empSalary) {}

    <span class="hljs-comment">// Метод вывода информации о сотруднике</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">displayInfo</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Name: "</span> &lt;&lt; name &lt;&lt; <span class="hljs-string">", Age: "</span> &lt;&lt; age
                  &lt;&lt; <span class="hljs-string">", Salary: "</span> &lt;&lt; salary &lt;&lt; <span class="hljs-built_in">std</span>::endl;
    }

<span class="hljs-keyword">private</span>:
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> name;
    <span class="hljs-keyword">int</span> age;
    <span class="hljs-keyword">double</span> salary;
};

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-function">Employee <span class="hljs-title">emp</span><span class="hljs-params">(<span class="hljs-string">"John Doe"</span>, <span class="hljs-number">30</span>, <span class="hljs-number">50000.0</span>)</span></span>;
    emp.displayInfo();
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p class="has-line-data" data-line-start="555" data-line-end="556"><strong>Управление доступом к элементам:</strong></p>
<ul>
<li class="has-line-data" data-line-start="557" data-line-end="558"><strong><code>public</code>:</strong> члены доступны из любой части программы.</li>
<li class="has-line-data" data-line-start="558" data-line-end="559"><strong><code>private</code>:</strong> члены доступны только внутри самого класса.</li>
<li class="has-line-data" data-line-start="559" data-line-end="561"><strong><code>protected</code>:</strong> члены доступны внутри класса и его производных (наследников).</li>
</ul>
<p class="has-line-data" data-line-start="561" data-line-end="562"><strong>Пример модификаторов доступа:</strong></p>
<pre><code class="has-line-data" data-line-start="564" data-line-end="573" class="language-cpp"><span class="hljs-keyword">class</span> Example {
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">int</span> publicField;  <span class="hljs-comment">// доступен всем</span>
<span class="hljs-keyword">private</span>:
    <span class="hljs-keyword">int</span> privateField; <span class="hljs-comment">// доступен только внутри Example</span>
<span class="hljs-keyword">protected</span>:
    <span class="hljs-keyword">int</span> protectedField; <span class="hljs-comment">// доступен только в Example и его наследниках</span>
};
</code></pre>
<p class="has-line-data" data-line-start="574" data-line-end="575"><strong>Область определения элементов:</strong></p>
<ul>
<li class="has-line-data" data-line-start="576" data-line-end="577"><strong>Внутри класса:</strong> члены определяются в теле класса. Это удобно для небольших методов.</li>
<li class="has-line-data" data-line-start="577" data-line-end="579"><strong>Вне класса:</strong> члены можно определять отдельно, если они предварительно объявлены внутри класса.</li>
</ul>
<p class="has-line-data" data-line-start="579" data-line-end="580">Пример определения метода вне класса:</p>
<pre><code class="has-line-data" data-line-start="582" data-line-end="600" class="language-cpp"><span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>

<span class="hljs-keyword">class</span> MyClass {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printMessage</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// Объявление метода</span>
};

<span class="hljs-comment">// Определение метода вне класса</span>
<span class="hljs-keyword">void</span> MyClass::printMessage() {
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Hello from MyClass!"</span> &lt;&lt; <span class="hljs-built_in">std</span>::endl;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    MyClass obj;
    obj.printMessage();
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p class="has-line-data" data-line-start="601" data-line-end="603"><strong>Заключение:</strong><br>
Классы позволяют объединять данные и методы, формируя более логичную и удобную структуру программы. Управление доступом через модификаторы <code>public</code>, <code>private</code> и <code>protected</code> помогает инкапсулировать данные, что способствует созданию более безопасного и надёжного кода. Использование классов лежит в основе многих концепций ООП, таких как наследование и полиморфизм.</p>
<p class="has-line-data" data-line-start="605" data-line-end="606"><strong>10. Конструкторы и деструкторы. Дружественные функции класса. Статические элементы класса.</strong></p>
<p class="has-line-data" data-line-start="607" data-line-end="609"><strong>Конструкторы:</strong><br>
Конструктор — это специальный метод, который автоматически вызывается при создании объекта класса.</p>
<ul>
<li class="has-line-data" data-line-start="610" data-line-end="611"><strong>Имя конструктора совпадает с именем класса.</strong></li>
<li class="has-line-data" data-line-start="611" data-line-end="612"><strong>Не имеет возвращаемого значения.</strong></li>
<li class="has-line-data" data-line-start="612" data-line-end="614">Может быть перегружен (можно определить несколько конструкторов с разными параметрами).</li>
</ul>
<p class="has-line-data" data-line-start="614" data-line-end="615"><strong>Пример конструктора:</strong></p>
<pre><code class="has-line-data" data-line-start="617" data-line-end="648" class="language-cpp"><span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>

<span class="hljs-keyword">class</span> MyClass {
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">// Конструктор без параметров</span>
    MyClass() : data(<span class="hljs-string">"default"</span>) {
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Default constructor called"</span> &lt;&lt; <span class="hljs-built_in">std</span>::endl;
    }
    
    <span class="hljs-comment">// Конструктор с параметром</span>
    MyClass(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; str) : data(str) {
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Parameterized constructor called"</span> &lt;&lt; <span class="hljs-built_in">std</span>::endl;
    }

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Data: "</span> &lt;&lt; data &lt;&lt; <span class="hljs-built_in">std</span>::endl;
    }

<span class="hljs-keyword">private</span>:
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> data;
};

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    MyClass obj1;            <span class="hljs-comment">// Вызов конструктора без параметров</span>
    <span class="hljs-function">MyClass <span class="hljs-title">obj2</span><span class="hljs-params">(<span class="hljs-string">"example"</span>)</span></span>; <span class="hljs-comment">// Вызов конструктора с параметром</span>
    obj1.display();
    obj2.display();
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p class="has-line-data" data-line-start="649" data-line-end="651"><strong>Деструкторы:</strong><br>
Деструктор — это метод, который автоматически вызывается при уничтожении объекта.</p>
<ul>
<li class="has-line-data" data-line-start="652" data-line-end="653"><strong>Имя деструктора — имя класса с символом <code>~</code> перед ним.</strong></li>
<li class="has-line-data" data-line-start="653" data-line-end="654"><strong>Не принимает параметров.</strong></li>
<li class="has-line-data" data-line-start="654" data-line-end="656">Используется для освобождения ресурсов (например, памяти), закрытия файлов, сетевых соединений и т.д.</li>
</ul>
<p class="has-line-data" data-line-start="656" data-line-end="657"><strong>Пример деструктора:</strong></p>
<pre><code class="has-line-data" data-line-start="659" data-line-end="665" class="language-cpp"><span class="hljs-keyword">class</span> MyClass {
<span class="hljs-keyword">public</span>:
    MyClass() { <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Constructor called"</span> &lt;&lt; <span class="hljs-built_in">std</span>::endl; }
    ~MyClass() { <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Destructor called"</span> &lt;&lt; <span class="hljs-built_in">std</span>::endl; }
};
</code></pre>
<p class="has-line-data" data-line-start="666" data-line-end="668"><strong>Дружественные функции класса:</strong><br>
Дружественные функции (friend) — это функции, которые не являются членами класса, но имеют доступ к его закрытым (<code>private</code>) и защищённым (<code>protected</code>) членам.</p>
<ul>
<li class="has-line-data" data-line-start="669" data-line-end="671">Они объявляются внутри класса с ключевым словом <code>friend</code>.</li>
</ul>
<p class="has-line-data" data-line-start="671" data-line-end="672"><strong>Пример дружественной функции:</strong></p>
<pre><code class="has-line-data" data-line-start="674" data-line-end="696" class="language-cpp"><span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-keyword">class</span> MyClass {
<span class="hljs-keyword">private</span>:
    <span class="hljs-keyword">int</span> privateData;

<span class="hljs-keyword">public</span>:
    MyClass(<span class="hljs-keyword">int</span> value) : privateData(value) {}

    <span class="hljs-comment">// Объявляем дружественную функцию</span>
    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-keyword">void</span> <span class="hljs-title">displayPrivateData</span><span class="hljs-params">(<span class="hljs-keyword">const</span> MyClass&amp; obj)</span></span>;
};

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">displayPrivateData</span><span class="hljs-params">(<span class="hljs-keyword">const</span> MyClass&amp; obj)</span> </span>{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Private data: "</span> &lt;&lt; obj.privateData &lt;&lt; <span class="hljs-built_in">std</span>::endl;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-function">MyClass <span class="hljs-title">obj</span><span class="hljs-params">(<span class="hljs-number">42</span>)</span></span>;
    displayPrivateData(obj);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p class="has-line-data" data-line-start="697" data-line-end="698"><strong>Статические элементы класса:</strong></p>
<ul>
<li class="has-line-data" data-line-start="699" data-line-end="704"><strong>Статические поля:</strong><br>
Это переменные, которые принадлежат классу, а не отдельным объектам.
<ul>
<li class="has-line-data" data-line-start="701" data-line-end="702">Имеют одно значение для всех объектов класса.</li>
<li class="has-line-data" data-line-start="702" data-line-end="704">Инициализируются вне класса (в глобальной области видимости).</li>
</ul>
</li>
</ul>
<p class="has-line-data" data-line-start="704" data-line-end="705"><strong>Пример статического поля:</strong></p>
<pre><code class="has-line-data" data-line-start="707" data-line-end="725" class="language-cpp"><span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-keyword">class</span> Counter {
<span class="hljs-keyword">public</span>:
    Counter() { ++count; }
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> count; }
<span class="hljs-keyword">private</span>:
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> count; <span class="hljs-comment">// объявление</span>
};

<span class="hljs-comment">// Определение статического поля</span>
<span class="hljs-keyword">int</span> Counter::count = <span class="hljs-number">0</span>;

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    Counter a, b, c;
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Number of objects: "</span> &lt;&lt; Counter::getCount() &lt;&lt; <span class="hljs-built_in">std</span>::endl;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<ul>
<li class="has-line-data" data-line-start="726" data-line-end="731"><strong>Статические методы:</strong><br>
Это методы, которые могут вызываться без создания объекта.
<ul>
<li class="has-line-data" data-line-start="728" data-line-end="729">Не имеют доступа к нестатическим членам класса.</li>
<li class="has-line-data" data-line-start="729" data-line-end="731">Используются для работы с общими данными класса или для предоставления вспомогательной функциональности.</li>
</ul>
</li>
</ul>
<p class="has-line-data" data-line-start="731" data-line-end="732"><strong>Пример статического метода:</strong></p>
<pre><code class="has-line-data" data-line-start="734" data-line-end="746" class="language-cpp"><span class="hljs-keyword">class</span> MyClass {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showMessage</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Static method called"</span> &lt;&lt; <span class="hljs-built_in">std</span>::endl;
    }
};

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    MyClass::showMessage();
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p class="has-line-data" data-line-start="747" data-line-end="748"><strong>Заключение:</strong></p>
<ul>
<li class="has-line-data" data-line-start="749" data-line-end="750">Конструкторы и деструкторы позволяют контролировать жизненный цикл объектов, автоматизируя начальную и завершающую настройку.</li>
<li class="has-line-data" data-line-start="750" data-line-end="751">Дружественные функции помогают организовывать доступ к закрытым данным, не нарушая инкапсуляцию.</li>
<li class="has-line-data" data-line-start="751" data-line-end="752">Статические поля и методы используются для хранения общих данных и предоставления функциональности, связанной с классом в целом, а не с конкретным экземпляром.</li>
</ul>
<p class="has-line-data" data-line-start="754" data-line-end="755"><strong>11. Основы механизма наследования классов.</strong></p>
<p class="has-line-data" data-line-start="756" data-line-end="758"><strong>Что такое наследование:</strong><br>
Наследование — это механизм объектно-ориентированного программирования, позволяющий создавать новый класс (производный), который заимствует свойства и методы существующего класса (базового).</p>
<ul>
<li class="has-line-data" data-line-start="759" data-line-end="760">Производный класс может добавлять новые члены или переопределять существующие.</li>
<li class="has-line-data" data-line-start="760" data-line-end="762">Наследование облегчает повторное использование кода и позволяет создавать иерархические структуры классов.</li>
</ul>
<p class="has-line-data" data-line-start="762" data-line-end="763"><strong>Базовый и производный классы:</strong></p>
<ul>
<li class="has-line-data" data-line-start="764" data-line-end="765"><strong>Базовый класс</strong> — это уже существующий класс, члены которого будут унаследованы.</li>
<li class="has-line-data" data-line-start="765" data-line-end="767"><strong>Производный класс</strong> — это новый класс, который наследует члены базового класса.</li>
</ul>
<p class="has-line-data" data-line-start="767" data-line-end="768"><strong>Пример:</strong></p>
<pre><code class="has-line-data" data-line-start="770" data-line-end="807" class="language-cpp"><span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>

<span class="hljs-comment">// Базовый класс</span>
<span class="hljs-keyword">class</span> Animal {
<span class="hljs-keyword">public</span>:
    Animal(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; name) : name(name) {}

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="hljs-string">" says: I am an animal!"</span> &lt;&lt; <span class="hljs-built_in">std</span>::endl;
    }

<span class="hljs-keyword">protected</span>:
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> name;
};

<span class="hljs-comment">// Производный класс</span>
<span class="hljs-keyword">class</span> Dog : <span class="hljs-keyword">public</span> Animal {
<span class="hljs-keyword">public</span>:
    Dog(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; name) : Animal(name) {}

    <span class="hljs-comment">// Переопределение метода</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="hljs-string">" says: Woof!"</span> &lt;&lt; <span class="hljs-built_in">std</span>::endl;
    }
};

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-function">Animal <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-string">"Generic Animal"</span>)</span></span>;
    <span class="hljs-function">Dog <span class="hljs-title">d</span><span class="hljs-params">(<span class="hljs-string">"Rex"</span>)</span></span>;

    a.speak();
    d.speak();

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p class="has-line-data" data-line-start="808" data-line-end="809"><strong>Ключевые слова для наследования:</strong></p>
<ul>
<li class="has-line-data" data-line-start="810" data-line-end="815">
<p class="has-line-data" data-line-start="810" data-line-end="814"><strong><code>public</code> наследование:</strong><br>
Все <code>public</code> члены базового класса становятся <code>public</code> в производном.<br>
Все <code>protected</code> члены остаются <code>protected</code>.<br>
<code>private</code> члены недоступны напрямую, но доступны через методы базового класса.</p>
</li>
<li class="has-line-data" data-line-start="815" data-line-end="818">
<p class="has-line-data" data-line-start="815" data-line-end="817"><strong><code>protected</code> наследование:</strong><br>
Все <code>public</code> и <code>protected</code> члены базового класса становятся <code>protected</code> в производном.</p>
</li>
<li class="has-line-data" data-line-start="818" data-line-end="820">
<p class="has-line-data" data-line-start="818" data-line-end="820"><strong><code>private</code> наследование:</strong><br>
Все <code>public</code> и <code>protected</code> члены базового класса становятся <code>private</code> в производном.</p>
</li>
</ul>
<p class="has-line-data" data-line-start="822" data-line-end="823"><strong>Пример разных типов наследования:</strong></p>
<pre><code class="has-line-data" data-line-start="825" data-line-end="850" class="language-cpp"><span class="hljs-keyword">class</span> Base {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">showPublic</span><span class="hljs-params">()</span> </span>{ <span class="hljs-comment">/* ... */</span> }
<span class="hljs-keyword">protected</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">showProtected</span><span class="hljs-params">()</span> </span>{ <span class="hljs-comment">/* ... */</span> }
<span class="hljs-keyword">private</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">showPrivate</span><span class="hljs-params">()</span> </span>{ <span class="hljs-comment">/* ... */</span> }
};

<span class="hljs-keyword">class</span> DerivedPublic : <span class="hljs-keyword">public</span> Base {
    <span class="hljs-comment">// showPublic() - доступен как public</span>
    <span class="hljs-comment">// showProtected() - доступен как protected</span>
    <span class="hljs-comment">// showPrivate() - недоступен</span>
};

<span class="hljs-keyword">class</span> DerivedProtected : <span class="hljs-keyword">protected</span> Base {
    <span class="hljs-comment">// showPublic() - доступен как protected</span>
    <span class="hljs-comment">// showProtected() - доступен как protected</span>
};

<span class="hljs-keyword">class</span> DerivedPrivate : <span class="hljs-keyword">private</span> Base {
    <span class="hljs-comment">// showPublic() - доступен как private</span>
    <span class="hljs-comment">// showProtected() - доступен как private</span>
};
</code></pre>
<p class="has-line-data" data-line-start="851" data-line-end="852"><strong>Роль конструктора и деструктора в наследовании:</strong></p>
<ul>
<li class="has-line-data" data-line-start="853" data-line-end="854"><strong>Конструктор базового класса</strong> обычно вызывается автоматически перед конструктором производного.</li>
<li class="has-line-data" data-line-start="854" data-line-end="856"><strong>Деструктор базового класса</strong> вызывается автоматически после деструктора производного.</li>
</ul>
<p class="has-line-data" data-line-start="856" data-line-end="857"><strong>Пример вызова конструктора базового класса:</strong></p>
<pre><code class="has-line-data" data-line-start="859" data-line-end="881" class="language-cpp"><span class="hljs-keyword">class</span> Animal {
<span class="hljs-keyword">public</span>:
    Animal(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; name) : name(name) {
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Animal created: "</span> &lt;&lt; name &lt;&lt; <span class="hljs-built_in">std</span>::endl;
    }
    ~Animal() {
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Animal destroyed: "</span> &lt;&lt; name &lt;&lt; <span class="hljs-built_in">std</span>::endl;
    }
<span class="hljs-keyword">private</span>:
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> name;
};

<span class="hljs-keyword">class</span> Dog : <span class="hljs-keyword">public</span> Animal {
<span class="hljs-keyword">public</span>:
    Dog(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; name) : Animal(name) {
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Dog created"</span> &lt;&lt; <span class="hljs-built_in">std</span>::endl;
    }
    ~Dog() {
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Dog destroyed"</span> &lt;&lt; <span class="hljs-built_in">std</span>::endl;
    }
};
</code></pre>
<p class="has-line-data" data-line-start="882" data-line-end="883"><strong>Заключение:</strong> Наследование — ключевая концепция ООП, которая упрощает повторное использование кода и создание иерархических структур классов. Оно позволяет проектировать системы так, чтобы базовые классы предоставляли общие возможности, а производные — добавляли специфичную функциональность.</p>
<p class="has-line-data" data-line-start="885" data-line-end="886"><strong>12. Виртуальные функции и классы. Абстрактные классы.</strong></p>
<p class="has-line-data" data-line-start="887" data-line-end="888"><strong>Виртуальные функции:</strong></p>
<ul>
<li class="has-line-data" data-line-start="889" data-line-end="890">Виртуальная функция — это функция-член, объявленная с ключевым словом <code>virtual</code> в базовом классе.</li>
<li class="has-line-data" data-line-start="890" data-line-end="891">Она позволяет переопределять поведение функции в производных классах, обеспечивая динамическое (или позднее) связывание.</li>
<li class="has-line-data" data-line-start="891" data-line-end="893">Вызов виртуальной функции через указатель или ссылку на базовый класс будет использовать реализацию производного класса, если такая существует.</li>
</ul>
<p class="has-line-data" data-line-start="893" data-line-end="894"><strong>Пример использования виртуальных функций:</strong></p>
<pre><code class="has-line-data" data-line-start="896" data-line-end="919" class="language-cpp"><span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>

<span class="hljs-keyword">class</span> Base {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Base class implementation"</span> &lt;&lt; <span class="hljs-built_in">std</span>::endl;
    }
};

<span class="hljs-keyword">class</span> Derived : <span class="hljs-keyword">public</span> Base {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> override </span>{
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Derived class implementation"</span> &lt;&lt; <span class="hljs-built_in">std</span>::endl;
    }
};

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    Base* basePtr = <span class="hljs-keyword">new</span> Derived();
    basePtr-&gt;show();  <span class="hljs-comment">// Вызов show() из Derived</span>
    <span class="hljs-keyword">delete</span> basePtr;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p class="has-line-data" data-line-start="920" data-line-end="921"><strong>Особенности:</strong></p>
<ul>
<li class="has-line-data" data-line-start="922" data-line-end="923">Если функция не объявлена виртуальной, то её вызов определяется во время компиляции (раннее связывание).</li>
<li class="has-line-data" data-line-start="923" data-line-end="925">Виртуальные функции дают гибкость в реализации полиморфизма: при использовании базового класса программа может работать с производными классами без изменения базового кода.</li>
</ul>
<hr>
<p class="has-line-data" data-line-start="927" data-line-end="928"><strong>Абстрактные классы:</strong></p>
<ul>
<li class="has-line-data" data-line-start="929" data-line-end="930">Абстрактный класс — это класс, содержащий хотя бы одну чисто виртуальную функцию.</li>
<li class="has-line-data" data-line-start="930" data-line-end="931">Чисто виртуальная функция объявляется с помощью <code>= 0</code> в её прототипе.</li>
<li class="has-line-data" data-line-start="931" data-line-end="932">Нельзя создавать объекты абстрактного класса.</li>
<li class="has-line-data" data-line-start="932" data-line-end="934">Абстрактные классы служат базой для наследования, задавая интерфейс, который производные классы должны реализовать.</li>
</ul>
<p class="has-line-data" data-line-start="934" data-line-end="935"><strong>Пример абстрактного класса:</strong></p>
<pre><code class="has-line-data" data-line-start="937" data-line-end="968" class="language-cpp"><span class="hljs-keyword">class</span> Shape {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">// чисто виртуальная функция</span>
    <span class="hljs-keyword">virtual</span> ~Shape() {}
};

<span class="hljs-keyword">class</span> Circle : <span class="hljs-keyword">public</span> Shape {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> override </span>{
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Drawing a circle"</span> &lt;&lt; <span class="hljs-built_in">std</span>::endl;
    }
};

<span class="hljs-keyword">class</span> Rectangle : <span class="hljs-keyword">public</span> Shape {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> override </span>{
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Drawing a rectangle"</span> &lt;&lt; <span class="hljs-built_in">std</span>::endl;
    }
};

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    Shape* shapes[] = {<span class="hljs-keyword">new</span> Circle(), <span class="hljs-keyword">new</span> Rectangle()};
    <span class="hljs-keyword">for</span> (Shape* shape : shapes) {
        shape-&gt;draw();
    }
    <span class="hljs-keyword">for</span> (Shape* shape : shapes) {
        <span class="hljs-keyword">delete</span> shape;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p class="has-line-data" data-line-start="969" data-line-end="970"><strong>Заключение:</strong></p>
<ul>
<li class="has-line-data" data-line-start="971" data-line-end="972"><strong>Виртуальные функции</strong> обеспечивают динамическое разрешение вызовов функций, поддерживая полиморфизм.</li>
<li class="has-line-data" data-line-start="972" data-line-end="973"><strong>Абстрактные классы</strong> задают основу для иерархии наследования, определяя интерфейс, который обязаны реализовать производные классы. Вместе они формируют фундамент гибкого и модульного объектно-ориентированного проектирования.</li>
</ul>
<p class="has-line-data" data-line-start="975" data-line-end="976"><strong>13. Шаблоны классов.</strong></p>
<p class="has-line-data" data-line-start="977" data-line-end="979"><strong>Что такое шаблоны классов:</strong><br>
Шаблоны классов в C++ позволяют создавать обобщённые (универсальные) классы, которые работают с разными типами данных.</p>
<ul>
<li class="has-line-data" data-line-start="980" data-line-end="981">Шаблон класса — это “форма”, из которой можно создать множество конкретных классов, указав тип данных при инстанцировании.</li>
<li class="has-line-data" data-line-start="981" data-line-end="983">Это снижает дублирование кода: вместо создания отдельных классов для каждого типа данных, достаточно один раз описать шаблон.</li>
</ul>
<p class="has-line-data" data-line-start="983" data-line-end="985"><strong>Объявление шаблона класса:</strong><br>
Для объявления шаблона класса используется ключевое слово <code>template</code> и параметр шаблона в угловых скобках <code>&lt;&gt;</code>. Параметром может быть тип (<code>typename</code> или <code>class</code>) или значение (например, целочисленный размер массива).</p>
<p class="has-line-data" data-line-start="986" data-line-end="987"><strong>Пример:</strong></p>
<pre><code class="has-line-data" data-line-start="989" data-line-end="1013" class="language-cpp"><span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>

<span class="hljs-comment">// Определение шаблона класса</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">class</span> Box {
<span class="hljs-keyword">public</span>:
    Box(T value) : data(value) {}
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Data: "</span> &lt;&lt; data &lt;&lt; <span class="hljs-built_in">std</span>::endl;
    }
<span class="hljs-keyword">private</span>:
    T data;
};

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    Box&lt;<span class="hljs-keyword">int</span>&gt; intBox(<span class="hljs-number">123</span>);        <span class="hljs-comment">// Использование шаблона с типом int</span>
    Box&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt; strBox(<span class="hljs-string">"Hello, World!"</span>); <span class="hljs-comment">// Использование шаблона с типом std::string</span>

    intBox.display();
    strBox.display();

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p class="has-line-data" data-line-start="1014" data-line-end="1015"><strong>Особенности шаблонов классов:</strong></p>
<ul>
<li class="has-line-data" data-line-start="1016" data-line-end="1017"><strong>Гибкость:</strong> можно использовать один и тот же код для разных типов данных.</li>
<li class="has-line-data" data-line-start="1017" data-line-end="1018"><strong>Типы:</strong> вместо фиксированного типа данных (например, <code>int</code> или <code>float</code>), шаблон принимает параметр <code>T</code>, который заменяется на конкретный тип во время компиляции.</li>
<li class="has-line-data" data-line-start="1018" data-line-end="1020"><strong>Параметры:</strong> параметры шаблона могут быть не только типами, но и значениями (например, целые числа для размеров массивов).</li>
</ul>
<p class="has-line-data" data-line-start="1020" data-line-end="1021"><strong>Пример шаблона с несколькими параметрами:</strong></p>
<pre><code class="has-line-data" data-line-start="1023" data-line-end="1041" class="language-cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;
<span class="hljs-keyword">class</span> Pair {
<span class="hljs-keyword">public</span>:
    Pair(T1 first, T2 second) : first(first), second(second) {}
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"First: "</span> &lt;&lt; first &lt;&lt; <span class="hljs-string">", Second: "</span> &lt;&lt; second &lt;&lt; <span class="hljs-built_in">std</span>::endl;
    }
<span class="hljs-keyword">private</span>:
    T1 first;
    T2 second;
};

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    Pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span>&gt; p(<span class="hljs-number">42</span>, <span class="hljs-number">3.14</span>);
    p.display();
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p class="has-line-data" data-line-start="1042" data-line-end="1043"><strong>Инстанцирование шаблонов:</strong></p>
<ul>
<li class="has-line-data" data-line-start="1044" data-line-end="1045">Когда вы используете шаблон класса с конкретным типом, компилятор генерирует специализированный класс для этого типа.</li>
<li class="has-line-data" data-line-start="1045" data-line-end="1047">Например, при создании <code>Box&lt;int&gt;</code>, компилятор создаст класс <code>Box</code> с заменой всех <code>T</code> на <code>int</code>.</li>
</ul>
<p class="has-line-data" data-line-start="1047" data-line-end="1049"><strong>Специализация шаблонов:</strong><br>
Иногда может потребоваться предоставить особую реализацию шаблона для конкретного типа. Это называется <strong>полной специализацией</strong>.</p>
<pre><code class="has-line-data" data-line-start="1051" data-line-end="1062" class="language-cpp"><span class="hljs-keyword">template</span> &lt;&gt;
<span class="hljs-keyword">class</span> Box&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt; {
<span class="hljs-keyword">public</span>:
    Box(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> value) : data(value) {}
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"String data: "</span> &lt;&lt; data &lt;&lt; <span class="hljs-built_in">std</span>::endl;
    }
<span class="hljs-keyword">private</span>:
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> data;
};
</code></pre>
<p class="has-line-data" data-line-start="1063" data-line-end="1065"><strong>Шаблоны и стандартная библиотека:</strong><br>
Шаблоны лежат в основе многих компонентов стандартной библиотеки C++ (STL), таких как <code>std::vector</code>, <code>std::map</code>, <code>std::set</code> и т.д. Эти компоненты были созданы именно как шаблоны классов, что обеспечивает их универсальность и удобство использования.</p>
<p class="has-line-data" data-line-start="1066" data-line-end="1068"><strong>Заключение:</strong><br>
Шаблоны классов — мощный инструмент, позволяющий писать универсальный, компактный и переиспользуемый код. Они упрощают разработку, уменьшают дублирование кода и служат основой многих стандартных контейнеров и алгоритмов в C++.</p>
<p class="has-line-data" data-line-start="1070" data-line-end="1071"><strong>14. Современные библиотеки языка С++.</strong></p>
<p class="has-line-data" data-line-start="1072" data-line-end="1073">Современные версии C++ (начиная с C++11 и далее) значительно расширили стандартную библиотеку, добавив множество инструментов, которые делают программирование более удобным, безопасным и эффективным. Вот некоторые из ключевых категорий и новшеств в стандартной библиотеке:</p>
<hr>
<p class="has-line-data" data-line-start="1076" data-line-end="1077"><strong>Умные указатели и управление памятью:</strong></p>
<ul>
<li class="has-line-data" data-line-start="1078" data-line-end="1083"><strong><code>&lt;memory&gt;</code>:</strong>
<ul>
<li class="has-line-data" data-line-start="1079" data-line-end="1080"><code>std::unique_ptr</code>: предоставляет эксклюзивное владение объектом.</li>
<li class="has-line-data" data-line-start="1080" data-line-end="1081"><code>std::shared_ptr</code>: позволяет нескольким объектам совместно владеть ресурсом, освобождая память, когда она больше не используется.</li>
<li class="has-line-data" data-line-start="1081" data-line-end="1083"><code>std::weak_ptr</code>: предотвращает циклические ссылки между <code>std::shared_ptr</code>.</li>
</ul>
</li>
</ul>
<p class="has-line-data" data-line-start="1083" data-line-end="1084">Пример использования <code>std::unique_ptr</code>:</p>
<pre><code class="has-line-data" data-line-start="1086" data-line-end="1096" class="language-cpp"><span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">std</span>::unique_ptr&lt;<span class="hljs-keyword">int</span>&gt; uptr(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">42</span>));
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Value: "</span> &lt;&lt; *uptr &lt;&lt; <span class="hljs-built_in">std</span>::endl;
    <span class="hljs-comment">// память освобождается автоматически при выходе из области видимости</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<hr>
<p class="has-line-data" data-line-start="1099" data-line-end="1100"><strong>Потоки и многопоточность:</strong></p>
<ul>
<li class="has-line-data" data-line-start="1101" data-line-end="1102"><strong><code>&lt;thread&gt;</code>:</strong> стандартные потоки.</li>
<li class="has-line-data" data-line-start="1102" data-line-end="1103"><strong><code>&lt;mutex&gt;</code> и <code>&lt;condition_variable&gt;</code>:</strong> синхронизация потоков.</li>
<li class="has-line-data" data-line-start="1103" data-line-end="1104"><strong><code>&lt;future&gt;</code> и <code>&lt;promise&gt;</code>:</strong> асинхронное выполнение и управление результатами.</li>
<li class="has-line-data" data-line-start="1104" data-line-end="1106"><strong><code>&lt;atomic&gt;</code>:</strong> атомарные операции и флаги для безопасной работы с данными из нескольких потоков.</li>
</ul>
<p class="has-line-data" data-line-start="1106" data-line-end="1107">Пример запуска потока:</p>
<pre><code class="has-line-data" data-line-start="1109" data-line-end="1122" class="language-cpp"><span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printMessage</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Hello from thread!"</span> &lt;&lt; <span class="hljs-built_in">std</span>::endl;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">std</span>::<span class="hljs-function">thread <span class="hljs-title">t</span><span class="hljs-params">(printMessage)</span></span>;
    t.join(); <span class="hljs-comment">// ожидаем завершения потока</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<hr>
<p class="has-line-data" data-line-start="1125" data-line-end="1126"><strong>Контейнеры и итераторы:</strong></p>
<ul>
<li class="has-line-data" data-line-start="1127" data-line-end="1130">
<p class="has-line-data" data-line-start="1127" data-line-end="1129"><strong>Улучшения стандартных контейнеров:</strong><br>
В дополнение к традиционным контейнерам, таким как <code>std::vector</code>, <code>std::list</code>, <code>std::map</code>, стандартная библиотека теперь включает <code>std::array</code> (статический массив фиксированного размера), а также более продвинутую поддержку операций с контейнерами, включая методы перемещения элементов.</p>
</li>
<li class="has-line-data" data-line-start="1130" data-line-end="1132">
<p class="has-line-data" data-line-start="1130" data-line-end="1132"><strong>Алгоритмы и сортировка:</strong><br>
Новые алгоритмы (например, параллельные алгоритмы из C++17) позволяют оптимизировать обработку данных, используя многопоточность.</p>
</li>
</ul>
<hr>
<p class="has-line-data" data-line-start="1136" data-line-end="1137"><strong>Работа со строками и текстом:</strong></p>
<ul>
<li class="has-line-data" data-line-start="1138" data-line-end="1139"><strong><code>&lt;string&gt;</code>:</strong> стандартная работа со строками.</li>
<li class="has-line-data" data-line-start="1139" data-line-end="1140"><strong><code>&lt;regex&gt;</code> (с C++11):</strong> поддержка регулярных выражений для поиска и замены текста.</li>
<li class="has-line-data" data-line-start="1140" data-line-end="1142"><strong><code>&lt;charconv&gt;</code> (с C++17):</strong> быстрые преобразования чисел в строки и обратно.</li>
</ul>
<p class="has-line-data" data-line-start="1142" data-line-end="1143">Пример использования регулярных выражений:</p>
<pre><code class="has-line-data" data-line-start="1145" data-line-end="1158" class="language-cpp"><span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;regex&gt;</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> s = <span class="hljs-string">"123-456-7890"</span>;
    <span class="hljs-built_in">std</span>::<span class="hljs-function">regex <span class="hljs-title">phone</span><span class="hljs-params">(<span class="hljs-string">"\\d{3}-\\d{3}-\\d{4}"</span>)</span></span>;
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">std</span>::regex_match(s, phone)) {
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Valid phone number!"</span> &lt;&lt; <span class="hljs-built_in">std</span>::endl;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<hr>
<p class="has-line-data" data-line-start="1161" data-line-end="1162"><strong>Новые типы времени и дат:</strong></p>
<ul>
<li class="has-line-data" data-line-start="1163" data-line-end="1164"><strong><code>&lt;chrono&gt;</code> (с C++11):</strong> удобная работа с временными интервалами, измерение времени выполнения.</li>
<li class="has-line-data" data-line-start="1164" data-line-end="1166"><strong><code>std::chrono::steady_clock</code>, <code>std::chrono::system_clock</code> и <code>std::chrono::high_resolution_clock</code>:</strong> позволяют измерять интервалы времени с разной степенью точности.</li>
</ul>
<p class="has-line-data" data-line-start="1166" data-line-end="1167">Пример:</p>
<pre><code class="has-line-data" data-line-start="1169" data-line-end="1185" class="language-cpp"><span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">auto</span> start = <span class="hljs-built_in">std</span>::chrono::high_resolution_clock::now();

    <span class="hljs-comment">// некоторая работа</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000000</span>; ++i);

    <span class="hljs-keyword">auto</span> end = <span class="hljs-built_in">std</span>::chrono::high_resolution_clock::now();
    <span class="hljs-built_in">std</span>::chrono::duration&lt;<span class="hljs-keyword">double</span>&gt; elapsed = end - start;

    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Elapsed time: "</span> &lt;&lt; elapsed.count() &lt;&lt; <span class="hljs-string">" seconds"</span> &lt;&lt; <span class="hljs-built_in">std</span>::endl;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<hr>
<p class="has-line-data" data-line-start="1188" data-line-end="1189"><strong>Новые элементы STL:</strong></p>
<ul>
<li class="has-line-data" data-line-start="1190" data-line-end="1191"><strong><code>&lt;tuple&gt;</code> (с C++11):</strong> позволяет группировать несколько значений разных типов.</li>
<li class="has-line-data" data-line-start="1191" data-line-end="1192"><strong><code>&lt;optional&gt;</code> (с C++17):</strong> возвращает значение, которое может быть отсутствующим.</li>
<li class="has-line-data" data-line-start="1192" data-line-end="1193"><strong><code>&lt;variant&gt;</code> (с C++17):</strong> позволяет хранить одно из нескольких типов значений.</li>
<li class="has-line-data" data-line-start="1193" data-line-end="1195"><strong><code>&lt;any&gt;</code> (с C++17):</strong> контейнер для значения любого типа.</li>
</ul>
<p class="has-line-data" data-line-start="1195" data-line-end="1196">Пример <code>std::tuple</code>:</p>
<pre><code class="has-line-data" data-line-start="1198" data-line-end="1207" class="language-cpp"><span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;tuple&gt;</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">std</span>::tuple&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>, <span class="hljs-keyword">double</span>&gt; t = <span class="hljs-built_in">std</span>::make_tuple(<span class="hljs-number">1</span>, <span class="hljs-string">"hello"</span>, <span class="hljs-number">3.14</span>);
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">std</span>::get&lt;<span class="hljs-number">1</span>&gt;(t) &lt;&lt; <span class="hljs-built_in">std</span>::endl; <span class="hljs-comment">// выводит "hello"</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<hr>
<p class="has-line-data" data-line-start="1210" data-line-end="1212"><strong>Заключение:</strong><br>
Современные библиотеки C++ значительно упрощают разработку, добавляя мощные и удобные инструменты для работы с памятью, многопоточностью, временем, текстом и структурами данных. Они позволяют писать более понятный, безопасный и производительный код, облегчая многие аспекты программирования.</p>
<p class="has-line-data" data-line-start="1214" data-line-end="1215"><strong>15. Библиотеки потоковых классов ввода-вывода.</strong></p>
<p class="has-line-data" data-line-start="1216" data-line-end="1217">C++ предоставляет мощные и удобные средства для работы с потоками ввода-вывода, реализованные через стандартные библиотеки, такие как <code>&lt;iostream&gt;</code> и <code>&lt;fstream&gt;</code>. Эти библиотеки поддерживают работу с консольным вводом-выводом, файлами и другими источниками данных, а также предоставляют широкие возможности форматирования, буферизации и обработки ошибок.</p>
<hr>
<p class="has-line-data" data-line-start="1220" data-line-end="1221"><strong>Классы потоков ввода-вывода:</strong></p>
<ol>
<li class="has-line-data" data-line-start="1222" data-line-end="1228">
<p class="has-line-data" data-line-start="1222" data-line-end="1224"><strong><code>std::istream</code> и <code>std::ostream</code>:</strong><br>
Базовые классы для работы с потоками ввода (<code>std::cin</code>) и вывода (<code>std::cout</code>).</p>
<ul>
<li class="has-line-data" data-line-start="1225" data-line-end="1226"><code>std::cin</code> — стандартный поток ввода из консоли.</li>
<li class="has-line-data" data-line-start="1226" data-line-end="1227"><code>std::cout</code> — стандартный поток вывода в консоль.</li>
<li class="has-line-data" data-line-start="1227" data-line-end="1228"><code>std::cerr</code> и <code>std::clog</code> — потоки вывода для ошибок и диагностических сообщений.</li>
</ul>
</li>
<li class="has-line-data" data-line-start="1228" data-line-end="1233">
<p class="has-line-data" data-line-start="1228" data-line-end="1230"><strong><code>std::ifstream</code> и <code>std::ofstream</code>:</strong><br>
Классы для работы с файлами на чтение (<code>std::ifstream</code>) и запись (<code>std::ofstream</code>).</p>
<ul>
<li class="has-line-data" data-line-start="1231" data-line-end="1232">Могут открывать файлы, читать данные построчно, побайтно или с использованием форматированных операций.</li>
<li class="has-line-data" data-line-start="1232" data-line-end="1233">Поддерживают режимы открытия, такие как <code>std::ios::in</code>, <code>std::ios::out</code>, <code>std::ios::binary</code> и т.д.</li>
</ul>
</li>
<li class="has-line-data" data-line-start="1233" data-line-end="1239">
<p class="has-line-data" data-line-start="1233" data-line-end="1235"><strong><code>std::fstream</code>:</strong><br>
Универсальный класс для работы с файлами на чтение и запись одновременно.</p>
<ul>
<li class="has-line-data" data-line-start="1236" data-line-end="1237">Позволяет открывать файл как для ввода, так и для вывода данных.</li>
<li class="has-line-data" data-line-start="1237" data-line-end="1239">Удобен для случаев, когда нужно одновременно читать из файла и записывать в него.</li>
</ul>
</li>
</ol>
<hr>
<p class="has-line-data" data-line-start="1241" data-line-end="1243"><strong>Форматирование вывода:</strong><br>
Потоки ввода-вывода в C++ поддерживают настройку формата через манипуляторы (<code>std::setw</code>, <code>std::setprecision</code>, <code>std::fixed</code>, <code>std::scientific</code>):</p>
<ul>
<li class="has-line-data" data-line-start="1244" data-line-end="1245"><strong><code>std::setw(n)</code></strong> — ширина поля для вывода.</li>
<li class="has-line-data" data-line-start="1245" data-line-end="1246"><strong><code>std::setprecision(p)</code></strong> — количество знаков после запятой для чисел с плавающей точкой.</li>
<li class="has-line-data" data-line-start="1246" data-line-end="1248"><strong><code>std::fixed</code> и <code>std::scientific</code></strong> — фиксированное и экспоненциальное представление чисел.</li>
</ul>
<p class="has-line-data" data-line-start="1248" data-line-end="1249">Пример форматирования:</p>
<pre><code class="has-line-data" data-line-start="1251" data-line-end="1262" class="language-cpp"><span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iomanip&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">double</span> pi = <span class="hljs-number">3.14159265359</span>;
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Default: "</span> &lt;&lt; pi &lt;&lt; <span class="hljs-string">'\n'</span>;
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Fixed: "</span> &lt;&lt; <span class="hljs-built_in">std</span>::fixed &lt;&lt; <span class="hljs-built_in">std</span>::setprecision(<span class="hljs-number">2</span>) &lt;&lt; pi &lt;&lt; <span class="hljs-string">'\n'</span>;
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Scientific: "</span> &lt;&lt; <span class="hljs-built_in">std</span>::scientific &lt;&lt; pi &lt;&lt; <span class="hljs-string">'\n'</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<hr>
<p class="has-line-data" data-line-start="1265" data-line-end="1267"><strong>Обработка ошибок:</strong><br>
Потоки ввода-вывода имеют встроенные механизмы проверки состояния.</p>
<ul>
<li class="has-line-data" data-line-start="1268" data-line-end="1269"><strong><code>std::ios::fail()</code></strong> — проверяет, была ли ошибка при последней операции.</li>
<li class="has-line-data" data-line-start="1269" data-line-end="1270"><strong><code>std::ios::eof()</code></strong> — проверяет достижение конца потока.</li>
<li class="has-line-data" data-line-start="1270" data-line-end="1271"><strong><code>std::ios::clear()</code></strong> — сбрасывает состояние потока.</li>
<li class="has-line-data" data-line-start="1271" data-line-end="1273"><strong><code>exceptions()</code></strong> — позволяет настроить бросание исключений при ошибках.</li>
</ul>
<p class="has-line-data" data-line-start="1273" data-line-end="1274">Пример проверки состояния:</p>
<pre><code class="has-line-data" data-line-start="1276" data-line-end="1287" class="language-cpp"><span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">std</span>::<span class="hljs-function">ifstream <span class="hljs-title">file</span><span class="hljs-params">(<span class="hljs-string">"nonexistent.txt"</span>)</span></span>;
    <span class="hljs-keyword">if</span> (!file) {
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"Error: could not open file.\n"</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<hr>
<p class="has-line-data" data-line-start="1290" data-line-end="1292"><strong>Расширение стандартных потоков:</strong><br>
Потоки в C++ можно перегружать и адаптировать для работы с пользовательскими источниками данных.</p>
<ul>
<li class="has-line-data" data-line-start="1293" data-line-end="1294">С помощью перегрузки операторов <code>&lt;&lt;</code> и <code>&gt;&gt;</code> можно легко поддерживать ввод-вывод для пользовательских классов.</li>
<li class="has-line-data" data-line-start="1294" data-line-end="1296">Стандартная библиотека также предоставляет инструменты для работы с строковыми потоками (<code>std::istringstream</code>, <code>std::ostringstream</code>, <code>std::stringstream</code>), что позволяет выполнять форматированный ввод-вывод из строк.</li>
</ul>
<p class="has-line-data" data-line-start="1296" data-line-end="1297">Пример работы с <code>std::ostringstream</code>:</p>
<pre><code class="has-line-data" data-line-start="1299" data-line-end="1310" class="language-cpp"><span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sstream&gt;</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">ostringstream</span> oss;
    oss &lt;&lt; <span class="hljs-string">"Hello, "</span> &lt;&lt; <span class="hljs-number">42</span> &lt;&lt; <span class="hljs-string">'!'</span>;
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> result = oss.str();
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; result &lt;&lt; <span class="hljs-built_in">std</span>::endl;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<hr>
<p class="has-line-data" data-line-start="1313" data-line-end="1315"><strong>Заключение:</strong><br>
Библиотеки потоковых классов C++ — это мощный инструмент для работы с данными. Они предоставляют стандартизованный, удобный и надёжный способ работы с консолью, файлами и другими источниками данных, поддерживая гибкое форматирование, обработку ошибок и расширение возможностей через пользовательские манипуляторы и перегрузки операторов.</p>
<p class="has-line-data" data-line-start="1317" data-line-end="1318"><strong>16. Особенности ввода-вывода в файл при использовании потоковых классов.</strong></p>
<p class="has-line-data" data-line-start="1319" data-line-end="1320">C++ предоставляет удобный и мощный интерфейс для работы с файлами через потоковые классы. Ключевыми особенностями являются понятный синтаксис, поддержка различных режимов работы с файлами и встроенные механизмы обработки ошибок. Основные классы для работы с файлами включают <code>std::ifstream</code>, <code>std::ofstream</code> и <code>std::fstream</code>.</p>
<hr>
<p class="has-line-data" data-line-start="1323" data-line-end="1324"><strong>Чтение из файла с использованием <code>std::ifstream</code>:</strong></p>
<ul>
<li class="has-line-data" data-line-start="1325" data-line-end="1326">Класс <code>std::ifstream</code> предназначен для чтения данных из файлов.</li>
<li class="has-line-data" data-line-start="1326" data-line-end="1327">Открытие файла можно выполнить прямо в конструкторе или вызвав метод <code>.open()</code>.</li>
<li class="has-line-data" data-line-start="1327" data-line-end="1329">Чтение можно организовать построчно (<code>std::getline()</code>), побайтово или в формате данных (<code>&gt;&gt;</code>).</li>
</ul>
<p class="has-line-data" data-line-start="1329" data-line-end="1330">Пример:</p>
<pre><code class="has-line-data" data-line-start="1332" data-line-end="1352" class="language-cpp"><span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">std</span>::<span class="hljs-function">ifstream <span class="hljs-title">inputFile</span><span class="hljs-params">(<span class="hljs-string">"example.txt"</span>)</span></span>;
    <span class="hljs-keyword">if</span> (!inputFile) {
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"Could not open the file for reading.\n"</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    }

    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> line;
    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">std</span>::getline(inputFile, line)) {
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; line &lt;&lt; <span class="hljs-string">'\n'</span>;
    }
    inputFile.close();

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<hr>
<p class="has-line-data" data-line-start="1355" data-line-end="1356"><strong>Запись в файл с использованием <code>std::ofstream</code>:</strong></p>
<ul>
<li class="has-line-data" data-line-start="1357" data-line-end="1358">Класс <code>std::ofstream</code> используется для записи данных в файл.</li>
<li class="has-line-data" data-line-start="1358" data-line-end="1359">Как и <code>std::ifstream</code>, файл можно открыть при создании объекта или позднее с помощью <code>.open()</code>.</li>
<li class="has-line-data" data-line-start="1359" data-line-end="1361">Можно использовать оператор <code>&lt;&lt;</code> для записи данных.</li>
</ul>
<p class="has-line-data" data-line-start="1361" data-line-end="1362">Пример:</p>
<pre><code class="has-line-data" data-line-start="1364" data-line-end="1381" class="language-cpp"><span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">std</span>::<span class="hljs-function">ofstream <span class="hljs-title">outputFile</span><span class="hljs-params">(<span class="hljs-string">"output.txt"</span>)</span></span>;
    <span class="hljs-keyword">if</span> (!outputFile) {
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"Could not open the file for writing.\n"</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    }

    outputFile &lt;&lt; <span class="hljs-string">"Hello, file!"</span> &lt;&lt; <span class="hljs-built_in">std</span>::endl;
    outputFile &lt;&lt; <span class="hljs-number">42</span> &lt;&lt; <span class="hljs-string">" is the answer."</span> &lt;&lt; <span class="hljs-built_in">std</span>::endl;
    outputFile.close();

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<hr>
<p class="has-line-data" data-line-start="1384" data-line-end="1385"><strong>Чтение и запись в одном потоке с использованием <code>std::fstream</code>:</strong></p>
<ul>
<li class="has-line-data" data-line-start="1386" data-line-end="1387">Класс <code>std::fstream</code> позволяет одновременно читать и записывать данные.</li>
<li class="has-line-data" data-line-start="1387" data-line-end="1388">Это удобно, если требуется модифицировать файл или работать с ним в режиме чтения-записи.</li>
<li class="has-line-data" data-line-start="1388" data-line-end="1390">Файл открывается с соответствующими флагами: <code>std::ios::in</code> (чтение), <code>std::ios::out</code> (запись), <code>std::ios::app</code> (добавление), <code>std::ios::trunc</code> (обрезка) и т.д.</li>
</ul>
<p class="has-line-data" data-line-start="1390" data-line-end="1391">Пример:</p>
<pre><code class="has-line-data" data-line-start="1393" data-line-end="1422" class="language-cpp"><span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// Открытие файла в режиме чтения и записи</span>
    <span class="hljs-built_in">std</span>::<span class="hljs-function">fstream <span class="hljs-title">file</span><span class="hljs-params">(<span class="hljs-string">"data.txt"</span>, <span class="hljs-built_in">std</span>::ios::in | <span class="hljs-built_in">std</span>::ios::out | <span class="hljs-built_in">std</span>::ios::app)</span></span>;
    <span class="hljs-keyword">if</span> (!file) {
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"Could not open the file.\n"</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    }

    <span class="hljs-comment">// Запись в конец файла</span>
    file &lt;&lt; <span class="hljs-string">"New line added"</span> &lt;&lt; <span class="hljs-built_in">std</span>::endl;

    <span class="hljs-comment">// Перемещение указателя в начало файла</span>
    file.seekg(<span class="hljs-number">0</span>, <span class="hljs-built_in">std</span>::ios::beg);

    <span class="hljs-comment">// Чтение из файла</span>
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> line;
    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">std</span>::getline(file, line)) {
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; line &lt;&lt; <span class="hljs-string">'\n'</span>;
    }

    file.close();

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<hr>
<p class="has-line-data" data-line-start="1425" data-line-end="1426"><strong>Обработка ошибок:</strong></p>
<ul>
<li class="has-line-data" data-line-start="1427" data-line-end="1433">Все потоковые классы наследуются от <code>std::ios</code>, который предоставляет методы проверки состояния:
<ul>
<li class="has-line-data" data-line-start="1428" data-line-end="1429"><code>eof()</code>: возвращает <code>true</code>, если достигнут конец файла.</li>
<li class="has-line-data" data-line-start="1429" data-line-end="1430"><code>fail()</code>: возвращает <code>true</code>, если произошла ошибка.</li>
<li class="has-line-data" data-line-start="1430" data-line-end="1431"><code>bad()</code>: возвращает <code>true</code>, если возникла серьёзная ошибка.</li>
<li class="has-line-data" data-line-start="1431" data-line-end="1433"><code>good()</code>: возвращает <code>true</code>, если поток находится в хорошем состоянии.</li>
</ul>
</li>
</ul>
<p class="has-line-data" data-line-start="1433" data-line-end="1434">Пример:</p>
<pre><code class="has-line-data" data-line-start="1436" data-line-end="1441" class="language-cpp"><span class="hljs-built_in">std</span>::<span class="hljs-function">ifstream <span class="hljs-title">file</span><span class="hljs-params">(<span class="hljs-string">"nonexistent.txt"</span>)</span></span>;
<span class="hljs-keyword">if</span> (!file.good()) {
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"Error: could not open file."</span> &lt;&lt; <span class="hljs-built_in">std</span>::endl;
}
</code></pre>
<hr>
<p class="has-line-data" data-line-start="1444" data-line-end="1446"><strong>Заключение:</strong><br>
Стандартные потоковые классы C++ предоставляют удобный, безопасный и интуитивно понятный интерфейс для работы с файлами. Они позволяют не только читать и записывать данные, но и обеспечивают обработку ошибок, манипуляции с указателями и гибкость в настройке режимов доступа.</p>
<p class="has-line-data" data-line-start="1448" data-line-end="1449"><strong>17. Библиотека шаблонов STL. Общее описание. Контейнеры, итераторы, алгоритмы.</strong></p>
<p class="has-line-data" data-line-start="1450" data-line-end="1452"><strong>Общее описание STL:</strong><br>
STL (Standard Template Library) — это часть стандартной библиотеки C++, предоставляющая набор готовых компонентов для работы с данными. STL состоит из трёх основных элементов: контейнеров, итераторов и алгоритмов. Вместе они обеспечивают высокоуровневые и эффективные инструменты для организации, хранения и обработки данных.</p>
<hr>
<p class="has-line-data" data-line-start="1455" data-line-end="1457"><strong>Контейнеры:</strong><br>
Контейнеры — это классы, которые служат для хранения множества объектов определённого типа. STL предлагает несколько видов контейнеров, которые подходят для различных задач:</p>
<ol>
<li class="has-line-data" data-line-start="1458" data-line-end="1464">
<p class="has-line-data" data-line-start="1458" data-line-end="1459"><strong>Последовательные контейнеры:</strong></p>
<ul>
<li class="has-line-data" data-line-start="1460" data-line-end="1461"><code>std::vector</code> — динамический массив.</li>
<li class="has-line-data" data-line-start="1461" data-line-end="1462"><code>std::deque</code> — двухсторонняя очередь.</li>
<li class="has-line-data" data-line-start="1462" data-line-end="1463"><code>std::list</code> — двусвязный список.</li>
<li class="has-line-data" data-line-start="1463" data-line-end="1464"><code>std::array</code> — статический массив фиксированного размера (добавлен в C++11).</li>
</ul>
</li>
<li class="has-line-data" data-line-start="1464" data-line-end="1470">
<p class="has-line-data" data-line-start="1464" data-line-end="1465"><strong>Ассоциативные контейнеры:</strong></p>
<ul>
<li class="has-line-data" data-line-start="1466" data-line-end="1467"><code>std::set</code> — множество уникальных элементов.</li>
<li class="has-line-data" data-line-start="1467" data-line-end="1468"><code>std::multiset</code> — множество, допускающее дублирование.</li>
<li class="has-line-data" data-line-start="1468" data-line-end="1469"><code>std::map</code> — коллекция пар «ключ-значение», где ключи уникальны.</li>
<li class="has-line-data" data-line-start="1469" data-line-end="1470"><code>std::multimap</code> — как <code>std::map</code>, но допускает дублирование ключей.</li>
</ul>
</li>
<li class="has-line-data" data-line-start="1470" data-line-end="1476">
<p class="has-line-data" data-line-start="1470" data-line-end="1471"><strong>Контейнеры адаптеры:</strong></p>
<ul>
<li class="has-line-data" data-line-start="1472" data-line-end="1473"><code>std::stack</code> — адаптер для работы как со стеком.</li>
<li class="has-line-data" data-line-start="1473" data-line-end="1474"><code>std::queue</code> — адаптер для очереди.</li>
<li class="has-line-data" data-line-start="1474" data-line-end="1476"><code>std::priority_queue</code> — очередь с приоритетом.</li>
</ul>
</li>
</ol>
<p class="has-line-data" data-line-start="1476" data-line-end="1477"><strong>Пример использования контейнера:</strong></p>
<pre><code class="has-line-data" data-line-start="1479" data-line-end="1490" class="language-cpp"><span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; numbers = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>};
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> n : numbers) {
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="hljs-string">" "</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<hr>
<p class="has-line-data" data-line-start="1493" data-line-end="1495"><strong>Итераторы:</strong><br>
Итераторы — это объекты, которые позволяют проходить по элементам контейнера. Они предоставляют интерфейс, схожий с указателями, для доступа к элементам.</p>
<ul>
<li class="has-line-data" data-line-start="1496" data-line-end="1501"><strong>Виды итераторов:</strong>
<ul>
<li class="has-line-data" data-line-start="1497" data-line-end="1498"><code>begin()</code> и <code>end()</code> — возвращают итераторы на начало и конец контейнера.</li>
<li class="has-line-data" data-line-start="1498" data-line-end="1499"><code>rbegin()</code> и <code>rend()</code> — обратные итераторы.</li>
<li class="has-line-data" data-line-start="1499" data-line-end="1501"><code>cbegin()</code> и <code>cend()</code> — константные итераторы (добавлены в C++11).</li>
</ul>
</li>
</ul>
<p class="has-line-data" data-line-start="1501" data-line-end="1502"><strong>Пример использования итераторов:</strong></p>
<pre><code class="has-line-data" data-line-start="1504" data-line-end="1515" class="language-cpp"><span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; numbers = {<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>};
    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;::iterator it = numbers.begin(); it != numbers.end(); ++it) {
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="hljs-string">" "</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<hr>
<p class="has-line-data" data-line-start="1518" data-line-end="1520"><strong>Алгоритмы:</strong><br>
Алгоритмы — это набор функций, которые работают с элементами контейнеров через итераторы. Они предоставляют стандартные операции, такие как поиск, сортировка, копирование, удаление и преобразование элементов.</p>
<ul>
<li class="has-line-data" data-line-start="1521" data-line-end="1528"><strong>Примеры алгоритмов:</strong>
<ul>
<li class="has-line-data" data-line-start="1522" data-line-end="1523"><code>std::sort()</code> — сортировка элементов.</li>
<li class="has-line-data" data-line-start="1523" data-line-end="1524"><code>std::find()</code> — поиск элемента.</li>
<li class="has-line-data" data-line-start="1524" data-line-end="1525"><code>std::reverse()</code> — обратный порядок элементов.</li>
<li class="has-line-data" data-line-start="1525" data-line-end="1526"><code>std::for_each()</code> — применение функции к каждому элементу.</li>
<li class="has-line-data" data-line-start="1526" data-line-end="1528"><code>std::transform()</code> — преобразование элементов с сохранением в другой контейнер.</li>
</ul>
</li>
</ul>
<p class="has-line-data" data-line-start="1528" data-line-end="1529"><strong>Пример использования алгоритма:</strong></p>
<pre><code class="has-line-data" data-line-start="1531" data-line-end="1544" class="language-cpp"><span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; numbers = {<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>};
    <span class="hljs-built_in">std</span>::sort(numbers.begin(), numbers.end());
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> n : numbers) {
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="hljs-string">" "</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<hr>
<p class="has-line-data" data-line-start="1547" data-line-end="1549"><strong>Заключение:</strong><br>
STL — это мощный инструмент, который повышает производительность разработки. Контейнеры позволяют удобно хранить данные, итераторы упрощают доступ к элементам, а алгоритмы обеспечивают стандартные операции над этими элементами. Вместе они предоставляют универсальный подход к обработке данных в C++ и делают код более читаемым, надёжным и переносимым.</p>
<p class="has-line-data" data-line-start="1551" data-line-end="1552"><strong>18. Библиотека <code>&lt;string&gt;</code> для работы со строками.</strong></p>
<p class="has-line-data" data-line-start="1553" data-line-end="1554"><strong>Общее описание:</strong></p>
<p class="has-line-data" data-line-start="1555" data-line-end="1556">Библиотека <code>&lt;string&gt;</code> предоставляет стандартный класс <code>std::string</code>, который позволяет работать со строками более эффективно и удобно, чем массивы символов в стиле C (<code>char[]</code>).</p>
<ul>
<li class="has-line-data" data-line-start="1557" data-line-end="1558"><code>std::string</code> — это динамическая строка, которая автоматически изменяет размер, упрощая манипуляции с текстом.</li>
<li class="has-line-data" data-line-start="1558" data-line-end="1560">Поддерживает стандартные операции, такие как конкатенация, поиск, замена и извлечение подстрок.</li>
</ul>
<hr>
<p class="has-line-data" data-line-start="1562" data-line-end="1563"><strong>Основные возможности <code>std::string</code>:</strong></p>
<ol>
<li class="has-line-data" data-line-start="1564" data-line-end="1574">
<p class="has-line-data" data-line-start="1564" data-line-end="1566"><strong>Создание строк:</strong><br>
Можно создавать пустую строку, строку с определённым содержимым, строку из нескольких символов.</p>
<pre><code class="has-line-data" data-line-start="1568" data-line-end="1573" class="language-cpp"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> s1;                     <span class="hljs-comment">// пустая строка</span>
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> s2 = <span class="hljs-string">"Hello"</span>;           <span class="hljs-comment">// строка из литерала</span>
<span class="hljs-built_in">std</span>::<span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">s3</span><span class="hljs-params">(<span class="hljs-number">5</span>, <span class="hljs-string">'a'</span>)</span></span>;             <span class="hljs-comment">// строка "aaaaa"</span>
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> s4 = s2;                <span class="hljs-comment">// копия строки</span>
</code></pre>
</li>
<li class="has-line-data" data-line-start="1574" data-line-end="1582">
<p class="has-line-data" data-line-start="1574" data-line-end="1576"><strong>Конкатенация строк:</strong><br>
Используется оператор <code>+</code> или метод <code>append()</code>.</p>
<pre><code class="has-line-data" data-line-start="1578" data-line-end="1581" class="language-cpp"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> s = <span class="hljs-string">"Hello, "</span> + <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>(<span class="hljs-string">"world!"</span>);
s.append(<span class="hljs-string">" How are you?"</span>);
</code></pre>
</li>
<li class="has-line-data" data-line-start="1582" data-line-end="1590">
<p class="has-line-data" data-line-start="1582" data-line-end="1584"><strong>Доступ к символам:</strong><br>
Доступ возможен через оператор <code>[]</code> или метод <code>at()</code>.</p>
<pre><code class="has-line-data" data-line-start="1586" data-line-end="1589" class="language-cpp"><span class="hljs-keyword">char</span> ch = s[<span class="hljs-number">0</span>];
s[<span class="hljs-number">1</span>] = <span class="hljs-string">'a'</span>;
</code></pre>
</li>
<li class="has-line-data" data-line-start="1590" data-line-end="1598">
<p class="has-line-data" data-line-start="1590" data-line-end="1592"><strong>Извлечение подстроки:</strong><br>
Метод <code>substr()</code> возвращает часть строки.</p>
<pre><code class="has-line-data" data-line-start="1594" data-line-end="1597" class="language-cpp"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> s = <span class="hljs-string">"Hello, world!"</span>;
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> sub = s.substr(<span class="hljs-number">7</span>, <span class="hljs-number">5</span>); <span class="hljs-comment">// sub == "world"</span>
</code></pre>
</li>
<li class="has-line-data" data-line-start="1598" data-line-end="1606">
<p class="has-line-data" data-line-start="1598" data-line-end="1600"><strong>Поиск:</strong><br>
Методы <code>find()</code>, <code>rfind()</code> ищут подстроку или символ в строке.</p>
<pre><code class="has-line-data" data-line-start="1602" data-line-end="1605" class="language-cpp"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> s = <span class="hljs-string">"Hello, world!"</span>;
<span class="hljs-keyword">size_t</span> pos = s.find(<span class="hljs-string">"world"</span>); <span class="hljs-comment">// pos == 7</span>
</code></pre>
</li>
<li class="has-line-data" data-line-start="1606" data-line-end="1614">
<p class="has-line-data" data-line-start="1606" data-line-end="1608"><strong>Сравнение строк:</strong><br>
Операторы <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, а также метод <code>compare()</code> позволяют сравнивать строки.</p>
<pre><code class="has-line-data" data-line-start="1610" data-line-end="1613" class="language-cpp"><span class="hljs-keyword">if</span> (s1 == s2) { <span class="hljs-comment">/* ... */</span> }
<span class="hljs-keyword">if</span> (s1.compare(s2) &lt; <span class="hljs-number">0</span>) { <span class="hljs-comment">/* ... */</span> }
</code></pre>
</li>
<li class="has-line-data" data-line-start="1614" data-line-end="1623">
<p class="has-line-data" data-line-start="1614" data-line-end="1616"><strong>Изменение строки:</strong><br>
Методы <code>replace()</code>, <code>erase()</code>, <code>insert()</code> позволяют заменять, удалять и добавлять символы или подстроки.</p>
<pre><code class="has-line-data" data-line-start="1618" data-line-end="1622" class="language-cpp">s.replace(<span class="hljs-number">7</span>, <span class="hljs-number">5</span>, <span class="hljs-string">"universe"</span>);
s.erase(<span class="hljs-number">0</span>, <span class="hljs-number">6</span>);
s.insert(<span class="hljs-number">0</span>, <span class="hljs-string">"Greetings "</span>);
</code></pre>
</li>
<li class="has-line-data" data-line-start="1623" data-line-end="1630">
<p class="has-line-data" data-line-start="1623" data-line-end="1625"><strong>Длина строки:</strong><br>
Метод <code>size()</code> или <code>length()</code> возвращает число символов.</p>
<pre><code class="has-line-data" data-line-start="1627" data-line-end="1629" class="language-cpp"><span class="hljs-keyword">size_t</span> len = s.length();
</code></pre>
</li>
<li class="has-line-data" data-line-start="1630" data-line-end="1637">
<p class="has-line-data" data-line-start="1630" data-line-end="1632"><strong>Преобразование строк:</strong><br>
Использование функции <code>std::to_string()</code> для преобразования чисел в строки:</p>
<pre><code class="has-line-data" data-line-start="1634" data-line-end="1637" class="language-cpp"><span class="hljs-keyword">int</span> n = <span class="hljs-number">42</span>;
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> s = <span class="hljs-built_in">std</span>::to_string(n);
</code></pre>
</li>
</ol>
<hr>
<p class="has-line-data" data-line-start="1641" data-line-end="1642"><strong>Преимущества <code>std::string</code> по сравнению с <code>char[]</code>:</strong></p>
<ul>
<li class="has-line-data" data-line-start="1643" data-line-end="1644"><strong>Безопасность:</strong> Нет необходимости вручную управлять размером буфера или добавлять нулевой символ в конце.</li>
<li class="has-line-data" data-line-start="1644" data-line-end="1645"><strong>Удобство:</strong> Методы для распространённых операций упрощают код.</li>
<li class="has-line-data" data-line-start="1645" data-line-end="1646"><strong>Гибкость:</strong> Автоматическое изменение размера строки при добавлении или удалении символов.</li>
<li class="has-line-data" data-line-start="1646" data-line-end="1648"><strong>Интеграция со стандартными библиотеками:</strong> <code>std::string</code> работает с алгоритмами STL, такими как <code>std::find</code> или <code>std::sort</code>.</li>
</ul>
<hr>
<p class="has-line-data" data-line-start="1650" data-line-end="1651"><strong>Пример работы с <code>std::string</code>:</strong></p>
<pre><code class="has-line-data" data-line-start="1653" data-line-end="1669" class="language-cpp"><span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> greeting = <span class="hljs-string">"Hello, "</span>;
    greeting += <span class="hljs-string">"world!"</span>;
    
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Length: "</span> &lt;&lt; greeting.size() &lt;&lt; <span class="hljs-string">'\n'</span>;
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Substring: "</span> &lt;&lt; greeting.substr(<span class="hljs-number">7</span>, <span class="hljs-number">5</span>) &lt;&lt; <span class="hljs-string">'\n'</span>;
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Replaced: "</span>;
    greeting.replace(<span class="hljs-number">7</span>, <span class="hljs-number">5</span>, <span class="hljs-string">"universe"</span>);
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; greeting &lt;&lt; <span class="hljs-string">'\n'</span>;
    
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<hr>
<p class="has-line-data" data-line-start="1672" data-line-end="1674"><strong>Заключение:</strong><br>
Библиотека <code>&lt;string&gt;</code> значительно упрощает работу со строками в C++, предоставляя удобный и безопасный интерфейс для операций, которые ранее требовали сложных манипуляций с массивами символов. Этот инструмент стал основным выбором для работы с текстом в современных программах на C++.</p>
<p class="has-line-data" data-line-start="1676" data-line-end="1677"><strong>19. Контейнер vector. Библиотека <code>&lt;vector&gt;</code>: особенности, стандартные имена и методы.</strong></p>
<p class="has-line-data" data-line-start="1678" data-line-end="1680"><strong>Общее описание:</strong><br>
<code>std::vector</code> — это динамический массив из стандартной библиотеки C++. Он хранит элементы в последовательной памяти, поддерживает произвольный доступ и может автоматически изменять свой размер. Вектор является одним из наиболее часто используемых контейнеров STL, поскольку он сочетает в себе простоту работы с массивами и гибкость стандартных контейнеров.</p>
<hr>
<p class="has-line-data" data-line-start="1683" data-line-end="1684"><strong>Особенности <code>std::vector</code>:</strong></p>
<ul>
<li class="has-line-data" data-line-start="1685" data-line-end="1689">
<p class="has-line-data" data-line-start="1685" data-line-end="1686"><strong>Динамическое изменение размера:</strong></p>
<ul>
<li class="has-line-data" data-line-start="1687" data-line-end="1688">Вектор увеличивает свой размер по мере добавления новых элементов.</li>
<li class="has-line-data" data-line-start="1688" data-line-end="1689">Операции добавления могут вызывать перераспределение памяти, если текущий выделенный блок не вмещает новые элементы.</li>
</ul>
</li>
<li class="has-line-data" data-line-start="1689" data-line-end="1693">
<p class="has-line-data" data-line-start="1689" data-line-end="1690"><strong>Произвольный доступ:</strong></p>
<ul>
<li class="has-line-data" data-line-start="1691" data-line-end="1692">Доступ к элементам возможен через индекс: <code>v[i]</code>.</li>
<li class="has-line-data" data-line-start="1692" data-line-end="1693">Время доступа к элементу — O(1).</li>
</ul>
</li>
<li class="has-line-data" data-line-start="1693" data-line-end="1697">
<p class="has-line-data" data-line-start="1693" data-line-end="1694"><strong>Поддержка итераторов:</strong></p>
<ul>
<li class="has-line-data" data-line-start="1695" data-line-end="1696">Вектор предоставляет стандартные итераторы: <code>begin()</code>, <code>end()</code>, <code>rbegin()</code>, <code>rend()</code>.</li>
<li class="has-line-data" data-line-start="1696" data-line-end="1697">Эти итераторы совместимы со всеми стандартными алгоритмами STL.</li>
</ul>
</li>
<li class="has-line-data" data-line-start="1697" data-line-end="1701">
<p class="has-line-data" data-line-start="1697" data-line-end="1698"><strong>Постоянный размер заголовка:</strong></p>
<ul>
<li class="has-line-data" data-line-start="1699" data-line-end="1701"><code>std::vector</code> не содержит дополнительных указателей или связей между элементами, как списки или деревья. Это делает его быстрым и эффективным для хранения больших массивов данных.</li>
</ul>
</li>
</ul>
<hr>
<p class="has-line-data" data-line-start="1703" data-line-end="1704"><strong>Стандартные методы <code>std::vector</code>:</strong></p>
<ol>
<li class="has-line-data" data-line-start="1705" data-line-end="1714">
<p class="has-line-data" data-line-start="1705" data-line-end="1706"><strong>Создание и инициализация:</strong></p>
<pre><code class="has-line-data" data-line-start="1708" data-line-end="1713" class="language-cpp"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v1;                  <span class="hljs-comment">// пустой вектор</span>
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v2(<span class="hljs-number">10</span>);              <span class="hljs-comment">// вектор с 10 элементами</span>
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v3(<span class="hljs-number">10</span>, <span class="hljs-number">42</span>);          <span class="hljs-comment">// 10 элементов со значением 42</span>
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v4 = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>};   <span class="hljs-comment">// список инициализации</span>
</code></pre>
</li>
<li class="has-line-data" data-line-start="1714" data-line-end="1724">
<p class="has-line-data" data-line-start="1714" data-line-end="1715"><strong>Добавление элементов:</strong></p>
<ul>
<li class="has-line-data" data-line-start="1716" data-line-end="1717"><code>push_back(value)</code>: добавляет элемент в конец.</li>
<li class="has-line-data" data-line-start="1717" data-line-end="1719"><code>emplace_back(args...)</code>: создаёт элемент на месте, избегая лишнего копирования.</li>
</ul>
<pre><code class="has-line-data" data-line-start="1720" data-line-end="1723" class="language-cpp">v.push_back(<span class="hljs-number">10</span>);
v.emplace_back(<span class="hljs-number">20</span>);
</code></pre>
</li>
<li class="has-line-data" data-line-start="1724" data-line-end="1737">
<p class="has-line-data" data-line-start="1724" data-line-end="1725"><strong>Удаление элементов:</strong></p>
<ul>
<li class="has-line-data" data-line-start="1726" data-line-end="1727"><code>pop_back()</code>: удаляет последний элемент.</li>
<li class="has-line-data" data-line-start="1727" data-line-end="1728"><code>erase(pos)</code>: удаляет элемент по итератору.</li>
<li class="has-line-data" data-line-start="1728" data-line-end="1729"><code>erase(first, last)</code>: удаляет диапазон элементов.</li>
<li class="has-line-data" data-line-start="1729" data-line-end="1731"><code>clear()</code>: очищает весь вектор.</li>
</ul>
<pre><code class="has-line-data" data-line-start="1732" data-line-end="1736" class="language-cpp">v.pop_back();
v.erase(v.begin() + <span class="hljs-number">2</span>);
v.clear();
</code></pre>
</li>
<li class="has-line-data" data-line-start="1737" data-line-end="1750">
<p class="has-line-data" data-line-start="1737" data-line-end="1738"><strong>Размер и ёмкость:</strong></p>
<ul>
<li class="has-line-data" data-line-start="1739" data-line-end="1740"><code>size()</code>: возвращает количество элементов.</li>
<li class="has-line-data" data-line-start="1740" data-line-end="1741"><code>capacity()</code>: показывает количество элементов, которые вектор может хранить без перераспределения памяти.</li>
<li class="has-line-data" data-line-start="1741" data-line-end="1742"><code>resize(n)</code>: изменяет размер вектора.</li>
<li class="has-line-data" data-line-start="1742" data-line-end="1743"><code>reserve(n)</code>: резервирует память для как минимум <code>n</code> элементов.</li>
<li class="has-line-data" data-line-start="1743" data-line-end="1745"><code>shrink_to_fit()</code>: уменьшает ёмкость вектора до текущего размера.</li>
</ul>
<pre><code class="has-line-data" data-line-start="1746" data-line-end="1749" class="language-cpp">v.reserve(<span class="hljs-number">100</span>);
v.resize(<span class="hljs-number">20</span>);
</code></pre>
</li>
<li class="has-line-data" data-line-start="1750" data-line-end="1762">
<p class="has-line-data" data-line-start="1750" data-line-end="1751"><strong>Доступ к элементам:</strong></p>
<ul>
<li class="has-line-data" data-line-start="1752" data-line-end="1753"><code>operator[]</code>: доступ по индексу без проверки границ.</li>
<li class="has-line-data" data-line-start="1753" data-line-end="1754"><code>at(index)</code>: доступ по индексу с проверкой границ.</li>
<li class="has-line-data" data-line-start="1754" data-line-end="1755"><code>front()</code>: возвращает ссылку на первый элемент.</li>
<li class="has-line-data" data-line-start="1755" data-line-end="1757"><code>back()</code>: возвращает ссылку на последний элемент.</li>
</ul>
<pre><code class="has-line-data" data-line-start="1758" data-line-end="1761" class="language-cpp"><span class="hljs-keyword">int</span> first = v.front();
<span class="hljs-keyword">int</span> last = v.back();
</code></pre>
</li>
<li class="has-line-data" data-line-start="1762" data-line-end="1773">
<p class="has-line-data" data-line-start="1762" data-line-end="1763"><strong>Итераторы:</strong></p>
<ul>
<li class="has-line-data" data-line-start="1764" data-line-end="1765"><code>begin()</code>, <code>end()</code>: итераторы на начало и конец.</li>
<li class="has-line-data" data-line-start="1765" data-line-end="1766"><code>rbegin()</code>, <code>rend()</code>: обратные итераторы.</li>
<li class="has-line-data" data-line-start="1766" data-line-end="1768"><code>cbegin()</code>, <code>cend()</code>: константные итераторы.</li>
</ul>
<pre><code class="has-line-data" data-line-start="1769" data-line-end="1773" class="language-cpp"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = v.begin(); it != v.end(); ++it) {
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="hljs-string">" "</span>;
}
</code></pre>
</li>
</ol>
<hr>
<p class="has-line-data" data-line-start="1777" data-line-end="1778"><strong>Пример использования <code>std::vector</code>:</strong></p>
<pre><code class="has-line-data" data-line-start="1780" data-line-end="1803" class="language-cpp"><span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; numbers = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>};

    <span class="hljs-comment">// Добавление элемента</span>
    numbers.push_back(<span class="hljs-number">6</span>);

    <span class="hljs-comment">// Удаление элемента</span>
    numbers.erase(numbers.begin() + <span class="hljs-number">2</span>);

    <span class="hljs-comment">// Доступ к элементу</span>
    <span class="hljs-keyword">int</span> value = numbers[<span class="hljs-number">3</span>];

    <span class="hljs-comment">// Вывод всех элементов</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> n : numbers) {
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="hljs-string">" "</span>;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<hr>
<p class="has-line-data" data-line-start="1806" data-line-end="1808"><strong>Заключение:</strong><br>
<code>std::vector</code> — это универсальный и эффективный инструмент для хранения последовательных данных. Его удобный интерфейс, динамическая природа и поддержка стандартных алгоритмов делают его основным выбором для большинства задач, требующих работы с массивоподобными структурами.</p>
<p class="has-line-data" data-line-start="1810" data-line-end="1811"><strong>20. Контейнер stack. Библиотека <code>&lt;stack&gt;</code>: особенности, стандартные имена и методы.</strong></p>
<p class="has-line-data" data-line-start="1812" data-line-end="1813"><strong>Общее описание:</strong></p>
<p class="has-line-data" data-line-start="1814" data-line-end="1815"><code>std::stack</code> — это контейнер-адаптер, который реализует принцип LIFO (last-in, first-out), то есть последний добавленный элемент извлекается первым. <code>std::stack</code> предоставляет упрощённый интерфейс для работы с данными, скрывая внутреннюю структуру хранения. Он основан на любом последовательном контейнере (по умолчанию на <code>std::deque</code>), что делает его гибким и удобным в использовании.</p>
<hr>
<p class="has-line-data" data-line-start="1818" data-line-end="1819"><strong>Особенности <code>std::stack</code>:</strong></p>
<ol>
<li class="has-line-data" data-line-start="1820" data-line-end="1824">
<p class="has-line-data" data-line-start="1820" data-line-end="1821"><strong>Принцип LIFO:</strong></p>
<ul>
<li class="has-line-data" data-line-start="1822" data-line-end="1823">Вставка элемента производится только в конец стека.</li>
<li class="has-line-data" data-line-start="1823" data-line-end="1824">Извлечение элемента происходит также из конца.</li>
</ul>
</li>
<li class="has-line-data" data-line-start="1824" data-line-end="1828">
<p class="has-line-data" data-line-start="1824" data-line-end="1825"><strong>Базовый контейнер:</strong></p>
<ul>
<li class="has-line-data" data-line-start="1826" data-line-end="1827"><code>std::stack</code> использует один из стандартных последовательных контейнеров (<code>std::vector</code>, <code>std::deque</code>, <code>std::list</code>) для хранения данных.</li>
<li class="has-line-data" data-line-start="1827" data-line-end="1828">По умолчанию используется <code>std::deque</code>.</li>
</ul>
</li>
<li class="has-line-data" data-line-start="1828" data-line-end="1833">
<p class="has-line-data" data-line-start="1828" data-line-end="1829"><strong>Ограниченный интерфейс:</strong></p>
<ul>
<li class="has-line-data" data-line-start="1830" data-line-end="1831"><code>std::stack</code> не предоставляет прямого доступа к элементам, кроме как к верхнему (последнему) элементу.</li>
<li class="has-line-data" data-line-start="1831" data-line-end="1833">Это упрощает API и подчёркивает, что доступ к элементам осуществляется строго через операции добавления, удаления и просмотра верхнего элемента.</li>
</ul>
</li>
</ol>
<hr>
<p class="has-line-data" data-line-start="1835" data-line-end="1836"><strong>Основные методы <code>std::stack</code>:</strong></p>
<ol>
<li class="has-line-data" data-line-start="1837" data-line-end="1845">
<p class="has-line-data" data-line-start="1837" data-line-end="1838"><strong>Создание и инициализация:</strong></p>
<pre><code class="has-line-data" data-line-start="1840" data-line-end="1844" class="language-cpp"><span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span>
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; s1;                   <span class="hljs-comment">// Пустой стек</span>
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; s2; <span class="hljs-comment">// Стек на основе std::vector</span>
</code></pre>
</li>
<li class="has-line-data" data-line-start="1845" data-line-end="1855">
<p class="has-line-data" data-line-start="1845" data-line-end="1846"><strong>Добавление элементов:</strong></p>
<ul>
<li class="has-line-data" data-line-start="1847" data-line-end="1848"><code>push(value)</code>: помещает элемент в стек.</li>
<li class="has-line-data" data-line-start="1848" data-line-end="1850"><code>emplace(args...)</code>: создаёт элемент на месте.</li>
</ul>
<pre><code class="has-line-data" data-line-start="1851" data-line-end="1854" class="language-cpp">s.push(<span class="hljs-number">10</span>);
s.emplace(<span class="hljs-number">20</span>);
</code></pre>
</li>
<li class="has-line-data" data-line-start="1855" data-line-end="1866">
<p class="has-line-data" data-line-start="1855" data-line-end="1856"><strong>Удаление элементов:</strong></p>
<ul>
<li class="has-line-data" data-line-start="1857" data-line-end="1858"><code>pop()</code>: удаляет верхний элемент.</li>
<li class="has-line-data" data-line-start="1858" data-line-end="1860">Перед вызовом <code>pop()</code> рекомендуется проверять, что стек не пуст (метод <code>empty()</code>).</li>
</ul>
<pre><code class="has-line-data" data-line-start="1861" data-line-end="1865" class="language-cpp"><span class="hljs-keyword">if</span> (!s.empty()) {
    s.pop();
}
</code></pre>
</li>
<li class="has-line-data" data-line-start="1866" data-line-end="1875">
<p class="has-line-data" data-line-start="1866" data-line-end="1867"><strong>Доступ к верхнему элементу:</strong></p>
<ul>
<li class="has-line-data" data-line-start="1868" data-line-end="1869"><code>top()</code>: возвращает ссылку на верхний элемент.</li>
<li class="has-line-data" data-line-start="1869" data-line-end="1871">Позволяет как читать, так и изменять верхний элемент.</li>
</ul>
<pre><code class="has-line-data" data-line-start="1872" data-line-end="1874" class="language-cpp">s.top() = <span class="hljs-number">42</span>;
</code></pre>
</li>
<li class="has-line-data" data-line-start="1875" data-line-end="1886">
<p class="has-line-data" data-line-start="1875" data-line-end="1876"><strong>Проверка состояния:</strong></p>
<ul>
<li class="has-line-data" data-line-start="1877" data-line-end="1878"><code>empty()</code>: проверяет, пуст ли стек.</li>
<li class="has-line-data" data-line-start="1878" data-line-end="1880"><code>size()</code>: возвращает количество элементов в стеке.</li>
</ul>
<pre><code class="has-line-data" data-line-start="1881" data-line-end="1886" class="language-cpp"><span class="hljs-keyword">if</span> (s.empty()) {
    <span class="hljs-comment">// стек пуст</span>
}
<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> count = s.size();
</code></pre>
</li>
</ol>
<hr>
<p class="has-line-data" data-line-start="1890" data-line-end="1891"><strong>Пример использования <code>std::stack</code>:</strong></p>
<pre><code class="has-line-data" data-line-start="1893" data-line-end="1913" class="language-cpp"><span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-built_in">stack</span>;

    <span class="hljs-comment">// Добавление элементов</span>
    <span class="hljs-built_in">stack</span>.push(<span class="hljs-number">1</span>);
    <span class="hljs-built_in">stack</span>.push(<span class="hljs-number">2</span>);
    <span class="hljs-built_in">stack</span>.push(<span class="hljs-number">3</span>);

    <span class="hljs-comment">// Извлечение элементов</span>
    <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">stack</span>.empty()) {
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">stack</span>.top() &lt;&lt; <span class="hljs-string">" "</span>; <span class="hljs-comment">// Выводим верхний элемент</span>
        <span class="hljs-built_in">stack</span>.pop();                     <span class="hljs-comment">// Удаляем верхний элемент</span>
    }

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<hr>
<p class="has-line-data" data-line-start="1916" data-line-end="1917"><strong>Преимущества <code>std::stack</code>:</strong></p>
<ul>
<li class="has-line-data" data-line-start="1918" data-line-end="1921">
<p class="has-line-data" data-line-start="1918" data-line-end="1920"><strong>Упрощённый интерфейс:</strong><br>
Позволяет сосредоточиться на основных операциях с LIFO-структурой.</p>
</li>
<li class="has-line-data" data-line-start="1921" data-line-end="1924">
<p class="has-line-data" data-line-start="1921" data-line-end="1923"><strong>Гибкость:</strong><br>
Может использовать различную базовую структуру для хранения элементов.</p>
</li>
<li class="has-line-data" data-line-start="1924" data-line-end="1926">
<p class="has-line-data" data-line-start="1924" data-line-end="1926"><strong>Совместимость:</strong><br>
Интегрируется со стандартной библиотекой и STL-алгоритмами.</p>
</li>
</ul>
<hr>
<p class="has-line-data" data-line-start="1930" data-line-end="1931"><strong>Заключение:</strong></p>
<p class="has-line-data" data-line-start="1932" data-line-end="1933"><code>std::stack</code> идеально подходит для задач, где нужен строгий доступ к данным по принципу LIFO, и обеспечивает простой, безопасный и интуитивно понятный интерфейс для работы с такими структурами.</p>
<p class="has-line-data" data-line-start="1935" data-line-end="1936"><strong>21. Контейнер queue. Библиотека <code>&lt;queue&gt;</code>: особенности, стандартные имена и методы.</strong></p>
<p class="has-line-data" data-line-start="1937" data-line-end="1938"><strong>Общее описание:</strong></p>
<p class="has-line-data" data-line-start="1939" data-line-end="1940"><code>std::queue</code> — это контейнер-адаптер, реализующий принцип FIFO (first-in, first-out). Элементы добавляются в конец очереди и извлекаются из её начала. Это удобная структура данных для сценариев, где порядок поступления и обработки элементов должен сохраняться.</p>
<hr>
<p class="has-line-data" data-line-start="1943" data-line-end="1944"><strong>Особенности <code>std::queue</code>:</strong></p>
<ol>
<li class="has-line-data" data-line-start="1945" data-line-end="1949">
<p class="has-line-data" data-line-start="1945" data-line-end="1946"><strong>Принцип FIFO:</strong></p>
<ul>
<li class="has-line-data" data-line-start="1947" data-line-end="1948">Первый добавленный элемент извлекается первым.</li>
<li class="has-line-data" data-line-start="1948" data-line-end="1949">Последний добавленный элемент будет извлечён только после всех предыдущих.</li>
</ul>
</li>
<li class="has-line-data" data-line-start="1949" data-line-end="1954">
<p class="has-line-data" data-line-start="1949" data-line-end="1950"><strong>Базовый контейнер:</strong></p>
<ul>
<li class="has-line-data" data-line-start="1951" data-line-end="1952"><code>std::queue</code> работает на основе других последовательных контейнеров.</li>
<li class="has-line-data" data-line-start="1952" data-line-end="1953">По умолчанию используется <code>std::deque</code>.</li>
<li class="has-line-data" data-line-start="1953" data-line-end="1954">Также может работать с <code>std::list</code> или другими совместимыми контейнерами.</li>
</ul>
</li>
<li class="has-line-data" data-line-start="1954" data-line-end="1960">
<p class="has-line-data" data-line-start="1954" data-line-end="1955"><strong>Ограниченный интерфейс:</strong></p>
<ul>
<li class="has-line-data" data-line-start="1956" data-line-end="1957">Доступ возможен только к началу и концу очереди.</li>
<li class="has-line-data" data-line-start="1957" data-line-end="1958">Прямого доступа ко всем элементам (например, через индекс) нет.</li>
<li class="has-line-data" data-line-start="1958" data-line-end="1960">Упрощённый API подчёркивает, что очередь предназначена для работы с элементами строго в порядке их поступления.</li>
</ul>
</li>
</ol>
<hr>
<p class="has-line-data" data-line-start="1962" data-line-end="1963"><strong>Основные методы <code>std::queue</code>:</strong></p>
<ol>
<li class="has-line-data" data-line-start="1964" data-line-end="1972">
<p class="has-line-data" data-line-start="1964" data-line-end="1965"><strong>Создание и инициализация:</strong></p>
<pre><code class="has-line-data" data-line-start="1967" data-line-end="1971" class="language-cpp"><span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span>
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt; q1;                   <span class="hljs-comment">// Пустая очередь</span>
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">deque</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; q2; <span class="hljs-comment">// Очередь на основе std::deque</span>
</code></pre>
</li>
<li class="has-line-data" data-line-start="1972" data-line-end="1982">
<p class="has-line-data" data-line-start="1972" data-line-end="1973"><strong>Добавление элементов:</strong></p>
<ul>
<li class="has-line-data" data-line-start="1974" data-line-end="1975"><code>push(value)</code>: добавляет элемент в конец очереди.</li>
<li class="has-line-data" data-line-start="1975" data-line-end="1977"><code>emplace(args...)</code>: создаёт элемент на месте, избегая лишнего копирования.</li>
</ul>
<pre><code class="has-line-data" data-line-start="1978" data-line-end="1981" class="language-cpp">q.push(<span class="hljs-number">10</span>);
q.emplace(<span class="hljs-number">20</span>);
</code></pre>
</li>
<li class="has-line-data" data-line-start="1982" data-line-end="1993">
<p class="has-line-data" data-line-start="1982" data-line-end="1983"><strong>Удаление элементов:</strong></p>
<ul>
<li class="has-line-data" data-line-start="1984" data-line-end="1985"><code>pop()</code>: удаляет элемент с начала очереди.</li>
<li class="has-line-data" data-line-start="1985" data-line-end="1987">Перед вызовом <code>pop()</code> рекомендуется убедиться, что очередь не пуста.</li>
</ul>
<pre><code class="has-line-data" data-line-start="1988" data-line-end="1992" class="language-cpp"><span class="hljs-keyword">if</span> (!q.empty()) {
    q.pop();
}
</code></pre>
</li>
<li class="has-line-data" data-line-start="1993" data-line-end="2004">
<p class="has-line-data" data-line-start="1993" data-line-end="1994"><strong>Доступ к элементам:</strong></p>
<ul>
<li class="has-line-data" data-line-start="1995" data-line-end="1996"><code>front()</code>: возвращает ссылку на первый (самый старый) элемент.</li>
<li class="has-line-data" data-line-start="1996" data-line-end="1997"><code>back()</code>: возвращает ссылку на последний (самый новый) элемент.</li>
<li class="has-line-data" data-line-start="1997" data-line-end="1999">Эти методы позволяют как читать, так и изменять элементы.</li>
</ul>
<pre><code class="has-line-data" data-line-start="2000" data-line-end="2003" class="language-cpp"><span class="hljs-keyword">int</span> first = q.front();
<span class="hljs-keyword">int</span> last = q.back();
</code></pre>
</li>
<li class="has-line-data" data-line-start="2004" data-line-end="2015">
<p class="has-line-data" data-line-start="2004" data-line-end="2005"><strong>Проверка состояния:</strong></p>
<ul>
<li class="has-line-data" data-line-start="2006" data-line-end="2007"><code>empty()</code>: проверяет, пуста ли очередь.</li>
<li class="has-line-data" data-line-start="2007" data-line-end="2009"><code>size()</code>: возвращает количество элементов в очереди.</li>
</ul>
<pre><code class="has-line-data" data-line-start="2010" data-line-end="2015" class="language-cpp"><span class="hljs-keyword">if</span> (q.empty()) {
    <span class="hljs-comment">// очередь пуста</span>
}
<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> count = q.size();
</code></pre>
</li>
</ol>
<hr>
<p class="has-line-data" data-line-start="2019" data-line-end="2020"><strong>Пример использования <code>std::queue</code>:</strong></p>
<pre><code class="has-line-data" data-line-start="2022" data-line-end="2042" class="language-cpp"><span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt; q;

    <span class="hljs-comment">// Добавление элементов</span>
    q.push(<span class="hljs-number">1</span>);
    q.push(<span class="hljs-number">2</span>);
    q.push(<span class="hljs-number">3</span>);

    <span class="hljs-comment">// Извлечение элементов</span>
    <span class="hljs-keyword">while</span> (!q.empty()) {
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; q.front() &lt;&lt; <span class="hljs-string">" "</span>; <span class="hljs-comment">// Выводим первый элемент</span>
        q.pop();                       <span class="hljs-comment">// Удаляем первый элемент</span>
    }

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<hr>
<p class="has-line-data" data-line-start="2045" data-line-end="2046"><strong>Преимущества <code>std::queue</code>:</strong></p>
<ul>
<li class="has-line-data" data-line-start="2047" data-line-end="2050">
<p class="has-line-data" data-line-start="2047" data-line-end="2049"><strong>Упрощённый интерфейс:</strong><br>
Подходит для задач, где требуется обработка элементов строго в порядке поступления.</p>
</li>
<li class="has-line-data" data-line-start="2050" data-line-end="2053">
<p class="has-line-data" data-line-start="2050" data-line-end="2052"><strong>Гибкость:</strong><br>
Может работать с разными базовыми контейнерами, предоставляя универсальность в использовании.</p>
</li>
<li class="has-line-data" data-line-start="2053" data-line-end="2055">
<p class="has-line-data" data-line-start="2053" data-line-end="2055"><strong>Совместимость:</strong><br>
Интеграция с STL позволяет легко применять алгоритмы и функциональные методы к контейнеру.</p>
</li>
</ul>
<hr>
<p class="has-line-data" data-line-start="2059" data-line-end="2060"><strong>Заключение:</strong></p>
<p class="has-line-data" data-line-start="2061" data-line-end="2062"><code>std::queue</code> — это надёжный инструмент для реализации очередей. Он предоставляет простой и понятный интерфейс для работы с элементами в порядке их поступления, что делает его естественным выбором для многих алгоритмов и задач.</p>
<p class="has-line-data" data-line-start="2064" data-line-end="2065"><strong>22. Контейнер deque. Библиотека <code>&lt;deque&gt;</code>: особенности, стандартные имена и методы.</strong></p>
<p class="has-line-data" data-line-start="2066" data-line-end="2068"><strong>Общее описание:</strong><br>
<code>std::deque</code> (double-ended queue) — это контейнер из стандартной библиотеки C++, который предоставляет эффективный доступ к элементам с обоих концов (начала и конца). <code>std::deque</code> объединяет преимущества динамического массива и двусвязного списка, обеспечивая гибкость при добавлении и удалении элементов.</p>
<hr>
<p class="has-line-data" data-line-start="2071" data-line-end="2072"><strong>Особенности <code>std::deque</code>:</strong></p>
<ol>
<li class="has-line-data" data-line-start="2073" data-line-end="2077">
<p class="has-line-data" data-line-start="2073" data-line-end="2074"><strong>Доступ к элементам:</strong></p>
<ul>
<li class="has-line-data" data-line-start="2075" data-line-end="2076">Как и <code>std::vector</code>, поддерживает произвольный доступ по индексу (время доступа — O(1)).</li>
<li class="has-line-data" data-line-start="2076" data-line-end="2077">Отличается от <code>std::vector</code> тем, что вставка и удаление элементов с начала также эффективно (время — O(1) или O(амортизированное 1)).</li>
</ul>
</li>
<li class="has-line-data" data-line-start="2077" data-line-end="2081">
<p class="has-line-data" data-line-start="2077" data-line-end="2078"><strong>Структура хранения:</strong></p>
<ul>
<li class="has-line-data" data-line-start="2079" data-line-end="2080">В отличие от <code>std::vector</code>, <code>std::deque</code> не гарантирует, что все элементы расположены в одной последовательной области памяти.</li>
<li class="has-line-data" data-line-start="2080" data-line-end="2081">Часто элементы хранятся в нескольких блоках памяти, что позволяет эффективно добавлять или удалять элементы с обеих сторон.</li>
</ul>
</li>
<li class="has-line-data" data-line-start="2081" data-line-end="2086">
<p class="has-line-data" data-line-start="2081" data-line-end="2082"><strong>Гибкость:</strong></p>
<ul>
<li class="has-line-data" data-line-start="2083" data-line-end="2084"><code>std::deque</code> идеально подходит для сценариев, где нужно часто добавлять или удалять элементы с начала и конца.</li>
<li class="has-line-data" data-line-start="2084" data-line-end="2086">Он немного медленнее <code>std::vector</code> при большом объёме случайных обращений к элементам, но обеспечивает более универсальную производительность при изменении размера.</li>
</ul>
</li>
</ol>
<hr>
<p class="has-line-data" data-line-start="2088" data-line-end="2089"><strong>Основные методы <code>std::deque</code>:</strong></p>
<ol>
<li class="has-line-data" data-line-start="2090" data-line-end="2100">
<p class="has-line-data" data-line-start="2090" data-line-end="2091"><strong>Создание и инициализация:</strong></p>
<pre><code class="has-line-data" data-line-start="2093" data-line-end="2099" class="language-cpp"><span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;deque&gt;</span></span>
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">deque</span>&lt;<span class="hljs-keyword">int</span>&gt; d1;                  <span class="hljs-comment">// Пустой deque</span>
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">deque</span>&lt;<span class="hljs-keyword">int</span>&gt; d2(<span class="hljs-number">10</span>);              <span class="hljs-comment">// 10 элементов по умолчанию</span>
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">deque</span>&lt;<span class="hljs-keyword">int</span>&gt; d3(<span class="hljs-number">10</span>, <span class="hljs-number">42</span>);          <span class="hljs-comment">// 10 элементов со значением 42</span>
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">deque</span>&lt;<span class="hljs-keyword">int</span>&gt; d4 = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>};   <span class="hljs-comment">// Список инициализации</span>
</code></pre>
</li>
<li class="has-line-data" data-line-start="2100" data-line-end="2114">
<p class="has-line-data" data-line-start="2100" data-line-end="2101"><strong>Добавление элементов:</strong></p>
<ul>
<li class="has-line-data" data-line-start="2102" data-line-end="2103"><code>push_back(value)</code>: добавляет элемент в конец.</li>
<li class="has-line-data" data-line-start="2103" data-line-end="2104"><code>push_front(value)</code>: добавляет элемент в начало.</li>
<li class="has-line-data" data-line-start="2104" data-line-end="2105"><code>emplace_back(args...)</code>: создаёт элемент в конце на месте.</li>
<li class="has-line-data" data-line-start="2105" data-line-end="2107"><code>emplace_front(args...)</code>: создаёт элемент в начале на месте.</li>
</ul>
<pre><code class="has-line-data" data-line-start="2108" data-line-end="2113" class="language-cpp">d.push_back(<span class="hljs-number">10</span>);
d.push_front(<span class="hljs-number">20</span>);
d.emplace_back(<span class="hljs-number">30</span>);
d.emplace_front(<span class="hljs-number">40</span>);
</code></pre>
</li>
<li class="has-line-data" data-line-start="2114" data-line-end="2124">
<p class="has-line-data" data-line-start="2114" data-line-end="2115"><strong>Удаление элементов:</strong></p>
<ul>
<li class="has-line-data" data-line-start="2116" data-line-end="2117"><code>pop_back()</code>: удаляет последний элемент.</li>
<li class="has-line-data" data-line-start="2117" data-line-end="2119"><code>pop_front()</code>: удаляет первый элемент.</li>
</ul>
<pre><code class="has-line-data" data-line-start="2120" data-line-end="2123" class="language-cpp">d.pop_back();
d.pop_front();
</code></pre>
</li>
<li class="has-line-data" data-line-start="2124" data-line-end="2137">
<p class="has-line-data" data-line-start="2124" data-line-end="2125"><strong>Доступ к элементам:</strong></p>
<ul>
<li class="has-line-data" data-line-start="2126" data-line-end="2127"><code>operator[]</code>: доступ по индексу без проверки границ.</li>
<li class="has-line-data" data-line-start="2127" data-line-end="2128"><code>at(index)</code>: доступ по индексу с проверкой границ.</li>
<li class="has-line-data" data-line-start="2128" data-line-end="2129"><code>front()</code>: возвращает ссылку на первый элемент.</li>
<li class="has-line-data" data-line-start="2129" data-line-end="2131"><code>back()</code>: возвращает ссылку на последний элемент.</li>
</ul>
<pre><code class="has-line-data" data-line-start="2132" data-line-end="2136" class="language-cpp"><span class="hljs-keyword">int</span> first = d.front();
<span class="hljs-keyword">int</span> last = d.back();
<span class="hljs-keyword">int</span> value = d[<span class="hljs-number">2</span>];
</code></pre>
</li>
<li class="has-line-data" data-line-start="2137" data-line-end="2151">
<p class="has-line-data" data-line-start="2137" data-line-end="2138"><strong>Проверка состояния:</strong></p>
<ul>
<li class="has-line-data" data-line-start="2139" data-line-end="2140"><code>empty()</code>: проверяет, пуст ли контейнер.</li>
<li class="has-line-data" data-line-start="2140" data-line-end="2141"><code>size()</code>: возвращает количество элементов.</li>
<li class="has-line-data" data-line-start="2141" data-line-end="2143"><code>clear()</code>: очищает весь контейнер.</li>
</ul>
<pre><code class="has-line-data" data-line-start="2144" data-line-end="2150" class="language-cpp"><span class="hljs-keyword">if</span> (d.empty()) {
    <span class="hljs-comment">// контейнер пуст</span>
}
<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> count = d.size();
d.clear();
</code></pre>
</li>
<li class="has-line-data" data-line-start="2151" data-line-end="2162">
<p class="has-line-data" data-line-start="2151" data-line-end="2152"><strong>Итераторы:</strong></p>
<ul>
<li class="has-line-data" data-line-start="2153" data-line-end="2154"><code>begin()</code>, <code>end()</code>: итераторы на начало и конец.</li>
<li class="has-line-data" data-line-start="2154" data-line-end="2155"><code>rbegin()</code>, <code>rend()</code>: обратные итераторы.</li>
<li class="has-line-data" data-line-start="2155" data-line-end="2157"><code>cbegin()</code>, <code>cend()</code>: константные итераторы.</li>
</ul>
<pre><code class="has-line-data" data-line-start="2158" data-line-end="2162" class="language-cpp"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = d.begin(); it != d.end(); ++it) {
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="hljs-string">" "</span>;
}
</code></pre>
</li>
</ol>
<hr>
<p class="has-line-data" data-line-start="2166" data-line-end="2167"><strong>Пример использования <code>std::deque</code>:</strong></p>
<pre><code class="has-line-data" data-line-start="2169" data-line-end="2189" class="language-cpp"><span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;deque&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">deque</span>&lt;<span class="hljs-keyword">int</span>&gt; dq = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>};

    <span class="hljs-comment">// Добавление и удаление элементов</span>
    dq.push_back(<span class="hljs-number">6</span>);
    dq.push_front(<span class="hljs-number">0</span>);
    dq.pop_back();
    dq.pop_front();

    <span class="hljs-comment">// Вывод элементов</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; n : dq) {
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="hljs-string">" "</span>;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<hr>
<p class="has-line-data" data-line-start="2192" data-line-end="2194"><strong>Заключение:</strong><br>
<code>std::deque</code> — это гибкий контейнер, который эффективно справляется с задачами, требующими частого добавления или удаления элементов с обоих концов. Он обеспечивает быстрый произвольный доступ и универсальность, делая его подходящим выбором для множества сценариев.</p>
<p class="has-line-data" data-line-start="2196" data-line-end="2197"><strong>23. Контейнер list. Библиотека <code>&lt;list&gt;</code>: особенности, стандартные имена и методы.</strong></p>
<p class="has-line-data" data-line-start="2198" data-line-end="2200"><strong>Общее описание:</strong><br>
<code>std::list</code> — это двусвязный список из стандартной библиотеки C++. В отличие от <code>std::vector</code> и <code>std::deque</code>, элементы <code>std::list</code> хранятся в отдельных узлах памяти, каждый из которых содержит ссылки на предыдущий и следующий узел. Это делает контейнер удобным для частого добавления, удаления или перемещения элементов в любом месте, но менее эффективным для случайного доступа.</p>
<hr>
<p class="has-line-data" data-line-start="2203" data-line-end="2204"><strong>Особенности <code>std::list</code>:</strong></p>
<ol>
<li class="has-line-data" data-line-start="2205" data-line-end="2209">
<p class="has-line-data" data-line-start="2205" data-line-end="2206"><strong>Двусвязная структура:</strong></p>
<ul>
<li class="has-line-data" data-line-start="2207" data-line-end="2208">Каждый элемент хранит указатели на предыдущий и следующий элемент.</li>
<li class="has-line-data" data-line-start="2208" data-line-end="2209">Вставка и удаление элементов занимают O(1), если известно место вставки (например, предоставлен итератор).</li>
</ul>
</li>
<li class="has-line-data" data-line-start="2209" data-line-end="2213">
<p class="has-line-data" data-line-start="2209" data-line-end="2210"><strong>Итераторы не инвалидируются:</strong></p>
<ul>
<li class="has-line-data" data-line-start="2211" data-line-end="2212">В отличие от <code>std::vector</code> и <code>std::deque</code>, операции добавления или удаления элементов не приводят к недействительности существующих итераторов, если эти итераторы указывают не на удаляемые элементы.</li>
<li class="has-line-data" data-line-start="2212" data-line-end="2213">Это делает <code>std::list</code> полезным для алгоритмов, которые часто изменяют структуру контейнера.</li>
</ul>
</li>
<li class="has-line-data" data-line-start="2213" data-line-end="2216">
<p class="has-line-data" data-line-start="2213" data-line-end="2214"><strong>Отсутствие произвольного доступа:</strong></p>
<ul>
<li class="has-line-data" data-line-start="2215" data-line-end="2216">Время доступа к элементу — O(n), так как приходится идти по списку, начиная с начала или конца.</li>
</ul>
</li>
<li class="has-line-data" data-line-start="2216" data-line-end="2221">
<p class="has-line-data" data-line-start="2216" data-line-end="2217"><strong>Полная поддержка итераторов:</strong></p>
<ul>
<li class="has-line-data" data-line-start="2218" data-line-end="2219">Включает стандартные, обратные и константные итераторы.</li>
<li class="has-line-data" data-line-start="2219" data-line-end="2221">Позволяет удобно перебирать элементы или применять стандартные алгоритмы STL.</li>
</ul>
</li>
</ol>
<hr>
<p class="has-line-data" data-line-start="2223" data-line-end="2224"><strong>Основные методы <code>std::list</code>:</strong></p>
<ol>
<li class="has-line-data" data-line-start="2225" data-line-end="2235">
<p class="has-line-data" data-line-start="2225" data-line-end="2226"><strong>Создание и инициализация:</strong></p>
<pre><code class="has-line-data" data-line-start="2228" data-line-end="2234" class="language-cpp"><span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span>
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">list</span>&lt;<span class="hljs-keyword">int</span>&gt; l1;                   <span class="hljs-comment">// пустой список</span>
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">list</span>&lt;<span class="hljs-keyword">int</span>&gt; l2(<span class="hljs-number">10</span>);               <span class="hljs-comment">// 10 элементов по умолчанию</span>
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">list</span>&lt;<span class="hljs-keyword">int</span>&gt; l3(<span class="hljs-number">10</span>, <span class="hljs-number">42</span>);           <span class="hljs-comment">// 10 элементов со значением 42</span>
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">list</span>&lt;<span class="hljs-keyword">int</span>&gt; l4 = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>};    <span class="hljs-comment">// список инициализации</span>
</code></pre>
</li>
<li class="has-line-data" data-line-start="2235" data-line-end="2252">
<p class="has-line-data" data-line-start="2235" data-line-end="2236"><strong>Добавление элементов:</strong></p>
<ul>
<li class="has-line-data" data-line-start="2237" data-line-end="2238"><code>push_back(value)</code>: добавляет элемент в конец.</li>
<li class="has-line-data" data-line-start="2238" data-line-end="2239"><code>push_front(value)</code>: добавляет элемент в начало.</li>
<li class="has-line-data" data-line-start="2239" data-line-end="2240"><code>emplace_back(args...)</code>: создаёт элемент в конце на месте.</li>
<li class="has-line-data" data-line-start="2240" data-line-end="2241"><code>emplace_front(args...)</code>: создаёт элемент в начале на месте.</li>
<li class="has-line-data" data-line-start="2241" data-line-end="2242"><code>insert(pos, value)</code>: вставляет элемент перед указанным итератором.</li>
<li class="has-line-data" data-line-start="2242" data-line-end="2244"><code>emplace(pos, args...)</code>: создаёт элемент на месте перед указанным итератором.</li>
</ul>
<pre><code class="has-line-data" data-line-start="2245" data-line-end="2251" class="language-cpp">l.push_back(<span class="hljs-number">10</span>);
l.push_front(<span class="hljs-number">20</span>);
l.emplace_back(<span class="hljs-number">30</span>);
l.emplace_front(<span class="hljs-number">40</span>);
l.insert(l.begin(), <span class="hljs-number">50</span>);
</code></pre>
</li>
<li class="has-line-data" data-line-start="2252" data-line-end="2267">
<p class="has-line-data" data-line-start="2252" data-line-end="2253"><strong>Удаление элементов:</strong></p>
<ul>
<li class="has-line-data" data-line-start="2254" data-line-end="2255"><code>pop_back()</code>: удаляет последний элемент.</li>
<li class="has-line-data" data-line-start="2255" data-line-end="2256"><code>pop_front()</code>: удаляет первый элемент.</li>
<li class="has-line-data" data-line-start="2256" data-line-end="2257"><code>erase(pos)</code>: удаляет элемент по итератору.</li>
<li class="has-line-data" data-line-start="2257" data-line-end="2258"><code>erase(first, last)</code>: удаляет диапазон элементов.</li>
<li class="has-line-data" data-line-start="2258" data-line-end="2260"><code>clear()</code>: удаляет все элементы.</li>
</ul>
<pre><code class="has-line-data" data-line-start="2261" data-line-end="2266" class="language-cpp">l.pop_back();
l.pop_front();
l.erase(l.begin());
l.clear();
</code></pre>
</li>
<li class="has-line-data" data-line-start="2267" data-line-end="2277">
<p class="has-line-data" data-line-start="2267" data-line-end="2268"><strong>Доступ к элементам:</strong></p>
<ul>
<li class="has-line-data" data-line-start="2269" data-line-end="2270"><code>front()</code>: возвращает ссылку на первый элемент.</li>
<li class="has-line-data" data-line-start="2270" data-line-end="2272"><code>back()</code>: возвращает ссылку на последний элемент.</li>
</ul>
<pre><code class="has-line-data" data-line-start="2273" data-line-end="2276" class="language-cpp"><span class="hljs-keyword">int</span> first = l.front();
<span class="hljs-keyword">int</span> last = l.back();
</code></pre>
</li>
<li class="has-line-data" data-line-start="2277" data-line-end="2289">
<p class="has-line-data" data-line-start="2277" data-line-end="2278"><strong>Проверка состояния:</strong></p>
<ul>
<li class="has-line-data" data-line-start="2279" data-line-end="2280"><code>empty()</code>: проверяет, пуст ли список.</li>
<li class="has-line-data" data-line-start="2280" data-line-end="2282"><code>size()</code>: возвращает количество элементов.</li>
</ul>
<pre><code class="has-line-data" data-line-start="2283" data-line-end="2288" class="language-cpp"><span class="hljs-keyword">if</span> (l.empty()) {
    <span class="hljs-comment">// список пуст</span>
}
<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> count = l.size();
</code></pre>
</li>
<li class="has-line-data" data-line-start="2289" data-line-end="2300">
<p class="has-line-data" data-line-start="2289" data-line-end="2290"><strong>Операции сортировки и объединения:</strong></p>
<ul>
<li class="has-line-data" data-line-start="2291" data-line-end="2292"><code>sort()</code>: сортирует элементы списка (по умолчанию в порядке возрастания).</li>
<li class="has-line-data" data-line-start="2292" data-line-end="2293"><code>merge(other_list)</code>: объединяет два отсортированных списка.</li>
<li class="has-line-data" data-line-start="2293" data-line-end="2294"><code>reverse()</code>: обращает порядок элементов.</li>
<li class="has-line-data" data-line-start="2294" data-line-end="2296"><code>unique()</code>: удаляет последовательные дублирующиеся элементы.</li>
</ul>
<pre><code class="has-line-data" data-line-start="2297" data-line-end="2300" class="language-cpp">l.sort();
l.reverse();
</code></pre>
</li>
</ol>
<hr>
<p class="has-line-data" data-line-start="2304" data-line-end="2305"><strong>Пример использования <code>std::list</code>:</strong></p>
<pre><code class="has-line-data" data-line-start="2307" data-line-end="2327" class="language-cpp"><span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">list</span>&lt;<span class="hljs-keyword">int</span>&gt; l = {<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>};

    <span class="hljs-comment">// Добавление и удаление элементов</span>
    l.push_back(<span class="hljs-number">50</span>);
    l.push_front(<span class="hljs-number">5</span>);
    l.pop_back();
    l.pop_front();

    <span class="hljs-comment">// Вывод элементов</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> n : l) {
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="hljs-string">" "</span>;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<hr>
<p class="has-line-data" data-line-start="2330" data-line-end="2332"><strong>Заключение:</strong><br>
<code>std::list</code> — это удобный инструмент для сценариев, где важна производительность вставки или удаления элементов в произвольных местах. Несмотря на отсутствие произвольного доступа по индексу, он широко применяется в задачах, требующих частого изменения структуры данных или использования итераторов.</p>
<p class="has-line-data" data-line-start="2334" data-line-end="2335"><strong>24. Контейнеры set, multiset. Библиотеки <code>&lt;set&gt;</code>, <code>&lt;multiset&gt;</code>: особенности, стандартные имена и методы.</strong></p>
<p class="has-line-data" data-line-start="2336" data-line-end="2338"><strong>Общее описание:</strong><br>
<code>std::set</code> и <code>std::multiset</code> — это ассоциативные контейнеры из стандартной библиотеки C++, которые обеспечивают автоматическую сортировку элементов и быстрый поиск.</p>
<ul>
<li class="has-line-data" data-line-start="2339" data-line-end="2340"><strong><code>std::set</code>:</strong> хранит уникальные элементы в отсортированном порядке.</li>
<li class="has-line-data" data-line-start="2340" data-line-end="2342"><strong><code>std::multiset</code>:</strong> допускает хранение нескольких экземпляров одного и того же значения, также в отсортированном порядке.</li>
</ul>
<p class="has-line-data" data-line-start="2342" data-line-end="2343">Оба контейнера реализованы на основе сбалансированных деревьев (обычно красно-чёрных), что обеспечивает логарифмическое время выполнения большинства операций.</p>
<hr>
<p class="has-line-data" data-line-start="2346" data-line-end="2347"><strong>Особенности <code>std::set</code>:</strong></p>
<ol>
<li class="has-line-data" data-line-start="2348" data-line-end="2352">
<p class="has-line-data" data-line-start="2348" data-line-end="2349"><strong>Уникальность элементов:</strong></p>
<ul>
<li class="has-line-data" data-line-start="2350" data-line-end="2351">Не допускает дублирования.</li>
<li class="has-line-data" data-line-start="2351" data-line-end="2352">Попытка вставить элемент, который уже существует, не изменяет контейнер.</li>
</ul>
</li>
<li class="has-line-data" data-line-start="2352" data-line-end="2356">
<p class="has-line-data" data-line-start="2352" data-line-end="2353"><strong>Отсортированность:</strong></p>
<ul>
<li class="has-line-data" data-line-start="2354" data-line-end="2355">Элементы автоматически упорядочиваются.</li>
<li class="has-line-data" data-line-start="2355" data-line-end="2356">По умолчанию используется оператор <code>&lt;</code> для сравнения, но можно предоставить пользовательский компаратор.</li>
</ul>
</li>
<li class="has-line-data" data-line-start="2356" data-line-end="2359">
<p class="has-line-data" data-line-start="2356" data-line-end="2357"><strong>Логарифмическая сложность:</strong></p>
<ul>
<li class="has-line-data" data-line-start="2358" data-line-end="2359">Вставка, удаление и поиск выполняются за O(log n).</li>
</ul>
</li>
<li class="has-line-data" data-line-start="2359" data-line-end="2364">
<p class="has-line-data" data-line-start="2359" data-line-end="2360"><strong>Итераторы:</strong></p>
<ul>
<li class="has-line-data" data-line-start="2361" data-line-end="2362">Поддерживает двунаправленные итераторы (не случайный доступ, как в векторах).</li>
<li class="has-line-data" data-line-start="2362" data-line-end="2364">Последовательность обхода соответствует порядку сортировки.</li>
</ul>
</li>
</ol>
<hr>
<p class="has-line-data" data-line-start="2366" data-line-end="2367"><strong>Особенности <code>std::multiset</code>:</strong></p>
<ol>
<li class="has-line-data" data-line-start="2368" data-line-end="2372">
<p class="has-line-data" data-line-start="2368" data-line-end="2369"><strong>Допустимы дублирующиеся элементы:</strong></p>
<ul>
<li class="has-line-data" data-line-start="2370" data-line-end="2371">Можно хранить несколько одинаковых значений.</li>
<li class="has-line-data" data-line-start="2371" data-line-end="2372">Удобно для подсчёта частоты элементов или хранения групп одинаковых данных.</li>
</ul>
</li>
<li class="has-line-data" data-line-start="2372" data-line-end="2376">
<p class="has-line-data" data-line-start="2372" data-line-end="2373"><strong>Отсортированность:</strong></p>
<ul>
<li class="has-line-data" data-line-start="2374" data-line-end="2375">Также элементы отсортированы по ключу.</li>
<li class="has-line-data" data-line-start="2375" data-line-end="2376">Порядок повторяющихся элементов может зависеть от реализации, но они следуют подряд.</li>
</ul>
</li>
<li class="has-line-data" data-line-start="2376" data-line-end="2380">
<p class="has-line-data" data-line-start="2376" data-line-end="2377"><strong>Сложность:</strong></p>
<ul>
<li class="has-line-data" data-line-start="2378" data-line-end="2380">Как и <code>std::set</code>, вставка, удаление и поиск занимают O(log n).</li>
</ul>
</li>
</ol>
<hr>
<p class="has-line-data" data-line-start="2382" data-line-end="2383"><strong>Стандартные методы <code>std::set</code> и <code>std::multiset</code>:</strong></p>
<ol>
<li class="has-line-data" data-line-start="2384" data-line-end="2393">
<p class="has-line-data" data-line-start="2384" data-line-end="2385"><strong>Создание и инициализация:</strong></p>
<pre><code class="has-line-data" data-line-start="2387" data-line-end="2392" class="language-cpp"><span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span>
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">set</span>&lt;<span class="hljs-keyword">int</span>&gt; s;                    <span class="hljs-comment">// пустой set</span>
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">set</span>&lt;<span class="hljs-keyword">int</span>&gt; s2 = {<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>};    <span class="hljs-comment">// список инициализации</span>
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">multiset</span>&lt;<span class="hljs-keyword">int</span>&gt; ms = {<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>}; <span class="hljs-comment">// multiset с дубликатами</span>
</code></pre>
</li>
<li class="has-line-data" data-line-start="2393" data-line-end="2404">
<p class="has-line-data" data-line-start="2393" data-line-end="2394"><strong>Вставка элементов:</strong></p>
<ul>
<li class="has-line-data" data-line-start="2395" data-line-end="2396"><code>insert(value)</code>: вставляет элемент.</li>
<li class="has-line-data" data-line-start="2396" data-line-end="2398"><code>emplace(args...)</code>: создаёт элемент на месте.</li>
</ul>
<pre><code class="has-line-data" data-line-start="2399" data-line-end="2403" class="language-cpp">s.insert(<span class="hljs-number">10</span>);
ms.insert(<span class="hljs-number">20</span>);
s.emplace(<span class="hljs-number">30</span>);
</code></pre>
</li>
<li class="has-line-data" data-line-start="2404" data-line-end="2415">
<p class="has-line-data" data-line-start="2404" data-line-end="2405"><strong>Удаление элементов:</strong></p>
<ul>
<li class="has-line-data" data-line-start="2406" data-line-end="2407"><code>erase(value)</code>: удаляет все элементы, равные <code>value</code>.</li>
<li class="has-line-data" data-line-start="2407" data-line-end="2408"><code>erase(it)</code>: удаляет элемент по итератору.</li>
<li class="has-line-data" data-line-start="2408" data-line-end="2410"><code>clear()</code>: очищает весь контейнер.</li>
</ul>
<pre><code class="has-line-data" data-line-start="2411" data-line-end="2414" class="language-cpp">s.erase(<span class="hljs-number">20</span>);
ms.erase(ms.find(<span class="hljs-number">20</span>));
</code></pre>
</li>
<li class="has-line-data" data-line-start="2415" data-line-end="2425">
<p class="has-line-data" data-line-start="2415" data-line-end="2416"><strong>Поиск элементов:</strong></p>
<ul>
<li class="has-line-data" data-line-start="2417" data-line-end="2418"><code>find(value)</code>: возвращает итератор на элемент или <code>end()</code>, если элемент не найден.</li>
<li class="has-line-data" data-line-start="2418" data-line-end="2420"><code>count(value)</code>: возвращает количество элементов с заданным значением (для <code>std::set</code> всегда 0 или 1).</li>
</ul>
<pre><code class="has-line-data" data-line-start="2421" data-line-end="2424" class="language-cpp"><span class="hljs-keyword">auto</span> it = s.find(<span class="hljs-number">10</span>);
<span class="hljs-keyword">if</span> (it != s.end()) { <span class="hljs-comment">/* элемент найден */</span> }
</code></pre>
</li>
<li class="has-line-data" data-line-start="2425" data-line-end="2435">
<p class="has-line-data" data-line-start="2425" data-line-end="2426"><strong>Обход элементов:</strong></p>
<ul>
<li class="has-line-data" data-line-start="2427" data-line-end="2428"><code>begin()</code>, <code>end()</code>: итераторы на начало и конец.</li>
<li class="has-line-data" data-line-start="2428" data-line-end="2430"><code>rbegin()</code>, <code>rend()</code>: обратные итераторы.</li>
</ul>
<pre><code class="has-line-data" data-line-start="2431" data-line-end="2435" class="language-cpp"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = s.begin(); it != s.end(); ++it) {
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="hljs-string">" "</span>;
}
</code></pre>
</li>
</ol>
<hr>
<p class="has-line-data" data-line-start="2439" data-line-end="2440"><strong>Пример работы с <code>std::set</code>:</strong></p>
<pre><code class="has-line-data" data-line-start="2442" data-line-end="2456" class="language-cpp"><span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">set</span>&lt;<span class="hljs-keyword">int</span>&gt; s = {<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>};
    s.insert(<span class="hljs-number">2</span>);
    s.erase(<span class="hljs-number">3</span>);

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> n : s) {
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="hljs-string">" "</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p class="has-line-data" data-line-start="2457" data-line-end="2458"><strong>Пример работы с <code>std::multiset</code>:</strong></p>
<pre><code class="has-line-data" data-line-start="2460" data-line-end="2473" class="language-cpp"><span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">multiset</span>&lt;<span class="hljs-keyword">int</span>&gt; ms = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>};
    ms.insert(<span class="hljs-number">2</span>);

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> n : ms) {
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="hljs-string">" "</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<hr>
<p class="has-line-data" data-line-start="2476" data-line-end="2478"><strong>Заключение:</strong><br>
<code>std::set</code> и <code>std::multiset</code> — удобные контейнеры для хранения отсортированных данных. Они обеспечивают уникальность элементов (в случае <code>std::set</code>) или возможность дублирования (в случае <code>std::multiset</code>). Логарифмическая сложность и автоматическая сортировка делают их идеальными для задач, связанных с поиском, упорядочиванием и обработкой множеств данных.</p>
<p class="has-line-data" data-line-start="2480" data-line-end="2481"><strong>25. Контейнер bitset. Библиотека <code>&lt;bitset&gt;</code>. Использование пар и кортежей.</strong></p>
<p class="has-line-data" data-line-start="2482" data-line-end="2484"><strong>Общее описание <code>std::bitset</code>:</strong><br>
<code>std::bitset</code> — это контейнер, предназначенный для работы с набором фиксированного числа битов. В отличие от традиционных битовых полей или переменных типа <code>unsigned int</code>, <code>std::bitset</code> предоставляет удобный и безопасный интерфейс для управления, доступа и выполнения операций с битами.</p>
<hr>
<p class="has-line-data" data-line-start="2487" data-line-end="2488"><strong>Особенности <code>std::bitset</code>:</strong></p>
<ol>
<li class="has-line-data" data-line-start="2489" data-line-end="2493">
<p class="has-line-data" data-line-start="2489" data-line-end="2490"><strong>Фиксированный размер:</strong></p>
<ul>
<li class="has-line-data" data-line-start="2491" data-line-end="2492">Размер задаётся на этапе компиляции и не может быть изменён во время выполнения.</li>
<li class="has-line-data" data-line-start="2492" data-line-end="2493">Это делает <code>std::bitset</code> эффективным для задач, где заранее известен размер битового массива.</li>
</ul>
</li>
<li class="has-line-data" data-line-start="2493" data-line-end="2497">
<p class="has-line-data" data-line-start="2493" data-line-end="2494"><strong>Битовое представление и доступ:</strong></p>
<ul>
<li class="has-line-data" data-line-start="2495" data-line-end="2496">Каждый бит доступен по индексу через оператор <code>[]</code> или методы, что упрощает его чтение и изменение.</li>
<li class="has-line-data" data-line-start="2496" data-line-end="2497">Поддерживаются стандартные операции побитового И, ИЛИ, НЕ, сдвиги и другие.</li>
</ul>
</li>
<li class="has-line-data" data-line-start="2497" data-line-end="2500">
<p class="has-line-data" data-line-start="2497" data-line-end="2498"><strong>Числовое и строковое представление:</strong></p>
<ul>
<li class="has-line-data" data-line-start="2499" data-line-end="2500">Биты можно конвертировать в целое число (<code>to_ulong()</code>) или строку (<code>to_string()</code>), что делает <code>std::bitset</code> удобным для преобразования данных.</li>
</ul>
</li>
<li class="has-line-data" data-line-start="2500" data-line-end="2504">
<p class="has-line-data" data-line-start="2500" data-line-end="2501"><strong>Безопасность:</strong></p>
<ul>
<li class="has-line-data" data-line-start="2502" data-line-end="2504">Использование методов <code>std::bitset</code> предотвращает выход за границы и другие типичные ошибки, связанные с управлением битами.</li>
</ul>
</li>
</ol>
<hr>
<p class="has-line-data" data-line-start="2506" data-line-end="2507"><strong>Основные методы <code>std::bitset</code>:</strong></p>
<ol>
<li class="has-line-data" data-line-start="2508" data-line-end="2517">
<p class="has-line-data" data-line-start="2508" data-line-end="2509"><strong>Создание и инициализация:</strong></p>
<pre><code class="has-line-data" data-line-start="2511" data-line-end="2516" class="language-cpp"><span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bitset&gt;</span></span>
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">bitset</span>&lt;8&gt; b1;                     <span class="hljs-comment">// Все биты обнулены</span>
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">bitset</span>&lt;8&gt; b2(<span class="hljs-string">"1101"</span>);             <span class="hljs-comment">// Из строкового представления</span>
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">bitset</span>&lt;8&gt; b3(<span class="hljs-number">0</span>b1010);             <span class="hljs-comment">// Из двоичного литерала</span>
</code></pre>
</li>
<li class="has-line-data" data-line-start="2517" data-line-end="2529">
<p class="has-line-data" data-line-start="2517" data-line-end="2518"><strong>Управление битами:</strong></p>
<ul>
<li class="has-line-data" data-line-start="2519" data-line-end="2520"><code>set(pos)</code>: Устанавливает бит в 1.</li>
<li class="has-line-data" data-line-start="2520" data-line-end="2521"><code>reset(pos)</code>: Устанавливает бит в 0.</li>
<li class="has-line-data" data-line-start="2521" data-line-end="2523"><code>flip(pos)</code>: Инвертирует значение бита.</li>
</ul>
<pre><code class="has-line-data" data-line-start="2524" data-line-end="2528" class="language-cpp">b1.<span class="hljs-built_in">set</span>(<span class="hljs-number">3</span>);
b2.reset(<span class="hljs-number">1</span>);
b3.flip(<span class="hljs-number">0</span>);
</code></pre>
</li>
<li class="has-line-data" data-line-start="2529" data-line-end="2539">
<p class="has-line-data" data-line-start="2529" data-line-end="2530"><strong>Доступ к битам:</strong></p>
<ul>
<li class="has-line-data" data-line-start="2531" data-line-end="2532"><code>operator[]</code>: Возвращает значение бита.</li>
<li class="has-line-data" data-line-start="2532" data-line-end="2534"><code>test(pos)</code>: Проверяет, установлен ли бит.</li>
</ul>
<pre><code class="has-line-data" data-line-start="2535" data-line-end="2538" class="language-cpp"><span class="hljs-keyword">bool</span> bitValue = b1[<span class="hljs-number">3</span>];
<span class="hljs-keyword">if</span> (b2.test(<span class="hljs-number">1</span>)) { <span class="hljs-comment">/* бит установлен */</span> }
</code></pre>
</li>
<li class="has-line-data" data-line-start="2539" data-line-end="2551">
<p class="has-line-data" data-line-start="2539" data-line-end="2540"><strong>Размер и проверка состояния:</strong></p>
<ul>
<li class="has-line-data" data-line-start="2541" data-line-end="2542"><code>size()</code>: Возвращает количество битов.</li>
<li class="has-line-data" data-line-start="2542" data-line-end="2543"><code>none()</code>: Возвращает <code>true</code>, если все биты равны 0.</li>
<li class="has-line-data" data-line-start="2543" data-line-end="2544"><code>any()</code>: Возвращает <code>true</code>, если хотя бы один бит равен 1.</li>
<li class="has-line-data" data-line-start="2544" data-line-end="2546"><code>all()</code>: Возвращает <code>true</code>, если все биты равны 1.</li>
</ul>
<pre><code class="has-line-data" data-line-start="2547" data-line-end="2550" class="language-cpp"><span class="hljs-keyword">if</span> (b1.any()) { <span class="hljs-comment">/* хотя бы один бит установлен */</span> }
<span class="hljs-keyword">if</span> (b2.none()) { <span class="hljs-comment">/* все биты равны 0 */</span> }
</code></pre>
</li>
<li class="has-line-data" data-line-start="2551" data-line-end="2560">
<p class="has-line-data" data-line-start="2551" data-line-end="2552"><strong>Преобразование:</strong></p>
<ul>
<li class="has-line-data" data-line-start="2553" data-line-end="2554"><code>to_ulong()</code>: Преобразует в <code>unsigned long</code>.</li>
<li class="has-line-data" data-line-start="2554" data-line-end="2556"><code>to_string()</code>: Возвращает строковое представление битов.</li>
</ul>
<pre><code class="has-line-data" data-line-start="2557" data-line-end="2560" class="language-cpp"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> bitStr = b1.to_string();
<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> num = b2.to_ulong();
</code></pre>
</li>
</ol>
<hr>
<p class="has-line-data" data-line-start="2564" data-line-end="2565"><strong>Пример использования <code>std::bitset</code>:</strong></p>
<pre><code class="has-line-data" data-line-start="2567" data-line-end="2581" class="language-cpp"><span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bitset&gt;</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">bitset</span>&lt;8&gt; bits(<span class="hljs-string">"11001100"</span>);
    bits.<span class="hljs-built_in">set</span>(<span class="hljs-number">1</span>);
    bits.reset(<span class="hljs-number">7</span>);
    bits.flip(<span class="hljs-number">0</span>);

    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Bits: "</span> &lt;&lt; bits &lt;&lt; <span class="hljs-string">'\n'</span>;
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"As number: "</span> &lt;&lt; bits.to_ulong() &lt;&lt; <span class="hljs-string">'\n'</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<hr>
<p class="has-line-data" data-line-start="2584" data-line-end="2585"><strong>Пары (<code>std::pair</code>) и кортежи (<code>std::tuple</code>):</strong></p>
<ol>
<li class="has-line-data" data-line-start="2586" data-line-end="2606">
<p class="has-line-data" data-line-start="2586" data-line-end="2587"><strong><code>std::pair</code>:</strong></p>
<ul>
<li class="has-line-data" data-line-start="2588" data-line-end="2589">Простая структура для хранения двух связанных значений.</li>
<li class="has-line-data" data-line-start="2589" data-line-end="2591">Часто используется для возвращения двух значений из функции или представления ключа и значения.</li>
</ul>
<p class="has-line-data" data-line-start="2591" data-line-end="2592"><strong>Создание пары:</strong></p>
<pre><code class="has-line-data" data-line-start="2594" data-line-end="2598" class="language-cpp"><span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span></span>
<span class="hljs-built_in">std</span>::pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt; p1 = <span class="hljs-built_in">std</span>::make_pair(<span class="hljs-number">1</span>, <span class="hljs-string">"Hello"</span>);
<span class="hljs-keyword">auto</span> p2 = <span class="hljs-built_in">std</span>::make_pair(<span class="hljs-number">42</span>, <span class="hljs-number">3.14</span>);
</code></pre>
<p class="has-line-data" data-line-start="2599" data-line-end="2600"><strong>Доступ к элементам пары:</strong></p>
<pre><code class="has-line-data" data-line-start="2602" data-line-end="2605" class="language-cpp"><span class="hljs-keyword">int</span> id = p1.first;
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> message = p1.second;
</code></pre>
</li>
<li class="has-line-data" data-line-start="2606" data-line-end="2626">
<p class="has-line-data" data-line-start="2606" data-line-end="2607"><strong><code>std::tuple</code>:</strong></p>
<ul>
<li class="has-line-data" data-line-start="2608" data-line-end="2609">Расширение <code>std::pair</code> для хранения нескольких элементов разного типа.</li>
<li class="has-line-data" data-line-start="2609" data-line-end="2611">Идеально подходит для возвращения нескольких значений из функции.</li>
</ul>
<p class="has-line-data" data-line-start="2611" data-line-end="2612"><strong>Создание кортежа:</strong></p>
<pre><code class="has-line-data" data-line-start="2614" data-line-end="2618" class="language-cpp"><span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;tuple&gt;</span></span>
<span class="hljs-built_in">std</span>::tuple&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span>, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt; t1 = <span class="hljs-built_in">std</span>::make_tuple(<span class="hljs-number">1</span>, <span class="hljs-number">3.14</span>, <span class="hljs-string">"Hello"</span>);
<span class="hljs-keyword">auto</span> t2 = <span class="hljs-built_in">std</span>::make_tuple(<span class="hljs-number">42</span>, <span class="hljs-string">'A'</span>, <span class="hljs-string">"World"</span>);
</code></pre>
<p class="has-line-data" data-line-start="2619" data-line-end="2620"><strong>Доступ к элементам кортежа:</strong></p>
<pre><code class="has-line-data" data-line-start="2622" data-line-end="2626" class="language-cpp"><span class="hljs-keyword">int</span> id = <span class="hljs-built_in">std</span>::get&lt;<span class="hljs-number">0</span>&gt;(t1);
<span class="hljs-keyword">double</span> value = <span class="hljs-built_in">std</span>::get&lt;<span class="hljs-number">1</span>&gt;(t1);
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> text = <span class="hljs-built_in">std</span>::get&lt;<span class="hljs-number">2</span>&gt;(t1);
</code></pre>
</li>
</ol>
<hr>
<p class="has-line-data" data-line-start="2630" data-line-end="2631"><strong>Заключение:</strong></p>
<ul>
<li class="has-line-data" data-line-start="2632" data-line-end="2633"><code>std::bitset</code> — удобный инструмент для работы с битовыми данными, предоставляющий простой интерфейс и функции для манипуляций.</li>
<li class="has-line-data" data-line-start="2633" data-line-end="2634"><code>std::pair</code> и <code>std::tuple</code> расширяют возможности стандартной библиотеки, позволяя работать с группами значений разных типов. Вместе они помогают писать более удобный и безопасный код.</li>
</ul>
<p class="has-line-data" data-line-start="2636" data-line-end="2637"><strong>26. Контейнеры map, multimap. Библиотеки <code>&lt;map&gt;</code>, <code>&lt;multimap&gt;</code>: особенности, стандартные имена и методы.</strong></p>
<p class="has-line-data" data-line-start="2638" data-line-end="2640"><strong>Общее описание:</strong><br>
<code>std::map</code> и <code>std::multimap</code> — это ассоциативные контейнеры из стандартной библиотеки C++, предназначенные для хранения пар ключ-значение.</p>
<ul>
<li class="has-line-data" data-line-start="2641" data-line-end="2642"><strong><code>std::map</code>:</strong> каждый ключ уникален; при вставке нового элемента с существующим ключом, старый элемент будет заменён.</li>
<li class="has-line-data" data-line-start="2642" data-line-end="2644"><strong><code>std::multimap</code>:</strong> допускает хранение нескольких элементов с одинаковыми ключами.</li>
</ul>
<p class="has-line-data" data-line-start="2644" data-line-end="2645">Оба контейнера реализованы на основе сбалансированных деревьев (обычно красно-чёрных), что обеспечивает логарифмическое время выполнения операций вставки, удаления и поиска.</p>
<hr>
<p class="has-line-data" data-line-start="2648" data-line-end="2649"><strong>Особенности <code>std::map</code>:</strong></p>
<ol>
<li class="has-line-data" data-line-start="2650" data-line-end="2653">
<p class="has-line-data" data-line-start="2650" data-line-end="2651"><strong>Уникальные ключи:</strong></p>
<ul>
<li class="has-line-data" data-line-start="2652" data-line-end="2653">Ключи должны быть уникальными; если попытаться вставить пару с уже существующим ключом, значение по этому ключу будет перезаписано.</li>
</ul>
</li>
<li class="has-line-data" data-line-start="2653" data-line-end="2657">
<p class="has-line-data" data-line-start="2653" data-line-end="2654"><strong>Сортировка:</strong></p>
<ul>
<li class="has-line-data" data-line-start="2655" data-line-end="2656">Элементы автоматически упорядочиваются по ключу.</li>
<li class="has-line-data" data-line-start="2656" data-line-end="2657">По умолчанию используется оператор <code>&lt;</code> для сравнения ключей, но можно передать пользовательский компаратор.</li>
</ul>
</li>
<li class="has-line-data" data-line-start="2657" data-line-end="2661">
<p class="has-line-data" data-line-start="2657" data-line-end="2658"><strong>Итераторы:</strong></p>
<ul>
<li class="has-line-data" data-line-start="2659" data-line-end="2660">Поддерживаются двунаправленные итераторы.</li>
<li class="has-line-data" data-line-start="2660" data-line-end="2661">Порядок итерации соответствует порядку сортировки ключей.</li>
</ul>
</li>
<li class="has-line-data" data-line-start="2661" data-line-end="2665">
<p class="has-line-data" data-line-start="2661" data-line-end="2662"><strong>Логарифмическая сложность:</strong></p>
<ul>
<li class="has-line-data" data-line-start="2663" data-line-end="2665">Основные операции (вставка, удаление, поиск) выполняются за O(log n).</li>
</ul>
</li>
</ol>
<hr>
<p class="has-line-data" data-line-start="2667" data-line-end="2668"><strong>Особенности <code>std::multimap</code>:</strong></p>
<ol>
<li class="has-line-data" data-line-start="2669" data-line-end="2673">
<p class="has-line-data" data-line-start="2669" data-line-end="2670"><strong>Повторяющиеся ключи:</strong></p>
<ul>
<li class="has-line-data" data-line-start="2671" data-line-end="2672">Один и тот же ключ может встречаться несколько раз.</li>
<li class="has-line-data" data-line-start="2672" data-line-end="2673">Это полезно для хранения групп значений, связанных с одним ключом.</li>
</ul>
</li>
<li class="has-line-data" data-line-start="2673" data-line-end="2676">
<p class="has-line-data" data-line-start="2673" data-line-end="2674"><strong>Сортировка:</strong></p>
<ul>
<li class="has-line-data" data-line-start="2675" data-line-end="2676">Элементы сортируются по ключу так же, как в <code>std::map</code>.</li>
</ul>
</li>
<li class="has-line-data" data-line-start="2676" data-line-end="2681">
<p class="has-line-data" data-line-start="2676" data-line-end="2677"><strong>Итераторы:</strong></p>
<ul>
<li class="has-line-data" data-line-start="2678" data-line-end="2679">Как и <code>std::map</code>, поддерживает двунаправленные итераторы.</li>
<li class="has-line-data" data-line-start="2679" data-line-end="2681">Итераторы проходят по всем элементам, включая дубликаты.</li>
</ul>
</li>
</ol>
<hr>
<p class="has-line-data" data-line-start="2683" data-line-end="2684"><strong>Основные методы <code>std::map</code> и <code>std::multimap</code>:</strong></p>
<ol>
<li class="has-line-data" data-line-start="2685" data-line-end="2693">
<p class="has-line-data" data-line-start="2685" data-line-end="2686"><strong>Создание и инициализация:</strong></p>
<pre><code class="has-line-data" data-line-start="2688" data-line-end="2692" class="language-cpp"><span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span>
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt; m;
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">multimap</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt; mm;
</code></pre>
</li>
<li class="has-line-data" data-line-start="2693" data-line-end="2705">
<p class="has-line-data" data-line-start="2693" data-line-end="2694"><strong>Вставка элементов:</strong></p>
<ul>
<li class="has-line-data" data-line-start="2695" data-line-end="2696"><code>insert(pair)</code>: вставляет пару ключ-значение.</li>
<li class="has-line-data" data-line-start="2696" data-line-end="2698"><code>emplace(args...)</code>: создаёт элемент на месте.</li>
</ul>
<pre><code class="has-line-data" data-line-start="2699" data-line-end="2704" class="language-cpp">m.insert({<span class="hljs-number">1</span>, <span class="hljs-string">"one"</span>});
m.emplace(<span class="hljs-number">2</span>, <span class="hljs-string">"two"</span>);
mm.insert({<span class="hljs-number">1</span>, <span class="hljs-string">"one"</span>});
mm.insert({<span class="hljs-number">1</span>, <span class="hljs-string">"another one"</span>});
</code></pre>
</li>
<li class="has-line-data" data-line-start="2705" data-line-end="2715">
<p class="has-line-data" data-line-start="2705" data-line-end="2706"><strong>Доступ к элементам:</strong></p>
<ul>
<li class="has-line-data" data-line-start="2707" data-line-end="2708"><code>operator[key]</code>: доступ к значению по ключу (только для <code>std::map</code>). Если ключ не существует, создаётся новый элемент.</li>
<li class="has-line-data" data-line-start="2708" data-line-end="2710"><code>at(key)</code>: доступ к значению по ключу с проверкой.</li>
</ul>
<pre><code class="has-line-data" data-line-start="2711" data-line-end="2714" class="language-cpp"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> val = m[<span class="hljs-number">1</span>];
val = m.at(<span class="hljs-number">2</span>);
</code></pre>
</li>
<li class="has-line-data" data-line-start="2715" data-line-end="2725">
<p class="has-line-data" data-line-start="2715" data-line-end="2716"><strong>Поиск элементов:</strong></p>
<ul>
<li class="has-line-data" data-line-start="2717" data-line-end="2718"><code>find(key)</code>: возвращает итератор на элемент или <code>end()</code>, если элемент не найден.</li>
<li class="has-line-data" data-line-start="2718" data-line-end="2720"><code>count(key)</code>: возвращает количество элементов с данным ключом (для <code>std::map</code> всегда 0 или 1).</li>
</ul>
<pre><code class="has-line-data" data-line-start="2721" data-line-end="2724" class="language-cpp"><span class="hljs-keyword">auto</span> it = m.find(<span class="hljs-number">1</span>);
<span class="hljs-keyword">if</span> (it != m.end()) { <span class="hljs-comment">/* элемент найден */</span> }
</code></pre>
</li>
<li class="has-line-data" data-line-start="2725" data-line-end="2737">
<p class="has-line-data" data-line-start="2725" data-line-end="2726"><strong>Диапазон значений:</strong></p>
<ul>
<li class="has-line-data" data-line-start="2727" data-line-end="2728"><code>equal_range(key)</code>: возвращает диапазон итераторов на все элементы с данным ключом.</li>
<li class="has-line-data" data-line-start="2728" data-line-end="2730">Особенно полезно для <code>std::multimap</code> при обработке дубликатов.</li>
</ul>
<pre><code class="has-line-data" data-line-start="2731" data-line-end="2736" class="language-cpp"><span class="hljs-keyword">auto</span> range = mm.equal_range(<span class="hljs-number">1</span>);
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = range.first; it != range.second; ++it) {
    <span class="hljs-comment">// обрабатываем элементы с ключом 1</span>
}
</code></pre>
</li>
<li class="has-line-data" data-line-start="2737" data-line-end="2748">
<p class="has-line-data" data-line-start="2737" data-line-end="2738"><strong>Удаление элементов:</strong></p>
<ul>
<li class="has-line-data" data-line-start="2739" data-line-end="2740"><code>erase(it)</code>: удаляет элемент по итератору.</li>
<li class="has-line-data" data-line-start="2740" data-line-end="2741"><code>erase(key)</code>: удаляет элементы с данным ключом.</li>
<li class="has-line-data" data-line-start="2741" data-line-end="2743"><code>clear()</code>: удаляет все элементы.</li>
</ul>
<pre><code class="has-line-data" data-line-start="2744" data-line-end="2747" class="language-cpp">m.erase(<span class="hljs-number">1</span>);
mm.erase(mm.begin());
</code></pre>
</li>
<li class="has-line-data" data-line-start="2748" data-line-end="2758">
<p class="has-line-data" data-line-start="2748" data-line-end="2749"><strong>Размер и состояние:</strong></p>
<ul>
<li class="has-line-data" data-line-start="2750" data-line-end="2751"><code>empty()</code>: проверяет, пуст ли контейнер.</li>
<li class="has-line-data" data-line-start="2751" data-line-end="2753"><code>size()</code>: возвращает количество элементов.</li>
</ul>
<pre><code class="has-line-data" data-line-start="2754" data-line-end="2758" class="language-cpp"><span class="hljs-keyword">if</span> (m.empty()) {
    <span class="hljs-comment">// контейнер пуст</span>
}
</code></pre>
</li>
</ol>
<hr>
<p class="has-line-data" data-line-start="2762" data-line-end="2763"><strong>Пример работы с <code>std::map</code>:</strong></p>
<pre><code class="has-line-data" data-line-start="2765" data-line-end="2781" class="language-cpp"><span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt; m;
    m[<span class="hljs-number">1</span>] = <span class="hljs-string">"one"</span>;
    m[<span class="hljs-number">2</span>] = <span class="hljs-string">"two"</span>;
    m[<span class="hljs-number">3</span>] = <span class="hljs-string">"three"</span>;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; [key, value] : m) {
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; key &lt;&lt; <span class="hljs-string">": "</span> &lt;&lt; value &lt;&lt; <span class="hljs-string">'\n'</span>;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p class="has-line-data" data-line-start="2782" data-line-end="2783"><strong>Пример работы с <code>std::multimap</code>:</strong></p>
<pre><code class="has-line-data" data-line-start="2785" data-line-end="2801" class="language-cpp"><span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">multimap</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt; mm;
    mm.insert({<span class="hljs-number">1</span>, <span class="hljs-string">"one"</span>});
    mm.insert({<span class="hljs-number">1</span>, <span class="hljs-string">"another one"</span>});
    mm.insert({<span class="hljs-number">2</span>, <span class="hljs-string">"two"</span>});

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; [key, value] : mm) {
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; key &lt;&lt; <span class="hljs-string">": "</span> &lt;&lt; value &lt;&lt; <span class="hljs-string">'\n'</span>;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<hr>
<p class="has-line-data" data-line-start="2804" data-line-end="2806"><strong>Заключение:</strong><br>
<code>std::map</code> и <code>std::multimap</code> — мощные инструменты для работы с отсортированными парами ключ-значение. Они обеспечивают эффективный поиск и вставку, что делает их подходящими для множества задач, связанных с обработкой и упорядочиванием данных.</p>
<p class="has-line-data" data-line-start="2808" data-line-end="2809"><strong>27. Принципы использования аллокаторов для работы с контейнерами.</strong></p>
<p class="has-line-data" data-line-start="2810" data-line-end="2811"><strong>Общее описание:</strong> Аллокаторы в C++ — это механизмы, определяющие, каким образом память выделяется и освобождается. Стандартные контейнеры STL, такие как <code>std::vector</code>, <code>std::list</code>, <code>std::map</code>, используют аллокаторы для управления памятью, предоставляя разработчику гибкость в выборе стратегий работы с памятью.</p>
<p class="has-line-data" data-line-start="2812" data-line-end="2813"><strong>Основные принципы:</strong></p>
<ol>
<li class="has-line-data" data-line-start="2814" data-line-end="2820">
<p class="has-line-data" data-line-start="2814" data-line-end="2816"><strong>Стандартный аллокатор (<code>std::allocator</code>):</strong><br>
По умолчанию контейнеры используют <code>std::allocator</code>. Это общий аллокатор, предоставляемый стандартной библиотекой, который:</p>
<ul>
<li class="has-line-data" data-line-start="2817" data-line-end="2818">Работает через <code>new</code> и <code>delete</code>.</li>
<li class="has-line-data" data-line-start="2818" data-line-end="2819">Поддерживает конструкцию и разрушение объектов.</li>
<li class="has-line-data" data-line-start="2819" data-line-end="2820">Имеет стабильное, предсказуемое поведение и обеспечивает хорошую совместимость между разными стандартными контейнерами.</li>
</ul>
</li>
<li class="has-line-data" data-line-start="2820" data-line-end="2826">
<p class="has-line-data" data-line-start="2820" data-line-end="2822"><strong>Кастомные аллокаторы:</strong><br>
Если требуется нестандартное поведение, можно определить свой собственный аллокатор, реализующий интерфейс, совместимый с <code>std::allocator</code>. Например:</p>
<ul>
<li class="has-line-data" data-line-start="2823" data-line-end="2824">Выделение памяти из заранее подготовленного блока (пула памяти).</li>
<li class="has-line-data" data-line-start="2824" data-line-end="2825">Отслеживание выделений для отладки или мониторинга.</li>
<li class="has-line-data" data-line-start="2825" data-line-end="2826">Оптимизация под особенности аппаратного окружения (например, использование выровненной памяти).</li>
</ul>
</li>
<li class="has-line-data" data-line-start="2826" data-line-end="2838">
<p class="has-line-data" data-line-start="2826" data-line-end="2828"><strong>Интерфейс аллокатора:</strong><br>
Кастомный аллокатор должен предоставлять определённый набор типов и методов:</p>
<ul>
<li class="has-line-data" data-line-start="2829" data-line-end="2833"><strong>Типы:</strong>
<ul>
<li class="has-line-data" data-line-start="2830" data-line-end="2831"><code>value_type</code>: тип объектов, управляемых аллокатором.</li>
<li class="has-line-data" data-line-start="2831" data-line-end="2832"><code>pointer</code>, <code>const_pointer</code>, <code>void_pointer</code>: указатели на управляемую память.</li>
<li class="has-line-data" data-line-start="2832" data-line-end="2833"><code>size_type</code>, <code>difference_type</code>: типы для измерения размеров и различий в памяти.</li>
</ul>
</li>
<li class="has-line-data" data-line-start="2833" data-line-end="2838"><strong>Методы:</strong>
<ul>
<li class="has-line-data" data-line-start="2834" data-line-end="2835"><code>allocate(size_t n)</code>: выделяет память для <code>n</code> объектов.</li>
<li class="has-line-data" data-line-start="2835" data-line-end="2836"><code>deallocate(pointer p, size_t n)</code>: освобождает ранее выделенную память.</li>
<li class="has-line-data" data-line-start="2836" data-line-end="2837"><code>construct(pointer p, Args&amp;&amp;... args)</code>: конструирует объект в указанной памяти.</li>
<li class="has-line-data" data-line-start="2837" data-line-end="2838"><code>destroy(pointer p)</code>: разрушает объект.</li>
</ul>
</li>
</ul>
</li>
<li class="has-line-data" data-line-start="2838" data-line-end="2843">
<p class="has-line-data" data-line-start="2838" data-line-end="2839"><strong>Преимущества кастомных аллокаторов:</strong></p>
<ul>
<li class="has-line-data" data-line-start="2840" data-line-end="2841">Более точный контроль над производительностью.</li>
<li class="has-line-data" data-line-start="2841" data-line-end="2842">Возможность реализации сложных моделей распределения памяти (например, memory pools).</li>
<li class="has-line-data" data-line-start="2842" data-line-end="2843">Улучшение предсказуемости программы за счёт заранее заданных политик выделения памяти.</li>
</ul>
</li>
<li class="has-line-data" data-line-start="2843" data-line-end="2877">
<p class="has-line-data" data-line-start="2843" data-line-end="2845"><strong>Пример кастомного аллокатора:</strong><br>
Вот пример упрощённого кастомного аллокатора, который отслеживает количество выделений:</p>
<pre><code class="has-line-data" data-line-start="2847" data-line-end="2874" class="language-cpp">#include &lt;memory&gt;
#include &lt;iostream&gt;

template &lt;typename T&gt;
struct MyAllocator {
    using value_type = T;

    MyAllocator() = default;

    T* allocate(std::size_t n) {
        std::cout &lt;&lt; "Allocating " &lt;&lt; n &lt;&lt; " elements\n";
        return static_cast&lt;T*&gt;(::operator new(n * sizeof(T)));
    }

    void deallocate(T* p, std::size_t n) {
        std::cout &lt;&lt; "Deallocating " &lt;&lt; n &lt;&lt; " elements\n";
        ::operator delete(p);
    }
};

int main() {
    std::vector&lt;int, MyAllocator&lt;int&gt;&gt; v;
    v.push_back(1);
    v.push_back(2);
    return 0;
}
</code></pre>
<p class="has-line-data" data-line-start="2875" data-line-end="2876">Этот аллокатор использует глобальный оператор <code>new</code> и <code>delete</code>, но добавляет сообщение в консоль каждый раз, когда выделяется или освобождается память.</p>
</li>
<li class="has-line-data" data-line-start="2877" data-line-end="2889">
<p class="has-line-data" data-line-start="2877" data-line-end="2878"><strong>Применение аллокаторов в контейнерах:</strong></p>
<ul>
<li class="has-line-data" data-line-start="2879" data-line-end="2886">
<p class="has-line-data" data-line-start="2879" data-line-end="2881"><strong>Передача аллокатора:</strong><br>
Контейнеры принимают аллокатор в качестве второго шаблонного аргумента:</p>
<pre><code class="has-line-data" data-line-start="2883" data-line-end="2885" class="language-cpp"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>, MyAllocator&lt;<span class="hljs-keyword">int</span>&gt;&gt; v;
</code></pre>
</li>
<li class="has-line-data" data-line-start="2886" data-line-end="2889">
<p class="has-line-data" data-line-start="2886" data-line-end="2888"><strong>Переносимость:</strong><br>
Кастомный аллокатор должен быть совместим с требованиями стандартной библиотеки, чтобы обеспечить корректную работу контейнеров.</p>
</li>
</ul>
</li>
</ol>
<hr>
<p class="has-line-data" data-line-start="2891" data-line-end="2893"><strong>Заключение:</strong><br>
Аллокаторы обеспечивают гибкость и контроль при работе с памятью в стандартных контейнерах STL. Использование кастомных аллокаторов оправдано, когда стандартный <code>std::allocator</code> не подходит для специфических требований к производительности, отладке или особенностям платформы.</p>
<p class="has-line-data" data-line-start="2895" data-line-end="2896"><strong>28. Принципы использования итераторов для работы с контейнерами.</strong></p>
<p class="has-line-data" data-line-start="2897" data-line-end="2899"><strong>Общее описание:</strong><br>
Итераторы — это объекты, предоставляющие унифицированный способ обхода элементов контейнера и работы с ними. Они абстрагируют внутреннюю структуру контейнера, позволяя использовать стандартные алгоритмы STL без необходимости знать, как конкретно организованы данные внутри контейнера. Итераторы напоминают указатели, но предоставляют более широкие возможности и лучшее соответствие принципам STL.</p>
<hr>
<p class="has-line-data" data-line-start="2902" data-line-end="2903"><strong>Классификация итераторов:</strong></p>
<ol>
<li class="has-line-data" data-line-start="2904" data-line-end="2908">
<p class="has-line-data" data-line-start="2904" data-line-end="2905"><strong>InputIterator и OutputIterator:</strong></p>
<ul>
<li class="has-line-data" data-line-start="2906" data-line-end="2907">InputIterator: обеспечивает последовательный доступ к элементам контейнера для чтения.</li>
<li class="has-line-data" data-line-start="2907" data-line-end="2908">OutputIterator: обеспечивает запись в элементы контейнера.</li>
</ul>
</li>
<li class="has-line-data" data-line-start="2908" data-line-end="2912">
<p class="has-line-data" data-line-start="2908" data-line-end="2909"><strong>ForwardIterator:</strong></p>
<ul>
<li class="has-line-data" data-line-start="2910" data-line-end="2911">Позволяет перемещаться вперёд по элементам контейнера и считывать данные несколько раз.</li>
<li class="has-line-data" data-line-start="2911" data-line-end="2912">Часто используется в односвязных списках или других контейнерах, где обратный доступ невозможен.</li>
</ul>
</li>
<li class="has-line-data" data-line-start="2912" data-line-end="2916">
<p class="has-line-data" data-line-start="2912" data-line-end="2913"><strong>BidirectionalIterator:</strong></p>
<ul>
<li class="has-line-data" data-line-start="2914" data-line-end="2915">Поддерживает перемещение в обоих направлениях (вперёд и назад).</li>
<li class="has-line-data" data-line-start="2915" data-line-end="2916">Используется в двусвязных списках или ассоциативных контейнерах.</li>
</ul>
</li>
<li class="has-line-data" data-line-start="2916" data-line-end="2921">
<p class="has-line-data" data-line-start="2916" data-line-end="2917"><strong>RandomAccessIterator:</strong></p>
<ul>
<li class="has-line-data" data-line-start="2918" data-line-end="2919">Предоставляет произвольный доступ, включая арифметические операции (например, <code>it + n</code>, <code>it[n]</code>).</li>
<li class="has-line-data" data-line-start="2919" data-line-end="2921">Обычно используется в <code>std::vector</code> или <code>std::deque</code>, где элементы расположены последовательно в памяти.</li>
</ul>
</li>
</ol>
<hr>
<p class="has-line-data" data-line-start="2923" data-line-end="2924"><strong>Использование итераторов:</strong></p>
<ol>
<li class="has-line-data" data-line-start="2925" data-line-end="2941">
<p class="has-line-data" data-line-start="2925" data-line-end="2926"><strong>Получение итераторов из контейнера:</strong></p>
<ul>
<li class="has-line-data" data-line-start="2927" data-line-end="2928"><code>begin()</code>: возвращает итератор на первый элемент.</li>
<li class="has-line-data" data-line-start="2928" data-line-end="2929"><code>end()</code>: возвращает итератор за последним элементом.</li>
<li class="has-line-data" data-line-start="2929" data-line-end="2930"><code>rbegin()</code> и <code>rend()</code>: возвращают обратные итераторы.</li>
<li class="has-line-data" data-line-start="2930" data-line-end="2932"><code>cbegin()</code> и <code>cend()</code>: возвращают константные итераторы.</li>
</ul>
<pre><code class="has-line-data" data-line-start="2933" data-line-end="2940" class="language-cpp"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>};
<span class="hljs-keyword">auto</span> it = v.begin();
<span class="hljs-keyword">while</span> (it != v.end()) {
    <span class="hljs-comment">// Работа с элементом *it</span>
    ++it;
}
</code></pre>
</li>
<li class="has-line-data" data-line-start="2941" data-line-end="2958">
<p class="has-line-data" data-line-start="2941" data-line-end="2943"><strong>Обход элементов с помощью итераторов:</strong><br>
Итераторы используются в циклах для доступа к элементам контейнера.</p>
<pre><code class="has-line-data" data-line-start="2945" data-line-end="2949" class="language-cpp"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = v.begin(); it != v.end(); ++it) {
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="hljs-string">" "</span>;
}
</code></pre>
<p class="has-line-data" data-line-start="2950" data-line-end="2951">Или с использованием диапазонных циклов:</p>
<pre><code class="has-line-data" data-line-start="2953" data-line-end="2957" class="language-cpp"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; elem : v) {
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; elem &lt;&lt; <span class="hljs-string">" "</span>;
}
</code></pre>
</li>
<li class="has-line-data" data-line-start="2958" data-line-end="2967">
<p class="has-line-data" data-line-start="2958" data-line-end="2960"><strong>Модификация элементов через итераторы:</strong><br>
Итераторы можно использовать не только для чтения, но и для изменения элементов.</p>
<pre><code class="has-line-data" data-line-start="2962" data-line-end="2966" class="language-cpp"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = v.begin(); it != v.end(); ++it) {
    *it *= <span class="hljs-number">2</span>; <span class="hljs-comment">// Умножаем каждый элемент на 2</span>
}
</code></pre>
</li>
<li class="has-line-data" data-line-start="2967" data-line-end="2978">
<p class="has-line-data" data-line-start="2967" data-line-end="2969"><strong>Использование с алгоритмами STL:</strong><br>
Итераторы позволяют применять стандартные алгоритмы, такие как <code>std::sort</code>, <code>std::find</code>, <code>std::copy</code>.</p>
<pre><code class="has-line-data" data-line-start="2971" data-line-end="2977" class="language-cpp"><span class="hljs-built_in">std</span>::sort(v.begin(), v.end());
<span class="hljs-keyword">auto</span> it = <span class="hljs-built_in">std</span>::find(v.begin(), v.end(), <span class="hljs-number">3</span>);
<span class="hljs-keyword">if</span> (it != v.end()) {
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Found: "</span> &lt;&lt; *it &lt;&lt; <span class="hljs-built_in">std</span>::endl;
}
</code></pre>
</li>
<li class="has-line-data" data-line-start="2978" data-line-end="2989">
<p class="has-line-data" data-line-start="2978" data-line-end="2979"><strong>Различие между обычными и константными итераторами:</strong></p>
<ul>
<li class="has-line-data" data-line-start="2980" data-line-end="2981">Константные итераторы (<code>const_iterator</code>) не позволяют изменять элементы контейнера.</li>
<li class="has-line-data" data-line-start="2981" data-line-end="2983">Они полезны, когда требуется только чтение и нужно предотвратить случайное изменение данных.</li>
</ul>
<pre><code class="has-line-data" data-line-start="2984" data-line-end="2989" class="language-cpp"><span class="hljs-keyword">for</span> (<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;::const_iterator it = v.cbegin(); it != v.cend(); ++it) {
    <span class="hljs-comment">// *it = 10; // ошибка, нельзя изменить элемент</span>
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="hljs-string">" "</span>;
}
</code></pre>
</li>
</ol>
<hr>
<p class="has-line-data" data-line-start="2993" data-line-end="2994"><strong>Преимущества использования итераторов:</strong></p>
<ol>
<li class="has-line-data" data-line-start="2995" data-line-end="2998">
<p class="has-line-data" data-line-start="2995" data-line-end="2997"><strong>Унифицированный интерфейс:</strong><br>
Итераторы предоставляют единый способ работы с любым контейнером STL (векторами, списками, картами и т.д.).</p>
</li>
<li class="has-line-data" data-line-start="2998" data-line-end="3001">
<p class="has-line-data" data-line-start="2998" data-line-end="3000"><strong>Совместимость с алгоритмами STL:</strong><br>
Большинство стандартных алгоритмов работают с итераторами, что упрощает их применение и делает код более читаемым.</p>
</li>
<li class="has-line-data" data-line-start="3001" data-line-end="3004">
<p class="has-line-data" data-line-start="3001" data-line-end="3003"><strong>Инкапсуляция структуры данных:</strong><br>
Программисту не нужно знать внутреннюю реализацию контейнера — итераторы скрывают эту сложность.</p>
</li>
<li class="has-line-data" data-line-start="3004" data-line-end="3006">
<p class="has-line-data" data-line-start="3004" data-line-end="3006"><strong>Гибкость:</strong><br>
Различные виды итераторов позволяют выбирать подходящий метод доступа в зависимости от типа контейнера и выполняемой задачи.</p>
</li>
</ol>
<hr>
<p class="has-line-data" data-line-start="3010" data-line-end="3012"><strong>Заключение:</strong><br>
Итераторы играют ключевую роль в стандарте STL, позволяя писать более универсальный, модульный и переносимый код. Благодаря итераторам разработчики могут сосредоточиться на логике обработки данных, не задумываясь о внутренней структуре контейнеров.</p>
<p class="has-line-data" data-line-start="3014" data-line-end="3015"><strong>29. Библиотека <code>&lt;algorithm&gt;</code>, основные функции.</strong></p>
<p class="has-line-data" data-line-start="3016" data-line-end="3018"><strong>Общее описание:</strong><br>
Библиотека <code>&lt;algorithm&gt;</code> предоставляет набор стандартных алгоритмов для обработки данных, таких как поиск, сортировка, копирование, удаление, трансформации и многое другое. Эти алгоритмы работают с любыми контейнерами STL, предоставляющими итераторы, что делает их универсальными и легко применимыми.</p>
<hr>
<p class="has-line-data" data-line-start="3021" data-line-end="3022"><strong>Основные категории алгоритмов:</strong></p>
<ol>
<li class="has-line-data" data-line-start="3023" data-line-end="3030">
<p class="has-line-data" data-line-start="3023" data-line-end="3024"><strong>Поиск и проверка:</strong></p>
<ul>
<li class="has-line-data" data-line-start="3025" data-line-end="3026"><code>std::find</code>: ищет элемент с заданным значением.</li>
<li class="has-line-data" data-line-start="3026" data-line-end="3027"><code>std::find_if</code>: ищет первый элемент, удовлетворяющий предикату.</li>
<li class="has-line-data" data-line-start="3027" data-line-end="3028"><code>std::count</code>: подсчитывает количество элементов с заданным значением.</li>
<li class="has-line-data" data-line-start="3028" data-line-end="3029"><code>std::count_if</code>: подсчитывает элементы, удовлетворяющие предикату.</li>
<li class="has-line-data" data-line-start="3029" data-line-end="3030"><code>std::any_of</code>, <code>std::all_of</code>, <code>std::none_of</code>: проверяют, соответствуют ли элементы определённым условиям.</li>
</ul>
</li>
<li class="has-line-data" data-line-start="3030" data-line-end="3036">
<p class="has-line-data" data-line-start="3030" data-line-end="3031"><strong>Сортировка и упорядочивание:</strong></p>
<ul>
<li class="has-line-data" data-line-start="3032" data-line-end="3033"><code>std::sort</code>: сортирует диапазон элементов.</li>
<li class="has-line-data" data-line-start="3033" data-line-end="3034"><code>std::partial_sort</code>: сортирует часть диапазона.</li>
<li class="has-line-data" data-line-start="3034" data-line-end="3035"><code>std::nth_element</code>: переставляет элементы так, чтобы элемент на указанной позиции оказался в своей окончательной отсортированной позиции.</li>
<li class="has-line-data" data-line-start="3035" data-line-end="3036"><code>std::is_sorted</code>: проверяет, отсортирован ли диапазон.</li>
</ul>
</li>
<li class="has-line-data" data-line-start="3036" data-line-end="3041">
<p class="has-line-data" data-line-start="3036" data-line-end="3037"><strong>Копирование и перемещение:</strong></p>
<ul>
<li class="has-line-data" data-line-start="3038" data-line-end="3039"><code>std::copy</code>: копирует элементы из одного диапазона в другой.</li>
<li class="has-line-data" data-line-start="3039" data-line-end="3040"><code>std::copy_if</code>: копирует только те элементы, которые удовлетворяют предикату.</li>
<li class="has-line-data" data-line-start="3040" data-line-end="3041"><code>std::move</code>: перемещает элементы из одного диапазона в другой.</li>
</ul>
</li>
<li class="has-line-data" data-line-start="3041" data-line-end="3047">
<p class="has-line-data" data-line-start="3041" data-line-end="3042"><strong>Удаление и замена:</strong></p>
<ul>
<li class="has-line-data" data-line-start="3043" data-line-end="3044"><code>std::remove</code>: переставляет элементы так, чтобы удалить определённые значения.</li>
<li class="has-line-data" data-line-start="3044" data-line-end="3045"><code>std::remove_if</code>: удаляет элементы, удовлетворяющие предикату.</li>
<li class="has-line-data" data-line-start="3045" data-line-end="3046"><code>std::replace</code>: заменяет все вхождения одного значения другим.</li>
<li class="has-line-data" data-line-start="3046" data-line-end="3047"><code>std::replace_if</code>: заменяет элементы, удовлетворяющие предикату.</li>
</ul>
</li>
<li class="has-line-data" data-line-start="3047" data-line-end="3051">
<p class="has-line-data" data-line-start="3047" data-line-end="3048"><strong>Трансформация:</strong></p>
<ul>
<li class="has-line-data" data-line-start="3049" data-line-end="3050"><code>std::transform</code>: применяет функцию ко всем элементам диапазона и записывает результаты в новый диапазон.</li>
<li class="has-line-data" data-line-start="3050" data-line-end="3051"><code>std::for_each</code>: применяет функцию ко всем элементам диапазона, не изменяя сам контейнер.</li>
</ul>
</li>
<li class="has-line-data" data-line-start="3051" data-line-end="3055">
<p class="has-line-data" data-line-start="3051" data-line-end="3052"><strong>Слияние, пересечение и разность:</strong></p>
<ul>
<li class="has-line-data" data-line-start="3053" data-line-end="3054"><code>std::merge</code>: объединяет два отсортированных диапазона.</li>
<li class="has-line-data" data-line-start="3054" data-line-end="3055"><code>std::set_union</code>, <code>std::set_intersection</code>, <code>std::set_difference</code>, <code>std::set_symmetric_difference</code>: операции над множествами.</li>
</ul>
</li>
<li class="has-line-data" data-line-start="3055" data-line-end="3062">
<p class="has-line-data" data-line-start="3055" data-line-end="3056"><strong>Разное:</strong></p>
<ul>
<li class="has-line-data" data-line-start="3057" data-line-end="3058"><code>std::reverse</code>: разворачивает порядок элементов в диапазоне.</li>
<li class="has-line-data" data-line-start="3058" data-line-end="3059"><code>std::shuffle</code>: случайным образом перемешивает элементы.</li>
<li class="has-line-data" data-line-start="3059" data-line-end="3060"><code>std::rotate</code>: циклически перемещает элементы.</li>
<li class="has-line-data" data-line-start="3060" data-line-end="3062"><code>std::unique</code>: удаляет последовательные дубликаты.</li>
</ul>
</li>
</ol>
<hr>
<p class="has-line-data" data-line-start="3064" data-line-end="3065"><strong>Примеры использования:</strong></p>
<ol>
<li class="has-line-data" data-line-start="3066" data-line-end="3085">
<p class="has-line-data" data-line-start="3066" data-line-end="3067"><strong>Поиск элемента:</strong></p>
<pre><code class="has-line-data" data-line-start="3069" data-line-end="3084" class="language-cpp"><span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; vec = {<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>};
    <span class="hljs-keyword">auto</span> it = <span class="hljs-built_in">std</span>::find(vec.begin(), vec.end(), <span class="hljs-number">30</span>);
    <span class="hljs-keyword">if</span> (it != vec.end()) {
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Found: "</span> &lt;&lt; *it &lt;&lt; <span class="hljs-string">'\n'</span>;
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Not found.\n"</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
</li>
<li class="has-line-data" data-line-start="3085" data-line-end="3102">
<p class="has-line-data" data-line-start="3085" data-line-end="3086"><strong>Сортировка:</strong></p>
<pre><code class="has-line-data" data-line-start="3088" data-line-end="3101" class="language-cpp"><span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; vec = {<span class="hljs-number">50</span>, <span class="hljs-number">10</span>, <span class="hljs-number">40</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>};
    <span class="hljs-built_in">std</span>::sort(vec.begin(), vec.end());
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> n : vec) {
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="hljs-string">" "</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
</li>
<li class="has-line-data" data-line-start="3102" data-line-end="3122">
<p class="has-line-data" data-line-start="3102" data-line-end="3103"><strong>Копирование с условием:</strong></p>
<pre><code class="has-line-data" data-line-start="3105" data-line-end="3121" class="language-cpp"><span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; vec = {<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>};
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; result;
    <span class="hljs-built_in">std</span>::copy_if(vec.begin(), vec.end(), <span class="hljs-built_in">std</span>::back_inserter(result), [](<span class="hljs-keyword">int</span> n) {
        <span class="hljs-keyword">return</span> n &gt; <span class="hljs-number">20</span>;
    });
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> n : result) {
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="hljs-string">" "</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
</li>
<li class="has-line-data" data-line-start="3122" data-line-end="3138">
<p class="has-line-data" data-line-start="3122" data-line-end="3123"><strong>Замена значений:</strong></p>
<pre><code class="has-line-data" data-line-start="3125" data-line-end="3138" class="language-cpp"><span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; vec = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>};
    <span class="hljs-built_in">std</span>::replace(vec.begin(), vec.end(), <span class="hljs-number">2</span>, <span class="hljs-number">42</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> n : vec) {
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="hljs-string">" "</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
</li>
</ol>
<hr>
<p class="has-line-data" data-line-start="3142" data-line-end="3144"><strong>Заключение:</strong><br>
Библиотека <code>&lt;algorithm&gt;</code> предоставляет множество универсальных функций, упрощающих работу с контейнерами STL. Эти алгоритмы являются основой современного C++ программирования, поскольку они делают код более компактным, читаемым и эффективным.</p>
<p class="has-line-data" data-line-start="3146" data-line-end="3147"><strong>30. Средства обработки исключений в языке С++.</strong></p>
<p class="has-line-data" data-line-start="3148" data-line-end="3150"><strong>Общее описание:</strong><br>
Исключения в C++ предоставляют механизм обработки ошибок, который позволяет отделить основной код от кода обработки ошибок. Это делает программы более устойчивыми и удобными в сопровождении. Вместо использования кодов возврата или специальных флагов, исключения позволяют “выбрасывать” и “ловить” ошибки с помощью ключевых слов <code>throw</code>, <code>try</code> и <code>catch</code>.</p>
<hr>
<p class="has-line-data" data-line-start="3153" data-line-end="3154"><strong>Основные элементы обработки исключений:</strong></p>
<ol>
<li class="has-line-data" data-line-start="3155" data-line-end="3167">
<p class="has-line-data" data-line-start="3155" data-line-end="3156"><strong>Ключевое слово <code>throw</code>:</strong></p>
<ul>
<li class="has-line-data" data-line-start="3157" data-line-end="3158">
<p class="has-line-data" data-line-start="3157" data-line-end="3158">Используется для генерации (выброса) исключения.</p>
</li>
<li class="has-line-data" data-line-start="3158" data-line-end="3159">
<p class="has-line-data" data-line-start="3158" data-line-end="3159">Может “выбрасывать” любые типы данных: встроенные типы (например, <code>int</code>, <code>char</code>) или объекты пользовательских классов.</p>
</li>
<li class="has-line-data" data-line-start="3159" data-line-end="3167">
<p class="has-line-data" data-line-start="3159" data-line-end="3160">Например:</p>
<pre><code class="has-line-data" data-line-start="3162" data-line-end="3166" class="language-cpp"><span class="hljs-keyword">throw</span> <span class="hljs-number">42</span>;           <span class="hljs-comment">// выброс исключения типа int</span>
<span class="hljs-keyword">throw</span> <span class="hljs-string">"Error!"</span>;      <span class="hljs-comment">// выброс исключения типа const char*</span>
<span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>(<span class="hljs-string">"Error!"</span>); <span class="hljs-comment">// выброс исключения типа std::string</span>
</code></pre>
</li>
</ul>
</li>
<li class="has-line-data" data-line-start="3167" data-line-end="3171">
<p class="has-line-data" data-line-start="3167" data-line-end="3168"><strong>Ключевое слово <code>try</code>:</strong></p>
<ul>
<li class="has-line-data" data-line-start="3169" data-line-end="3170">Определяет блок кода, в котором могут возникать исключения.</li>
<li class="has-line-data" data-line-start="3170" data-line-end="3171">За блоком <code>try</code> следует один или несколько блоков <code>catch</code>, обрабатывающих возможные исключения.</li>
</ul>
</li>
<li class="has-line-data" data-line-start="3171" data-line-end="3188">
<p class="has-line-data" data-line-start="3171" data-line-end="3172"><strong>Ключевое слово <code>catch</code>:</strong></p>
<ul>
<li class="has-line-data" data-line-start="3173" data-line-end="3174">
<p class="has-line-data" data-line-start="3173" data-line-end="3174">Используется для перехвата исключений.</p>
</li>
<li class="has-line-data" data-line-start="3174" data-line-end="3175">
<p class="has-line-data" data-line-start="3174" data-line-end="3175">Указывает, какие типы исключений можно обработать.</p>
</li>
<li class="has-line-data" data-line-start="3175" data-line-end="3176">
<p class="has-line-data" data-line-start="3175" data-line-end="3176">Может быть несколько блоков <code>catch</code> для разных типов исключений.</p>
</li>
<li class="has-line-data" data-line-start="3176" data-line-end="3188">
<p class="has-line-data" data-line-start="3176" data-line-end="3177">Например:</p>
<pre><code class="has-line-data" data-line-start="3179" data-line-end="3188" class="language-cpp"><span class="hljs-keyword">try</span> {
    <span class="hljs-comment">// Код, который может выбросить исключение</span>
    <span class="hljs-keyword">throw</span> <span class="hljs-number">42</span>;
} <span class="hljs-keyword">catch</span> (<span class="hljs-keyword">int</span> err) {
    <span class="hljs-comment">// Обработка исключения типа int</span>
} <span class="hljs-keyword">catch</span> (<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; err) {
    <span class="hljs-comment">// Обработка исключения типа std::string</span>
}
</code></pre>
</li>
</ul>
</li>
</ol>
<hr>
<p class="has-line-data" data-line-start="3192" data-line-end="3193"><strong>Пример обработки исключений:</strong></p>
<pre><code class="has-line-data" data-line-start="3195" data-line-end="3214" class="language-cpp"><span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">try</span> {
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> input;
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cin</span> &gt;&gt; input;
        <span class="hljs-keyword">if</span> (input != <span class="hljs-string">"ok"</span>) {
            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::runtime_error(<span class="hljs-string">"Invalid input!"</span>);
        }
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Input is valid.\n"</span>;
    } <span class="hljs-keyword">catch</span> (<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::runtime_error&amp; e) {
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"Caught exception: "</span> &lt;&lt; e.what() &lt;&lt; <span class="hljs-string">'\n'</span>;
    } <span class="hljs-keyword">catch</span> (...) {
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"Caught unknown exception.\n"</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p class="has-line-data" data-line-start="3215" data-line-end="3216"><strong>Особенности:</strong></p>
<ul>
<li class="has-line-data" data-line-start="3217" data-line-end="3231">
<p class="has-line-data" data-line-start="3217" data-line-end="3219"><strong>Полиморфизм исключений:</strong><br>
Если класс исключения наследуется от другого класса, можно ловить исключения базового типа.</p>
<pre><code class="has-line-data" data-line-start="3221" data-line-end="3230" class="language-cpp"><span class="hljs-keyword">class</span> BaseException {};
<span class="hljs-keyword">class</span> DerivedException : <span class="hljs-keyword">public</span> BaseException {};

<span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">throw</span> DerivedException();
} <span class="hljs-keyword">catch</span> (BaseException&amp;) {
    <span class="hljs-comment">// Перехватится исключение DerivedException</span>
}
</code></pre>
</li>
<li class="has-line-data" data-line-start="3231" data-line-end="3242">
<p class="has-line-data" data-line-start="3231" data-line-end="3233"><strong>Обработка любых исключений:</strong><br>
Блок <code>catch(...)</code> перехватывает исключения любого типа.</p>
<pre><code class="has-line-data" data-line-start="3235" data-line-end="3241" class="language-cpp"><span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">throw</span> <span class="hljs-number">3.14</span>;
} <span class="hljs-keyword">catch</span> (...) {
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"Unknown exception caught.\n"</span>;
}
</code></pre>
</li>
<li class="has-line-data" data-line-start="3242" data-line-end="3245">
<p class="has-line-data" data-line-start="3242" data-line-end="3244"><strong>Выход из <code>try</code>-блока:</strong><br>
Если в <code>try</code>-блоке возникло исключение, выполнение переходит в соответствующий <code>catch</code>-блок. Код после точки <code>throw</code> в <code>try</code>-блоке не выполняется.</p>
</li>
<li class="has-line-data" data-line-start="3245" data-line-end="3247">
<p class="has-line-data" data-line-start="3245" data-line-end="3247"><strong>Порядок блоков <code>catch</code>:</strong><br>
Важно расположить более конкретные блоки <code>catch</code> перед более общими. Например, сначала обрабатывать пользовательские типы, затем стандартные типы, а в конце <code>catch(...)</code>.</p>
</li>
</ul>
<hr>
<p class="has-line-data" data-line-start="3251" data-line-end="3252"><strong>Исключения и деструкторы:</strong></p>
<ul>
<li class="has-line-data" data-line-start="3253" data-line-end="3254">Если во время выполнения <code>try</code>-блока возникают исключения, все локальные объекты, созданные до <code>throw</code>, корректно уничтожаются.</li>
<li class="has-line-data" data-line-start="3254" data-line-end="3256">Это помогает избежать утечек памяти и других ресурсов.</li>
</ul>
<p class="has-line-data" data-line-start="3256" data-line-end="3257"><strong>Пример:</strong></p>
<pre><code class="has-line-data" data-line-start="3259" data-line-end="3278" class="language-cpp"><span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdexcept&gt;</span></span>

<span class="hljs-keyword">class</span> Resource {
<span class="hljs-keyword">public</span>:
    Resource() { <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Resource acquired\n"</span>; }
    ~Resource() { <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Resource released\n"</span>; }
};

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">try</span> {
        Resource res;
        <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::runtime_error(<span class="hljs-string">"Something went wrong"</span>);
    } <span class="hljs-keyword">catch</span> (<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::exception&amp; e) {
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"Exception: "</span> &lt;&lt; e.what() &lt;&lt; <span class="hljs-string">'\n'</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p class="has-line-data" data-line-start="3279" data-line-end="3280">Вывод:</p>
<pre><code class="has-line-data" data-line-start="3282" data-line-end="3286" class="language-makefile">Resource acquired
Resource released
Exception: Something went wrong
</code></pre>
<hr>
<p class="has-line-data" data-line-start="3289" data-line-end="3290"><strong>Заключение:</strong> Средства обработки исключений в C++ позволяют писать более надёжный и понятный код, отделяя основной функционал от кода обработки ошибок. Используя <code>try</code>, <code>throw</code> и <code>catch</code>, можно централизовать обработку ошибок, облегчить отладку и повысить стабильность программы.</p>
<hr>

</body></html>
